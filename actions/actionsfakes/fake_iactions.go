// Code generated by counterfeiter. DO NOT EDIT.
package actionsfakes

import (
	"context"
	"sync"

	"github.com/batchcorp/plumber-schemas/build/go/protos/opts"
	"github.com/batchcorp/plumber/actions"
	"github.com/batchcorp/plumber/server/types"
)

type FakeIActions struct {
	CreateRelayStub        func(context.Context, *opts.RelayOptions) (*types.Relay, error)
	createRelayMutex       sync.RWMutex
	createRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	createRelayReturns struct {
		result1 *types.Relay
		result2 error
	}
	createRelayReturnsOnCall map[int]struct {
		result1 *types.Relay
		result2 error
	}
	CreateTunnelStub        func(context.Context, *opts.TunnelOptions) (*types.Tunnel, error)
	createTunnelMutex       sync.RWMutex
	createTunnelArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.TunnelOptions
	}
	createTunnelReturns struct {
		result1 *types.Tunnel
		result2 error
	}
	createTunnelReturnsOnCall map[int]struct {
		result1 *types.Tunnel
		result2 error
	}
	DeleteRelayStub        func(context.Context, string) (*types.Relay, error)
	deleteRelayMutex       sync.RWMutex
	deleteRelayArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteRelayReturns struct {
		result1 *types.Relay
		result2 error
	}
	deleteRelayReturnsOnCall map[int]struct {
		result1 *types.Relay
		result2 error
	}
	DeleteTunnelStub        func(context.Context, string) error
	deleteTunnelMutex       sync.RWMutex
	deleteTunnelArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteTunnelReturns struct {
		result1 error
	}
	deleteTunnelReturnsOnCall map[int]struct {
		result1 error
	}
	ResumeRelayStub        func(context.Context, string) (*types.Relay, error)
	resumeRelayMutex       sync.RWMutex
	resumeRelayArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	resumeRelayReturns struct {
		result1 *types.Relay
		result2 error
	}
	resumeRelayReturnsOnCall map[int]struct {
		result1 *types.Relay
		result2 error
	}
	ResumeTunnelStub        func(context.Context, string) (*types.Tunnel, error)
	resumeTunnelMutex       sync.RWMutex
	resumeTunnelArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	resumeTunnelReturns struct {
		result1 *types.Tunnel
		result2 error
	}
	resumeTunnelReturnsOnCall map[int]struct {
		result1 *types.Tunnel
		result2 error
	}
	StopRelayStub        func(context.Context, string) (*types.Relay, error)
	stopRelayMutex       sync.RWMutex
	stopRelayArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	stopRelayReturns struct {
		result1 *types.Relay
		result2 error
	}
	stopRelayReturnsOnCall map[int]struct {
		result1 *types.Relay
		result2 error
	}
	StopTunnelStub        func(context.Context, string) (*types.Tunnel, error)
	stopTunnelMutex       sync.RWMutex
	stopTunnelArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	stopTunnelReturns struct {
		result1 *types.Tunnel
		result2 error
	}
	stopTunnelReturnsOnCall map[int]struct {
		result1 *types.Tunnel
		result2 error
	}
	UpdateRelayStub        func(context.Context, *opts.RelayOptions) (*types.Relay, error)
	updateRelayMutex       sync.RWMutex
	updateRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	updateRelayReturns struct {
		result1 *types.Relay
		result2 error
	}
	updateRelayReturnsOnCall map[int]struct {
		result1 *types.Relay
		result2 error
	}
	UpdateTunnelStub        func(context.Context, string, *opts.TunnelOptions) (*types.Tunnel, error)
	updateTunnelMutex       sync.RWMutex
	updateTunnelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *opts.TunnelOptions
	}
	updateTunnelReturns struct {
		result1 *types.Tunnel
		result2 error
	}
	updateTunnelReturnsOnCall map[int]struct {
		result1 *types.Tunnel
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIActions) CreateRelay(arg1 context.Context, arg2 *opts.RelayOptions) (*types.Relay, error) {
	fake.createRelayMutex.Lock()
	ret, specificReturn := fake.createRelayReturnsOnCall[len(fake.createRelayArgsForCall)]
	fake.createRelayArgsForCall = append(fake.createRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.CreateRelayStub
	fakeReturns := fake.createRelayReturns
	fake.recordInvocation("CreateRelay", []interface{}{arg1, arg2})
	fake.createRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) CreateRelayCallCount() int {
	fake.createRelayMutex.RLock()
	defer fake.createRelayMutex.RUnlock()
	return len(fake.createRelayArgsForCall)
}

func (fake *FakeIActions) CreateRelayCalls(stub func(context.Context, *opts.RelayOptions) (*types.Relay, error)) {
	fake.createRelayMutex.Lock()
	defer fake.createRelayMutex.Unlock()
	fake.CreateRelayStub = stub
}

func (fake *FakeIActions) CreateRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.createRelayMutex.RLock()
	defer fake.createRelayMutex.RUnlock()
	argsForCall := fake.createRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) CreateRelayReturns(result1 *types.Relay, result2 error) {
	fake.createRelayMutex.Lock()
	defer fake.createRelayMutex.Unlock()
	fake.CreateRelayStub = nil
	fake.createRelayReturns = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) CreateRelayReturnsOnCall(i int, result1 *types.Relay, result2 error) {
	fake.createRelayMutex.Lock()
	defer fake.createRelayMutex.Unlock()
	fake.CreateRelayStub = nil
	if fake.createRelayReturnsOnCall == nil {
		fake.createRelayReturnsOnCall = make(map[int]struct {
			result1 *types.Relay
			result2 error
		})
	}
	fake.createRelayReturnsOnCall[i] = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) CreateTunnel(arg1 context.Context, arg2 *opts.TunnelOptions) (*types.Tunnel, error) {
	fake.createTunnelMutex.Lock()
	ret, specificReturn := fake.createTunnelReturnsOnCall[len(fake.createTunnelArgsForCall)]
	fake.createTunnelArgsForCall = append(fake.createTunnelArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.TunnelOptions
	}{arg1, arg2})
	stub := fake.CreateTunnelStub
	fakeReturns := fake.createTunnelReturns
	fake.recordInvocation("CreateTunnel", []interface{}{arg1, arg2})
	fake.createTunnelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) CreateTunnelCallCount() int {
	fake.createTunnelMutex.RLock()
	defer fake.createTunnelMutex.RUnlock()
	return len(fake.createTunnelArgsForCall)
}

func (fake *FakeIActions) CreateTunnelCalls(stub func(context.Context, *opts.TunnelOptions) (*types.Tunnel, error)) {
	fake.createTunnelMutex.Lock()
	defer fake.createTunnelMutex.Unlock()
	fake.CreateTunnelStub = stub
}

func (fake *FakeIActions) CreateTunnelArgsForCall(i int) (context.Context, *opts.TunnelOptions) {
	fake.createTunnelMutex.RLock()
	defer fake.createTunnelMutex.RUnlock()
	argsForCall := fake.createTunnelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) CreateTunnelReturns(result1 *types.Tunnel, result2 error) {
	fake.createTunnelMutex.Lock()
	defer fake.createTunnelMutex.Unlock()
	fake.CreateTunnelStub = nil
	fake.createTunnelReturns = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) CreateTunnelReturnsOnCall(i int, result1 *types.Tunnel, result2 error) {
	fake.createTunnelMutex.Lock()
	defer fake.createTunnelMutex.Unlock()
	fake.CreateTunnelStub = nil
	if fake.createTunnelReturnsOnCall == nil {
		fake.createTunnelReturnsOnCall = make(map[int]struct {
			result1 *types.Tunnel
			result2 error
		})
	}
	fake.createTunnelReturnsOnCall[i] = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) DeleteRelay(arg1 context.Context, arg2 string) (*types.Relay, error) {
	fake.deleteRelayMutex.Lock()
	ret, specificReturn := fake.deleteRelayReturnsOnCall[len(fake.deleteRelayArgsForCall)]
	fake.deleteRelayArgsForCall = append(fake.deleteRelayArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteRelayStub
	fakeReturns := fake.deleteRelayReturns
	fake.recordInvocation("DeleteRelay", []interface{}{arg1, arg2})
	fake.deleteRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) DeleteRelayCallCount() int {
	fake.deleteRelayMutex.RLock()
	defer fake.deleteRelayMutex.RUnlock()
	return len(fake.deleteRelayArgsForCall)
}

func (fake *FakeIActions) DeleteRelayCalls(stub func(context.Context, string) (*types.Relay, error)) {
	fake.deleteRelayMutex.Lock()
	defer fake.deleteRelayMutex.Unlock()
	fake.DeleteRelayStub = stub
}

func (fake *FakeIActions) DeleteRelayArgsForCall(i int) (context.Context, string) {
	fake.deleteRelayMutex.RLock()
	defer fake.deleteRelayMutex.RUnlock()
	argsForCall := fake.deleteRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) DeleteRelayReturns(result1 *types.Relay, result2 error) {
	fake.deleteRelayMutex.Lock()
	defer fake.deleteRelayMutex.Unlock()
	fake.DeleteRelayStub = nil
	fake.deleteRelayReturns = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) DeleteRelayReturnsOnCall(i int, result1 *types.Relay, result2 error) {
	fake.deleteRelayMutex.Lock()
	defer fake.deleteRelayMutex.Unlock()
	fake.DeleteRelayStub = nil
	if fake.deleteRelayReturnsOnCall == nil {
		fake.deleteRelayReturnsOnCall = make(map[int]struct {
			result1 *types.Relay
			result2 error
		})
	}
	fake.deleteRelayReturnsOnCall[i] = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) DeleteTunnel(arg1 context.Context, arg2 string) error {
	fake.deleteTunnelMutex.Lock()
	ret, specificReturn := fake.deleteTunnelReturnsOnCall[len(fake.deleteTunnelArgsForCall)]
	fake.deleteTunnelArgsForCall = append(fake.deleteTunnelArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteTunnelStub
	fakeReturns := fake.deleteTunnelReturns
	fake.recordInvocation("DeleteTunnel", []interface{}{arg1, arg2})
	fake.deleteTunnelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIActions) DeleteTunnelCallCount() int {
	fake.deleteTunnelMutex.RLock()
	defer fake.deleteTunnelMutex.RUnlock()
	return len(fake.deleteTunnelArgsForCall)
}

func (fake *FakeIActions) DeleteTunnelCalls(stub func(context.Context, string) error) {
	fake.deleteTunnelMutex.Lock()
	defer fake.deleteTunnelMutex.Unlock()
	fake.DeleteTunnelStub = stub
}

func (fake *FakeIActions) DeleteTunnelArgsForCall(i int) (context.Context, string) {
	fake.deleteTunnelMutex.RLock()
	defer fake.deleteTunnelMutex.RUnlock()
	argsForCall := fake.deleteTunnelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) DeleteTunnelReturns(result1 error) {
	fake.deleteTunnelMutex.Lock()
	defer fake.deleteTunnelMutex.Unlock()
	fake.DeleteTunnelStub = nil
	fake.deleteTunnelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIActions) DeleteTunnelReturnsOnCall(i int, result1 error) {
	fake.deleteTunnelMutex.Lock()
	defer fake.deleteTunnelMutex.Unlock()
	fake.DeleteTunnelStub = nil
	if fake.deleteTunnelReturnsOnCall == nil {
		fake.deleteTunnelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTunnelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIActions) ResumeRelay(arg1 context.Context, arg2 string) (*types.Relay, error) {
	fake.resumeRelayMutex.Lock()
	ret, specificReturn := fake.resumeRelayReturnsOnCall[len(fake.resumeRelayArgsForCall)]
	fake.resumeRelayArgsForCall = append(fake.resumeRelayArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ResumeRelayStub
	fakeReturns := fake.resumeRelayReturns
	fake.recordInvocation("ResumeRelay", []interface{}{arg1, arg2})
	fake.resumeRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) ResumeRelayCallCount() int {
	fake.resumeRelayMutex.RLock()
	defer fake.resumeRelayMutex.RUnlock()
	return len(fake.resumeRelayArgsForCall)
}

func (fake *FakeIActions) ResumeRelayCalls(stub func(context.Context, string) (*types.Relay, error)) {
	fake.resumeRelayMutex.Lock()
	defer fake.resumeRelayMutex.Unlock()
	fake.ResumeRelayStub = stub
}

func (fake *FakeIActions) ResumeRelayArgsForCall(i int) (context.Context, string) {
	fake.resumeRelayMutex.RLock()
	defer fake.resumeRelayMutex.RUnlock()
	argsForCall := fake.resumeRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) ResumeRelayReturns(result1 *types.Relay, result2 error) {
	fake.resumeRelayMutex.Lock()
	defer fake.resumeRelayMutex.Unlock()
	fake.ResumeRelayStub = nil
	fake.resumeRelayReturns = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) ResumeRelayReturnsOnCall(i int, result1 *types.Relay, result2 error) {
	fake.resumeRelayMutex.Lock()
	defer fake.resumeRelayMutex.Unlock()
	fake.ResumeRelayStub = nil
	if fake.resumeRelayReturnsOnCall == nil {
		fake.resumeRelayReturnsOnCall = make(map[int]struct {
			result1 *types.Relay
			result2 error
		})
	}
	fake.resumeRelayReturnsOnCall[i] = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) ResumeTunnel(arg1 context.Context, arg2 string) (*types.Tunnel, error) {
	fake.resumeTunnelMutex.Lock()
	ret, specificReturn := fake.resumeTunnelReturnsOnCall[len(fake.resumeTunnelArgsForCall)]
	fake.resumeTunnelArgsForCall = append(fake.resumeTunnelArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ResumeTunnelStub
	fakeReturns := fake.resumeTunnelReturns
	fake.recordInvocation("ResumeTunnel", []interface{}{arg1, arg2})
	fake.resumeTunnelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) ResumeTunnelCallCount() int {
	fake.resumeTunnelMutex.RLock()
	defer fake.resumeTunnelMutex.RUnlock()
	return len(fake.resumeTunnelArgsForCall)
}

func (fake *FakeIActions) ResumeTunnelCalls(stub func(context.Context, string) (*types.Tunnel, error)) {
	fake.resumeTunnelMutex.Lock()
	defer fake.resumeTunnelMutex.Unlock()
	fake.ResumeTunnelStub = stub
}

func (fake *FakeIActions) ResumeTunnelArgsForCall(i int) (context.Context, string) {
	fake.resumeTunnelMutex.RLock()
	defer fake.resumeTunnelMutex.RUnlock()
	argsForCall := fake.resumeTunnelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) ResumeTunnelReturns(result1 *types.Tunnel, result2 error) {
	fake.resumeTunnelMutex.Lock()
	defer fake.resumeTunnelMutex.Unlock()
	fake.ResumeTunnelStub = nil
	fake.resumeTunnelReturns = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) ResumeTunnelReturnsOnCall(i int, result1 *types.Tunnel, result2 error) {
	fake.resumeTunnelMutex.Lock()
	defer fake.resumeTunnelMutex.Unlock()
	fake.ResumeTunnelStub = nil
	if fake.resumeTunnelReturnsOnCall == nil {
		fake.resumeTunnelReturnsOnCall = make(map[int]struct {
			result1 *types.Tunnel
			result2 error
		})
	}
	fake.resumeTunnelReturnsOnCall[i] = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) StopRelay(arg1 context.Context, arg2 string) (*types.Relay, error) {
	fake.stopRelayMutex.Lock()
	ret, specificReturn := fake.stopRelayReturnsOnCall[len(fake.stopRelayArgsForCall)]
	fake.stopRelayArgsForCall = append(fake.stopRelayArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.StopRelayStub
	fakeReturns := fake.stopRelayReturns
	fake.recordInvocation("StopRelay", []interface{}{arg1, arg2})
	fake.stopRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) StopRelayCallCount() int {
	fake.stopRelayMutex.RLock()
	defer fake.stopRelayMutex.RUnlock()
	return len(fake.stopRelayArgsForCall)
}

func (fake *FakeIActions) StopRelayCalls(stub func(context.Context, string) (*types.Relay, error)) {
	fake.stopRelayMutex.Lock()
	defer fake.stopRelayMutex.Unlock()
	fake.StopRelayStub = stub
}

func (fake *FakeIActions) StopRelayArgsForCall(i int) (context.Context, string) {
	fake.stopRelayMutex.RLock()
	defer fake.stopRelayMutex.RUnlock()
	argsForCall := fake.stopRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) StopRelayReturns(result1 *types.Relay, result2 error) {
	fake.stopRelayMutex.Lock()
	defer fake.stopRelayMutex.Unlock()
	fake.StopRelayStub = nil
	fake.stopRelayReturns = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) StopRelayReturnsOnCall(i int, result1 *types.Relay, result2 error) {
	fake.stopRelayMutex.Lock()
	defer fake.stopRelayMutex.Unlock()
	fake.StopRelayStub = nil
	if fake.stopRelayReturnsOnCall == nil {
		fake.stopRelayReturnsOnCall = make(map[int]struct {
			result1 *types.Relay
			result2 error
		})
	}
	fake.stopRelayReturnsOnCall[i] = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) StopTunnel(arg1 context.Context, arg2 string) (*types.Tunnel, error) {
	fake.stopTunnelMutex.Lock()
	ret, specificReturn := fake.stopTunnelReturnsOnCall[len(fake.stopTunnelArgsForCall)]
	fake.stopTunnelArgsForCall = append(fake.stopTunnelArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.StopTunnelStub
	fakeReturns := fake.stopTunnelReturns
	fake.recordInvocation("StopTunnel", []interface{}{arg1, arg2})
	fake.stopTunnelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) StopTunnelCallCount() int {
	fake.stopTunnelMutex.RLock()
	defer fake.stopTunnelMutex.RUnlock()
	return len(fake.stopTunnelArgsForCall)
}

func (fake *FakeIActions) StopTunnelCalls(stub func(context.Context, string) (*types.Tunnel, error)) {
	fake.stopTunnelMutex.Lock()
	defer fake.stopTunnelMutex.Unlock()
	fake.StopTunnelStub = stub
}

func (fake *FakeIActions) StopTunnelArgsForCall(i int) (context.Context, string) {
	fake.stopTunnelMutex.RLock()
	defer fake.stopTunnelMutex.RUnlock()
	argsForCall := fake.stopTunnelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) StopTunnelReturns(result1 *types.Tunnel, result2 error) {
	fake.stopTunnelMutex.Lock()
	defer fake.stopTunnelMutex.Unlock()
	fake.StopTunnelStub = nil
	fake.stopTunnelReturns = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) StopTunnelReturnsOnCall(i int, result1 *types.Tunnel, result2 error) {
	fake.stopTunnelMutex.Lock()
	defer fake.stopTunnelMutex.Unlock()
	fake.StopTunnelStub = nil
	if fake.stopTunnelReturnsOnCall == nil {
		fake.stopTunnelReturnsOnCall = make(map[int]struct {
			result1 *types.Tunnel
			result2 error
		})
	}
	fake.stopTunnelReturnsOnCall[i] = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) UpdateRelay(arg1 context.Context, arg2 *opts.RelayOptions) (*types.Relay, error) {
	fake.updateRelayMutex.Lock()
	ret, specificReturn := fake.updateRelayReturnsOnCall[len(fake.updateRelayArgsForCall)]
	fake.updateRelayArgsForCall = append(fake.updateRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.UpdateRelayStub
	fakeReturns := fake.updateRelayReturns
	fake.recordInvocation("UpdateRelay", []interface{}{arg1, arg2})
	fake.updateRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) UpdateRelayCallCount() int {
	fake.updateRelayMutex.RLock()
	defer fake.updateRelayMutex.RUnlock()
	return len(fake.updateRelayArgsForCall)
}

func (fake *FakeIActions) UpdateRelayCalls(stub func(context.Context, *opts.RelayOptions) (*types.Relay, error)) {
	fake.updateRelayMutex.Lock()
	defer fake.updateRelayMutex.Unlock()
	fake.UpdateRelayStub = stub
}

func (fake *FakeIActions) UpdateRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.updateRelayMutex.RLock()
	defer fake.updateRelayMutex.RUnlock()
	argsForCall := fake.updateRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIActions) UpdateRelayReturns(result1 *types.Relay, result2 error) {
	fake.updateRelayMutex.Lock()
	defer fake.updateRelayMutex.Unlock()
	fake.UpdateRelayStub = nil
	fake.updateRelayReturns = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) UpdateRelayReturnsOnCall(i int, result1 *types.Relay, result2 error) {
	fake.updateRelayMutex.Lock()
	defer fake.updateRelayMutex.Unlock()
	fake.UpdateRelayStub = nil
	if fake.updateRelayReturnsOnCall == nil {
		fake.updateRelayReturnsOnCall = make(map[int]struct {
			result1 *types.Relay
			result2 error
		})
	}
	fake.updateRelayReturnsOnCall[i] = struct {
		result1 *types.Relay
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) UpdateTunnel(arg1 context.Context, arg2 string, arg3 *opts.TunnelOptions) (*types.Tunnel, error) {
	fake.updateTunnelMutex.Lock()
	ret, specificReturn := fake.updateTunnelReturnsOnCall[len(fake.updateTunnelArgsForCall)]
	fake.updateTunnelArgsForCall = append(fake.updateTunnelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *opts.TunnelOptions
	}{arg1, arg2, arg3})
	stub := fake.UpdateTunnelStub
	fakeReturns := fake.updateTunnelReturns
	fake.recordInvocation("UpdateTunnel", []interface{}{arg1, arg2, arg3})
	fake.updateTunnelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIActions) UpdateTunnelCallCount() int {
	fake.updateTunnelMutex.RLock()
	defer fake.updateTunnelMutex.RUnlock()
	return len(fake.updateTunnelArgsForCall)
}

func (fake *FakeIActions) UpdateTunnelCalls(stub func(context.Context, string, *opts.TunnelOptions) (*types.Tunnel, error)) {
	fake.updateTunnelMutex.Lock()
	defer fake.updateTunnelMutex.Unlock()
	fake.UpdateTunnelStub = stub
}

func (fake *FakeIActions) UpdateTunnelArgsForCall(i int) (context.Context, string, *opts.TunnelOptions) {
	fake.updateTunnelMutex.RLock()
	defer fake.updateTunnelMutex.RUnlock()
	argsForCall := fake.updateTunnelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIActions) UpdateTunnelReturns(result1 *types.Tunnel, result2 error) {
	fake.updateTunnelMutex.Lock()
	defer fake.updateTunnelMutex.Unlock()
	fake.UpdateTunnelStub = nil
	fake.updateTunnelReturns = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) UpdateTunnelReturnsOnCall(i int, result1 *types.Tunnel, result2 error) {
	fake.updateTunnelMutex.Lock()
	defer fake.updateTunnelMutex.Unlock()
	fake.UpdateTunnelStub = nil
	if fake.updateTunnelReturnsOnCall == nil {
		fake.updateTunnelReturnsOnCall = make(map[int]struct {
			result1 *types.Tunnel
			result2 error
		})
	}
	fake.updateTunnelReturnsOnCall[i] = struct {
		result1 *types.Tunnel
		result2 error
	}{result1, result2}
}

func (fake *FakeIActions) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createRelayMutex.RLock()
	defer fake.createRelayMutex.RUnlock()
	fake.createTunnelMutex.RLock()
	defer fake.createTunnelMutex.RUnlock()
	fake.deleteRelayMutex.RLock()
	defer fake.deleteRelayMutex.RUnlock()
	fake.deleteTunnelMutex.RLock()
	defer fake.deleteTunnelMutex.RUnlock()
	fake.resumeRelayMutex.RLock()
	defer fake.resumeRelayMutex.RUnlock()
	fake.resumeTunnelMutex.RLock()
	defer fake.resumeTunnelMutex.RUnlock()
	fake.stopRelayMutex.RLock()
	defer fake.stopRelayMutex.RUnlock()
	fake.stopTunnelMutex.RLock()
	defer fake.stopTunnelMutex.RUnlock()
	fake.updateRelayMutex.RLock()
	defer fake.updateRelayMutex.RUnlock()
	fake.updateTunnelMutex.RLock()
	defer fake.updateTunnelMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIActions) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ actions.IActions = new(FakeIActions)
