// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kubemq_go.proto

package kubemq

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StreamRequestType int32

const (
	StreamRequestType_StreamRequestTypeUnknown StreamRequestType = 0
	StreamRequestType_ReceiveMessage           StreamRequestType = 1
	StreamRequestType_AckMessage               StreamRequestType = 2
	StreamRequestType_RejectMessage            StreamRequestType = 3
	StreamRequestType_ModifyVisibility         StreamRequestType = 4
	StreamRequestType_ResendMessage            StreamRequestType = 5
	StreamRequestType_SendModifiedMessage      StreamRequestType = 6
)

var StreamRequestType_name = map[int32]string{
	0: "StreamRequestTypeUnknown",
	1: "ReceiveMessage",
	2: "AckMessage",
	3: "RejectMessage",
	4: "ModifyVisibility",
	5: "ResendMessage",
	6: "SendModifiedMessage",
}

var StreamRequestType_value = map[string]int32{
	"StreamRequestTypeUnknown": 0,
	"ReceiveMessage":           1,
	"AckMessage":               2,
	"RejectMessage":            3,
	"ModifyVisibility":         4,
	"ResendMessage":            5,
	"SendModifiedMessage":      6,
}

func (x StreamRequestType) String() string {
	return proto.EnumName(StreamRequestType_name, int32(x))
}

func (StreamRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{0}
}

type QueuesDownstreamRequestType int32

const (
	QueuesDownstreamRequestType_PollRequestTypeUnknown QueuesDownstreamRequestType = 0
	QueuesDownstreamRequestType_Get                    QueuesDownstreamRequestType = 1
	QueuesDownstreamRequestType_AckAll                 QueuesDownstreamRequestType = 2
	QueuesDownstreamRequestType_AckRange               QueuesDownstreamRequestType = 3
	QueuesDownstreamRequestType_NAckAll                QueuesDownstreamRequestType = 4
	QueuesDownstreamRequestType_NAckRange              QueuesDownstreamRequestType = 5
	QueuesDownstreamRequestType_ReQueueAll             QueuesDownstreamRequestType = 6
	QueuesDownstreamRequestType_ReQueueRange           QueuesDownstreamRequestType = 7
	QueuesDownstreamRequestType_ActiveOffsets          QueuesDownstreamRequestType = 8
	QueuesDownstreamRequestType_TransactionStatus      QueuesDownstreamRequestType = 9
	QueuesDownstreamRequestType_CloseByClient          QueuesDownstreamRequestType = 10
	QueuesDownstreamRequestType_CloseByServer          QueuesDownstreamRequestType = 11
)

var QueuesDownstreamRequestType_name = map[int32]string{
	0:  "PollRequestTypeUnknown",
	1:  "Get",
	2:  "AckAll",
	3:  "AckRange",
	4:  "NAckAll",
	5:  "NAckRange",
	6:  "ReQueueAll",
	7:  "ReQueueRange",
	8:  "ActiveOffsets",
	9:  "TransactionStatus",
	10: "CloseByClient",
	11: "CloseByServer",
}

var QueuesDownstreamRequestType_value = map[string]int32{
	"PollRequestTypeUnknown": 0,
	"Get":                    1,
	"AckAll":                 2,
	"AckRange":               3,
	"NAckAll":                4,
	"NAckRange":              5,
	"ReQueueAll":             6,
	"ReQueueRange":           7,
	"ActiveOffsets":          8,
	"TransactionStatus":      9,
	"CloseByClient":          10,
	"CloseByServer":          11,
}

func (x QueuesDownstreamRequestType) String() string {
	return proto.EnumName(QueuesDownstreamRequestType_name, int32(x))
}

func (QueuesDownstreamRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{1}
}

type TopicsUpstreamRequestType int32

const (
	TopicsUpstreamRequestType_TopicsUpstreamRequestUnknown TopicsUpstreamRequestType = 0
	TopicsUpstreamRequestType_FireAndForget                TopicsUpstreamRequestType = 1
	TopicsUpstreamRequestType_SendAsync                    TopicsUpstreamRequestType = 2
	TopicsUpstreamRequestType_SendSync                     TopicsUpstreamRequestType = 3
)

var TopicsUpstreamRequestType_name = map[int32]string{
	0: "TopicsUpstreamRequestUnknown",
	1: "FireAndForget",
	2: "SendAsync",
	3: "SendSync",
}

var TopicsUpstreamRequestType_value = map[string]int32{
	"TopicsUpstreamRequestUnknown": 0,
	"FireAndForget":                1,
	"SendAsync":                    2,
	"SendSync":                     3,
}

func (x TopicsUpstreamRequestType) String() string {
	return proto.EnumName(TopicsUpstreamRequestType_name, int32(x))
}

func (TopicsUpstreamRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{2}
}

type TopicsSubscriptionStrategyType int32

const (
	TopicsSubscriptionStrategyType_SubscriptionStrategyTypeUndefined TopicsSubscriptionStrategyType = 0
	TopicsSubscriptionStrategyType_Range                             TopicsSubscriptionStrategyType = 1
	TopicsSubscriptionStrategyType_RoundRobin                        TopicsSubscriptionStrategyType = 2
	TopicsSubscriptionStrategyType_Sticky                            TopicsSubscriptionStrategyType = 3
)

var TopicsSubscriptionStrategyType_name = map[int32]string{
	0: "SubscriptionStrategyTypeUndefined",
	1: "Range",
	2: "RoundRobin",
	3: "Sticky",
}

var TopicsSubscriptionStrategyType_value = map[string]int32{
	"SubscriptionStrategyTypeUndefined": 0,
	"Range":                             1,
	"RoundRobin":                        2,
	"Sticky":                            3,
}

func (x TopicsSubscriptionStrategyType) String() string {
	return proto.EnumName(TopicsSubscriptionStrategyType_name, int32(x))
}

func (TopicsSubscriptionStrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{3}
}

type TopicsSubscriptionOffsetType int32

const (
	TopicsSubscriptionOffsetType_SubscriptionOffsetTypeUndefined TopicsSubscriptionOffsetType = 0
	TopicsSubscriptionOffsetType_StartNewOnly                    TopicsSubscriptionOffsetType = 1
	TopicsSubscriptionOffsetType_StartFromFirst                  TopicsSubscriptionOffsetType = 2
	TopicsSubscriptionOffsetType_StartFromLast                   TopicsSubscriptionOffsetType = 3
	TopicsSubscriptionOffsetType_StartAtSequence                 TopicsSubscriptionOffsetType = 4
	TopicsSubscriptionOffsetType_StartAtTime                     TopicsSubscriptionOffsetType = 5
	TopicsSubscriptionOffsetType_StartAtTimeDelta                TopicsSubscriptionOffsetType = 6
)

var TopicsSubscriptionOffsetType_name = map[int32]string{
	0: "SubscriptionOffsetTypeUndefined",
	1: "StartNewOnly",
	2: "StartFromFirst",
	3: "StartFromLast",
	4: "StartAtSequence",
	5: "StartAtTime",
	6: "StartAtTimeDelta",
}

var TopicsSubscriptionOffsetType_value = map[string]int32{
	"SubscriptionOffsetTypeUndefined": 0,
	"StartNewOnly":                    1,
	"StartFromFirst":                  2,
	"StartFromLast":                   3,
	"StartAtSequence":                 4,
	"StartAtTime":                     5,
	"StartAtTimeDelta":                6,
}

func (x TopicsSubscriptionOffsetType) String() string {
	return proto.EnumName(TopicsSubscriptionOffsetType_name, int32(x))
}

func (TopicsSubscriptionOffsetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{4}
}

type TopicsSubscriptionRequestType int32

const (
	TopicsSubscriptionRequestType_SubscriptionRequestTypeUndefined TopicsSubscriptionRequestType = 0
	TopicsSubscriptionRequestType_SubscriptionRequestTypeJoin      TopicsSubscriptionRequestType = 1
	TopicsSubscriptionRequestType_SubscriptionRequestTypeLeave     TopicsSubscriptionRequestType = 2
)

var TopicsSubscriptionRequestType_name = map[int32]string{
	0: "SubscriptionRequestTypeUndefined",
	1: "SubscriptionRequestTypeJoin",
	2: "SubscriptionRequestTypeLeave",
}

var TopicsSubscriptionRequestType_value = map[string]int32{
	"SubscriptionRequestTypeUndefined": 0,
	"SubscriptionRequestTypeJoin":      1,
	"SubscriptionRequestTypeLeave":     2,
}

func (x TopicsSubscriptionRequestType) String() string {
	return proto.EnumName(TopicsSubscriptionRequestType_name, int32(x))
}

func (TopicsSubscriptionRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{5}
}

type TopicsSubscriptionEventType int32

const (
	TopicsSubscriptionEventType_SubscriptionEventTypeUndefined      TopicsSubscriptionEventType = 0
	TopicsSubscriptionEventType_SubscriptionEventTypeSubscribe      TopicsSubscriptionEventType = 1
	TopicsSubscriptionEventType_SubscriptionEventTypeReSync         TopicsSubscriptionEventType = 2
	TopicsSubscriptionEventType_SubscriptionEventTypeReSyncComplete TopicsSubscriptionEventType = 3
	TopicsSubscriptionEventType_SubscriptionEventTypeHeartbeat      TopicsSubscriptionEventType = 4
	TopicsSubscriptionEventType_SubscriptionEventTypeLeave          TopicsSubscriptionEventType = 5
	TopicsSubscriptionEventType_SubscriptionEventTypeGroupState     TopicsSubscriptionEventType = 6
)

var TopicsSubscriptionEventType_name = map[int32]string{
	0: "SubscriptionEventTypeUndefined",
	1: "SubscriptionEventTypeSubscribe",
	2: "SubscriptionEventTypeReSync",
	3: "SubscriptionEventTypeReSyncComplete",
	4: "SubscriptionEventTypeHeartbeat",
	5: "SubscriptionEventTypeLeave",
	6: "SubscriptionEventTypeGroupState",
}

var TopicsSubscriptionEventType_value = map[string]int32{
	"SubscriptionEventTypeUndefined":      0,
	"SubscriptionEventTypeSubscribe":      1,
	"SubscriptionEventTypeReSync":         2,
	"SubscriptionEventTypeReSyncComplete": 3,
	"SubscriptionEventTypeHeartbeat":      4,
	"SubscriptionEventTypeLeave":          5,
	"SubscriptionEventTypeGroupState":     6,
}

func (x TopicsSubscriptionEventType) String() string {
	return proto.EnumName(TopicsSubscriptionEventType_name, int32(x))
}

func (TopicsSubscriptionEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{6}
}

type TopicsDownstreamRequestType int32

const (
	TopicsDownstreamRequestType_DownstreamRequestTypeUndefined           TopicsDownstreamRequestType = 0
	TopicsDownstreamRequestType_DownstreamRequestTypeSubscriptionRequest TopicsDownstreamRequestType = 1
	TopicsDownstreamRequestType_DownstreamRequestTypeSubscriptionEvent   TopicsDownstreamRequestType = 2
)

var TopicsDownstreamRequestType_name = map[int32]string{
	0: "DownstreamRequestTypeUndefined",
	1: "DownstreamRequestTypeSubscriptionRequest",
	2: "DownstreamRequestTypeSubscriptionEvent",
}

var TopicsDownstreamRequestType_value = map[string]int32{
	"DownstreamRequestTypeUndefined":           0,
	"DownstreamRequestTypeSubscriptionRequest": 1,
	"DownstreamRequestTypeSubscriptionEvent":   2,
}

func (x TopicsDownstreamRequestType) String() string {
	return proto.EnumName(TopicsDownstreamRequestType_name, int32(x))
}

func (TopicsDownstreamRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{7}
}

type Subscribe_SubscribeType int32

const (
	Subscribe_SubscribeTypeUndefined Subscribe_SubscribeType = 0
	Subscribe_Events                 Subscribe_SubscribeType = 1
	Subscribe_EventsStore            Subscribe_SubscribeType = 2
	Subscribe_Commands               Subscribe_SubscribeType = 3
	Subscribe_Queries                Subscribe_SubscribeType = 4
)

var Subscribe_SubscribeType_name = map[int32]string{
	0: "SubscribeTypeUndefined",
	1: "Events",
	2: "EventsStore",
	3: "Commands",
	4: "Queries",
}

var Subscribe_SubscribeType_value = map[string]int32{
	"SubscribeTypeUndefined": 0,
	"Events":                 1,
	"EventsStore":            2,
	"Commands":               3,
	"Queries":                4,
}

func (x Subscribe_SubscribeType) String() string {
	return proto.EnumName(Subscribe_SubscribeType_name, int32(x))
}

func (Subscribe_SubscribeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{5, 0}
}

type Subscribe_EventsStoreType int32

const (
	Subscribe_EventsStoreTypeUndefined Subscribe_EventsStoreType = 0
	Subscribe_StartNewOnly             Subscribe_EventsStoreType = 1
	Subscribe_StartFromFirst           Subscribe_EventsStoreType = 2
	Subscribe_StartFromLast            Subscribe_EventsStoreType = 3
	Subscribe_StartAtSequence          Subscribe_EventsStoreType = 4
	Subscribe_StartAtTime              Subscribe_EventsStoreType = 5
	Subscribe_StartAtTimeDelta         Subscribe_EventsStoreType = 6
)

var Subscribe_EventsStoreType_name = map[int32]string{
	0: "EventsStoreTypeUndefined",
	1: "StartNewOnly",
	2: "StartFromFirst",
	3: "StartFromLast",
	4: "StartAtSequence",
	5: "StartAtTime",
	6: "StartAtTimeDelta",
}

var Subscribe_EventsStoreType_value = map[string]int32{
	"EventsStoreTypeUndefined": 0,
	"StartNewOnly":             1,
	"StartFromFirst":           2,
	"StartFromLast":            3,
	"StartAtSequence":          4,
	"StartAtTime":              5,
	"StartAtTimeDelta":         6,
}

func (x Subscribe_EventsStoreType) String() string {
	return proto.EnumName(Subscribe_EventsStoreType_name, int32(x))
}

func (Subscribe_EventsStoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{5, 1}
}

type Request_RequestType int32

const (
	Request_RequestTypeUnknown Request_RequestType = 0
	Request_Command            Request_RequestType = 1
	Request_Query              Request_RequestType = 2
)

var Request_RequestType_name = map[int32]string{
	0: "RequestTypeUnknown",
	1: "Command",
	2: "Query",
}

var Request_RequestType_value = map[string]int32{
	"RequestTypeUnknown": 0,
	"Command":            1,
	"Query":              2,
}

func (x Request_RequestType) String() string {
	return proto.EnumName(Request_RequestType_name, int32(x))
}

func (Request_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{6, 0}
}

type PingResult struct {
	Host                 string   `protobuf:"bytes,1,opt,name=Host,proto3" json:"Host,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	ServerStartTime      int64    `protobuf:"varint,3,opt,name=ServerStartTime,proto3" json:"ServerStartTime,omitempty"`
	ServerUpTimeSeconds  int64    `protobuf:"varint,4,opt,name=ServerUpTimeSeconds,proto3" json:"ServerUpTimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingResult) Reset()      { *m = PingResult{} }
func (*PingResult) ProtoMessage() {}
func (*PingResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{0}
}
func (m *PingResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingResult.Merge(m, src)
}
func (m *PingResult) XXX_Size() int {
	return m.Size()
}
func (m *PingResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PingResult.DiscardUnknown(m)
}

var xxx_messageInfo_PingResult proto.InternalMessageInfo

func (m *PingResult) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *PingResult) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *PingResult) GetServerStartTime() int64 {
	if m != nil {
		return m.ServerStartTime
	}
	return 0
}

func (m *PingResult) GetServerUpTimeSeconds() int64 {
	if m != nil {
		return m.ServerUpTimeSeconds
	}
	return 0
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{1}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Result struct {
	EventID              string   `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	Sent                 bool     `protobuf:"varint,2,opt,name=Sent,proto3" json:"Sent,omitempty"`
	Error                string   `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()      { *m = Result{} }
func (*Result) ProtoMessage() {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{2}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Result) GetSent() bool {
	if m != nil {
		return m.Sent
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Event struct {
	EventID              string            `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	ClientID             string            `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string            `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string            `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Store                bool              `protobuf:"varint,6,opt,name=Store,proto3" json:"Store,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,7,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{3}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Event) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Event) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Event) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Event) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Event) GetStore() bool {
	if m != nil {
		return m.Store
	}
	return false
}

func (m *Event) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type EventReceive struct {
	EventID              string            `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	Channel              string            `protobuf:"bytes,2,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string            `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	Timestamp            int64             `protobuf:"varint,5,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Sequence             uint64            `protobuf:"varint,6,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,7,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EventReceive) Reset()      { *m = EventReceive{} }
func (*EventReceive) ProtoMessage() {}
func (*EventReceive) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{4}
}
func (m *EventReceive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReceive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReceive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReceive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReceive.Merge(m, src)
}
func (m *EventReceive) XXX_Size() int {
	return m.Size()
}
func (m *EventReceive) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReceive.DiscardUnknown(m)
}

var xxx_messageInfo_EventReceive proto.InternalMessageInfo

func (m *EventReceive) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *EventReceive) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *EventReceive) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *EventReceive) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *EventReceive) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EventReceive) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *EventReceive) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Subscribe struct {
	SubscribeTypeData    Subscribe_SubscribeType   `protobuf:"varint,1,opt,name=SubscribeTypeData,proto3,enum=kubemq.Subscribe_SubscribeType" json:"SubscribeTypeData,omitempty"`
	ClientID             string                    `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string                    `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Group                string                    `protobuf:"bytes,4,opt,name=Group,proto3" json:"Group,omitempty"`
	EventsStoreTypeData  Subscribe_EventsStoreType `protobuf:"varint,5,opt,name=EventsStoreTypeData,proto3,enum=kubemq.Subscribe_EventsStoreType" json:"EventsStoreTypeData,omitempty"`
	EventsStoreTypeValue int64                     `protobuf:"varint,6,opt,name=EventsStoreTypeValue,proto3" json:"EventsStoreTypeValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *Subscribe) Reset()      { *m = Subscribe{} }
func (*Subscribe) ProtoMessage() {}
func (*Subscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{5}
}
func (m *Subscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscribe.Merge(m, src)
}
func (m *Subscribe) XXX_Size() int {
	return m.Size()
}
func (m *Subscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscribe.DiscardUnknown(m)
}

var xxx_messageInfo_Subscribe proto.InternalMessageInfo

func (m *Subscribe) GetSubscribeTypeData() Subscribe_SubscribeType {
	if m != nil {
		return m.SubscribeTypeData
	}
	return Subscribe_SubscribeTypeUndefined
}

func (m *Subscribe) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Subscribe) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Subscribe) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subscribe) GetEventsStoreTypeData() Subscribe_EventsStoreType {
	if m != nil {
		return m.EventsStoreTypeData
	}
	return Subscribe_EventsStoreTypeUndefined
}

func (m *Subscribe) GetEventsStoreTypeValue() int64 {
	if m != nil {
		return m.EventsStoreTypeValue
	}
	return 0
}

type Request struct {
	RequestID            string              `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RequestTypeData      Request_RequestType `protobuf:"varint,2,opt,name=RequestTypeData,proto3,enum=kubemq.Request_RequestType" json:"RequestTypeData,omitempty"`
	ClientID             string              `protobuf:"bytes,3,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string              `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string              `protobuf:"bytes,5,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte              `protobuf:"bytes,6,opt,name=Body,proto3" json:"Body,omitempty"`
	ReplyChannel         string              `protobuf:"bytes,7,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Timeout              int32               `protobuf:"varint,8,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
	CacheKey             string              `protobuf:"bytes,9,opt,name=CacheKey,proto3" json:"CacheKey,omitempty"`
	CacheTTL             int32               `protobuf:"varint,10,opt,name=CacheTTL,proto3" json:"CacheTTL,omitempty"`
	Span                 []byte              `protobuf:"bytes,11,opt,name=Span,proto3" json:"Span,omitempty"`
	Tags                 map[string]string   `protobuf:"bytes,12,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Request) Reset()      { *m = Request{} }
func (*Request) ProtoMessage() {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{6}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Request) GetRequestTypeData() Request_RequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return Request_RequestTypeUnknown
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Request) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Request) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Request) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Request) GetCacheKey() string {
	if m != nil {
		return m.CacheKey
	}
	return ""
}

func (m *Request) GetCacheTTL() int32 {
	if m != nil {
		return m.CacheTTL
	}
	return 0
}

func (m *Request) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *Request) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Response struct {
	ClientID             string            `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	RequestID            string            `protobuf:"bytes,2,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ReplyChannel         string            `protobuf:"bytes,3,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Metadata             string            `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	CacheHit             bool              `protobuf:"varint,6,opt,name=CacheHit,proto3" json:"CacheHit,omitempty"`
	Timestamp            int64             `protobuf:"varint,7,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Executed             bool              `protobuf:"varint,8,opt,name=Executed,proto3" json:"Executed,omitempty"`
	Error                string            `protobuf:"bytes,9,opt,name=Error,proto3" json:"Error,omitempty"`
	Span                 []byte            `protobuf:"bytes,10,opt,name=Span,proto3" json:"Span,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,11,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Response) Reset()      { *m = Response{} }
func (*Response) ProtoMessage() {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{7}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Response) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Response) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Response) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Response) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Response) GetCacheHit() bool {
	if m != nil {
		return m.CacheHit
	}
	return false
}

func (m *Response) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Response) GetExecuted() bool {
	if m != nil {
		return m.Executed
	}
	return false
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *Response) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type QueueMessage struct {
	MessageID            string                  `protobuf:"bytes,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	ClientID             string                  `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string                  `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string                  `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte                  `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Tags                 map[string]string       `protobuf:"bytes,6,rep,name=Tags,proto3" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Attributes           *QueueMessageAttributes `protobuf:"bytes,7,opt,name=Attributes,proto3" json:"Attributes,omitempty"`
	Policy               *QueueMessagePolicy     `protobuf:"bytes,8,opt,name=Policy,proto3" json:"Policy,omitempty"`
	Topic                string                  `protobuf:"bytes,9,opt,name=Topic,proto3" json:"Topic,omitempty"`
	Partition            int32                   `protobuf:"varint,10,opt,name=Partition,proto3" json:"Partition,omitempty"`
	PartitionKey         string                  `protobuf:"bytes,11,opt,name=PartitionKey,proto3" json:"PartitionKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *QueueMessage) Reset()      { *m = QueueMessage{} }
func (*QueueMessage) ProtoMessage() {}
func (*QueueMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{8}
}
func (m *QueueMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessage.Merge(m, src)
}
func (m *QueueMessage) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessage.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessage proto.InternalMessageInfo

func (m *QueueMessage) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *QueueMessage) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *QueueMessage) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *QueueMessage) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *QueueMessage) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *QueueMessage) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *QueueMessage) GetAttributes() *QueueMessageAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *QueueMessage) GetPolicy() *QueueMessagePolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *QueueMessage) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *QueueMessage) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *QueueMessage) GetPartitionKey() string {
	if m != nil {
		return m.PartitionKey
	}
	return ""
}

type QueueMessagesBatchRequest struct {
	BatchID              string          `protobuf:"bytes,1,opt,name=BatchID,proto3" json:"BatchID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages,proto3" json:"Messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueueMessagesBatchRequest) Reset()      { *m = QueueMessagesBatchRequest{} }
func (*QueueMessagesBatchRequest) ProtoMessage() {}
func (*QueueMessagesBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{9}
}
func (m *QueueMessagesBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagesBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagesBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessagesBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagesBatchRequest.Merge(m, src)
}
func (m *QueueMessagesBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagesBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagesBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagesBatchRequest proto.InternalMessageInfo

func (m *QueueMessagesBatchRequest) GetBatchID() string {
	if m != nil {
		return m.BatchID
	}
	return ""
}

func (m *QueueMessagesBatchRequest) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type QueueMessagesBatchResponse struct {
	BatchID              string                    `protobuf:"bytes,1,opt,name=BatchID,proto3" json:"BatchID,omitempty"`
	Results              []*SendQueueMessageResult `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
	HaveErrors           bool                      `protobuf:"varint,3,opt,name=HaveErrors,proto3" json:"HaveErrors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *QueueMessagesBatchResponse) Reset()      { *m = QueueMessagesBatchResponse{} }
func (*QueueMessagesBatchResponse) ProtoMessage() {}
func (*QueueMessagesBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{10}
}
func (m *QueueMessagesBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagesBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagesBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessagesBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagesBatchResponse.Merge(m, src)
}
func (m *QueueMessagesBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagesBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagesBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagesBatchResponse proto.InternalMessageInfo

func (m *QueueMessagesBatchResponse) GetBatchID() string {
	if m != nil {
		return m.BatchID
	}
	return ""
}

func (m *QueueMessagesBatchResponse) GetResults() []*SendQueueMessageResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *QueueMessagesBatchResponse) GetHaveErrors() bool {
	if m != nil {
		return m.HaveErrors
	}
	return false
}

type QueueMessageAttributes struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Sequence             uint64   `protobuf:"varint,2,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	MD5OfBody            string   `protobuf:"bytes,3,opt,name=MD5OfBody,proto3" json:"MD5OfBody,omitempty"`
	ReceiveCount         int32    `protobuf:"varint,4,opt,name=ReceiveCount,proto3" json:"ReceiveCount,omitempty"`
	ReRouted             bool     `protobuf:"varint,5,opt,name=ReRouted,proto3" json:"ReRouted,omitempty"`
	ReRoutedFromQueue    string   `protobuf:"bytes,6,opt,name=ReRoutedFromQueue,proto3" json:"ReRoutedFromQueue,omitempty"`
	ExpirationAt         int64    `protobuf:"varint,7,opt,name=ExpirationAt,proto3" json:"ExpirationAt,omitempty"`
	DelayedTo            int64    `protobuf:"varint,8,opt,name=DelayedTo,proto3" json:"DelayedTo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueMessageAttributes) Reset()      { *m = QueueMessageAttributes{} }
func (*QueueMessageAttributes) ProtoMessage() {}
func (*QueueMessageAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{11}
}
func (m *QueueMessageAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessageAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessageAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessageAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessageAttributes.Merge(m, src)
}
func (m *QueueMessageAttributes) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessageAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessageAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessageAttributes proto.InternalMessageInfo

func (m *QueueMessageAttributes) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *QueueMessageAttributes) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *QueueMessageAttributes) GetMD5OfBody() string {
	if m != nil {
		return m.MD5OfBody
	}
	return ""
}

func (m *QueueMessageAttributes) GetReceiveCount() int32 {
	if m != nil {
		return m.ReceiveCount
	}
	return 0
}

func (m *QueueMessageAttributes) GetReRouted() bool {
	if m != nil {
		return m.ReRouted
	}
	return false
}

func (m *QueueMessageAttributes) GetReRoutedFromQueue() string {
	if m != nil {
		return m.ReRoutedFromQueue
	}
	return ""
}

func (m *QueueMessageAttributes) GetExpirationAt() int64 {
	if m != nil {
		return m.ExpirationAt
	}
	return 0
}

func (m *QueueMessageAttributes) GetDelayedTo() int64 {
	if m != nil {
		return m.DelayedTo
	}
	return 0
}

type QueueMessagePolicy struct {
	ExpirationSeconds    int32    `protobuf:"varint,1,opt,name=ExpirationSeconds,proto3" json:"ExpirationSeconds,omitempty"`
	DelaySeconds         int32    `protobuf:"varint,2,opt,name=DelaySeconds,proto3" json:"DelaySeconds,omitempty"`
	MaxReceiveCount      int32    `protobuf:"varint,3,opt,name=MaxReceiveCount,proto3" json:"MaxReceiveCount,omitempty"`
	MaxReceiveQueue      string   `protobuf:"bytes,4,opt,name=MaxReceiveQueue,proto3" json:"MaxReceiveQueue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueMessagePolicy) Reset()      { *m = QueueMessagePolicy{} }
func (*QueueMessagePolicy) ProtoMessage() {}
func (*QueueMessagePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{12}
}
func (m *QueueMessagePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessagePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagePolicy.Merge(m, src)
}
func (m *QueueMessagePolicy) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagePolicy proto.InternalMessageInfo

func (m *QueueMessagePolicy) GetExpirationSeconds() int32 {
	if m != nil {
		return m.ExpirationSeconds
	}
	return 0
}

func (m *QueueMessagePolicy) GetDelaySeconds() int32 {
	if m != nil {
		return m.DelaySeconds
	}
	return 0
}

func (m *QueueMessagePolicy) GetMaxReceiveCount() int32 {
	if m != nil {
		return m.MaxReceiveCount
	}
	return 0
}

func (m *QueueMessagePolicy) GetMaxReceiveQueue() string {
	if m != nil {
		return m.MaxReceiveQueue
	}
	return ""
}

type SendQueueMessageResult struct {
	MessageID            string   `protobuf:"bytes,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	SentAt               int64    `protobuf:"varint,2,opt,name=SentAt,proto3" json:"SentAt,omitempty"`
	ExpirationAt         int64    `protobuf:"varint,3,opt,name=ExpirationAt,proto3" json:"ExpirationAt,omitempty"`
	DelayedTo            int64    `protobuf:"varint,4,opt,name=DelayedTo,proto3" json:"DelayedTo,omitempty"`
	IsError              bool     `protobuf:"varint,5,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string   `protobuf:"bytes,6,opt,name=Error,proto3" json:"Error,omitempty"`
	RefChannel           string   `protobuf:"bytes,7,opt,name=RefChannel,proto3" json:"RefChannel,omitempty"`
	RefTopic             string   `protobuf:"bytes,8,opt,name=RefTopic,proto3" json:"RefTopic,omitempty"`
	RefPartition         int32    `protobuf:"varint,9,opt,name=RefPartition,proto3" json:"RefPartition,omitempty"`
	RefHash              string   `protobuf:"bytes,10,opt,name=RefHash,proto3" json:"RefHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendQueueMessageResult) Reset()      { *m = SendQueueMessageResult{} }
func (*SendQueueMessageResult) ProtoMessage() {}
func (*SendQueueMessageResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{13}
}
func (m *SendQueueMessageResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendQueueMessageResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendQueueMessageResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendQueueMessageResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendQueueMessageResult.Merge(m, src)
}
func (m *SendQueueMessageResult) XXX_Size() int {
	return m.Size()
}
func (m *SendQueueMessageResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SendQueueMessageResult.DiscardUnknown(m)
}

var xxx_messageInfo_SendQueueMessageResult proto.InternalMessageInfo

func (m *SendQueueMessageResult) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *SendQueueMessageResult) GetSentAt() int64 {
	if m != nil {
		return m.SentAt
	}
	return 0
}

func (m *SendQueueMessageResult) GetExpirationAt() int64 {
	if m != nil {
		return m.ExpirationAt
	}
	return 0
}

func (m *SendQueueMessageResult) GetDelayedTo() int64 {
	if m != nil {
		return m.DelayedTo
	}
	return 0
}

func (m *SendQueueMessageResult) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *SendQueueMessageResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *SendQueueMessageResult) GetRefChannel() string {
	if m != nil {
		return m.RefChannel
	}
	return ""
}

func (m *SendQueueMessageResult) GetRefTopic() string {
	if m != nil {
		return m.RefTopic
	}
	return ""
}

func (m *SendQueueMessageResult) GetRefPartition() int32 {
	if m != nil {
		return m.RefPartition
	}
	return 0
}

func (m *SendQueueMessageResult) GetRefHash() string {
	if m != nil {
		return m.RefHash
	}
	return ""
}

type ReceiveQueueMessagesRequest struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string   `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	MaxNumberOfMessages  int32    `protobuf:"varint,4,opt,name=MaxNumberOfMessages,proto3" json:"MaxNumberOfMessages,omitempty"`
	WaitTimeSeconds      int32    `protobuf:"varint,5,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	IsPeak               bool     `protobuf:"varint,6,opt,name=IsPeak,proto3" json:"IsPeak,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiveQueueMessagesRequest) Reset()      { *m = ReceiveQueueMessagesRequest{} }
func (*ReceiveQueueMessagesRequest) ProtoMessage() {}
func (*ReceiveQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{14}
}
func (m *ReceiveQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveQueueMessagesRequest.Merge(m, src)
}
func (m *ReceiveQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveQueueMessagesRequest proto.InternalMessageInfo

func (m *ReceiveQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetMaxNumberOfMessages() int32 {
	if m != nil {
		return m.MaxNumberOfMessages
	}
	return 0
}

func (m *ReceiveQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

func (m *ReceiveQueueMessagesRequest) GetIsPeak() bool {
	if m != nil {
		return m.IsPeak
	}
	return false
}

type ReceiveQueueMessagesResponse struct {
	RequestID            string          `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages,proto3" json:"Messages,omitempty"`
	MessagesReceived     int32           `protobuf:"varint,3,opt,name=MessagesReceived,proto3" json:"MessagesReceived,omitempty"`
	MessagesExpired      int32           `protobuf:"varint,4,opt,name=MessagesExpired,proto3" json:"MessagesExpired,omitempty"`
	IsPeak               bool            `protobuf:"varint,5,opt,name=IsPeak,proto3" json:"IsPeak,omitempty"`
	IsError              bool            `protobuf:"varint,6,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string          `protobuf:"bytes,7,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReceiveQueueMessagesResponse) Reset()      { *m = ReceiveQueueMessagesResponse{} }
func (*ReceiveQueueMessagesResponse) ProtoMessage() {}
func (*ReceiveQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{15}
}
func (m *ReceiveQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveQueueMessagesResponse.Merge(m, src)
}
func (m *ReceiveQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveQueueMessagesResponse proto.InternalMessageInfo

func (m *ReceiveQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ReceiveQueueMessagesResponse) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *ReceiveQueueMessagesResponse) GetMessagesReceived() int32 {
	if m != nil {
		return m.MessagesReceived
	}
	return 0
}

func (m *ReceiveQueueMessagesResponse) GetMessagesExpired() int32 {
	if m != nil {
		return m.MessagesExpired
	}
	return 0
}

func (m *ReceiveQueueMessagesResponse) GetIsPeak() bool {
	if m != nil {
		return m.IsPeak
	}
	return false
}

func (m *ReceiveQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *ReceiveQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type AckAllQueueMessagesRequest struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string   `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	WaitTimeSeconds      int32    `protobuf:"varint,4,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckAllQueueMessagesRequest) Reset()      { *m = AckAllQueueMessagesRequest{} }
func (*AckAllQueueMessagesRequest) ProtoMessage() {}
func (*AckAllQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{16}
}
func (m *AckAllQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckAllQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckAllQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AckAllQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckAllQueueMessagesRequest.Merge(m, src)
}
func (m *AckAllQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *AckAllQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AckAllQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AckAllQueueMessagesRequest proto.InternalMessageInfo

func (m *AckAllQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

type AckAllQueueMessagesResponse struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	AffectedMessages     uint64   `protobuf:"varint,2,opt,name=AffectedMessages,proto3" json:"AffectedMessages,omitempty"`
	IsError              bool     `protobuf:"varint,3,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string   `protobuf:"bytes,4,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckAllQueueMessagesResponse) Reset()      { *m = AckAllQueueMessagesResponse{} }
func (*AckAllQueueMessagesResponse) ProtoMessage() {}
func (*AckAllQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{17}
}
func (m *AckAllQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckAllQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckAllQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AckAllQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckAllQueueMessagesResponse.Merge(m, src)
}
func (m *AckAllQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *AckAllQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AckAllQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AckAllQueueMessagesResponse proto.InternalMessageInfo

func (m *AckAllQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *AckAllQueueMessagesResponse) GetAffectedMessages() uint64 {
	if m != nil {
		return m.AffectedMessages
	}
	return 0
}

func (m *AckAllQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *AckAllQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type StreamQueueMessagesRequest struct {
	RequestID             string            `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID              string            `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	StreamRequestTypeData StreamRequestType `protobuf:"varint,3,opt,name=StreamRequestTypeData,proto3,enum=kubemq.StreamRequestType" json:"StreamRequestTypeData,omitempty"`
	Channel               string            `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	VisibilitySeconds     int32             `protobuf:"varint,5,opt,name=VisibilitySeconds,proto3" json:"VisibilitySeconds,omitempty"`
	WaitTimeSeconds       int32             `protobuf:"varint,6,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	RefSequence           uint64            `protobuf:"varint,7,opt,name=RefSequence,proto3" json:"RefSequence,omitempty"`
	ModifiedMessage       *QueueMessage     `protobuf:"bytes,8,opt,name=ModifiedMessage,proto3" json:"ModifiedMessage,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_unrecognized      []byte            `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *StreamQueueMessagesRequest) Reset()      { *m = StreamQueueMessagesRequest{} }
func (*StreamQueueMessagesRequest) ProtoMessage() {}
func (*StreamQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{18}
}
func (m *StreamQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamQueueMessagesRequest.Merge(m, src)
}
func (m *StreamQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamQueueMessagesRequest proto.InternalMessageInfo

func (m *StreamQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetStreamRequestTypeData() StreamRequestType {
	if m != nil {
		return m.StreamRequestTypeData
	}
	return StreamRequestType_StreamRequestTypeUnknown
}

func (m *StreamQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetVisibilitySeconds() int32 {
	if m != nil {
		return m.VisibilitySeconds
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetRefSequence() uint64 {
	if m != nil {
		return m.RefSequence
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetModifiedMessage() *QueueMessage {
	if m != nil {
		return m.ModifiedMessage
	}
	return nil
}

type StreamQueueMessagesResponse struct {
	RequestID             string            `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	StreamRequestTypeData StreamRequestType `protobuf:"varint,2,opt,name=StreamRequestTypeData,proto3,enum=kubemq.StreamRequestType" json:"StreamRequestTypeData,omitempty"`
	Message               *QueueMessage     `protobuf:"bytes,3,opt,name=Message,proto3" json:"Message,omitempty"`
	IsError               bool              `protobuf:"varint,4,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                 string            `protobuf:"bytes,5,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_unrecognized      []byte            `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *StreamQueueMessagesResponse) Reset()      { *m = StreamQueueMessagesResponse{} }
func (*StreamQueueMessagesResponse) ProtoMessage() {}
func (*StreamQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{19}
}
func (m *StreamQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamQueueMessagesResponse.Merge(m, src)
}
func (m *StreamQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamQueueMessagesResponse proto.InternalMessageInfo

func (m *StreamQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *StreamQueueMessagesResponse) GetStreamRequestTypeData() StreamRequestType {
	if m != nil {
		return m.StreamRequestTypeData
	}
	return StreamRequestType_StreamRequestTypeUnknown
}

func (m *StreamQueueMessagesResponse) GetMessage() *QueueMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *StreamQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *StreamQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type QueuesUpstreamRequest struct {
	RequestID            string          `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages,proto3" json:"Messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueuesUpstreamRequest) Reset()      { *m = QueuesUpstreamRequest{} }
func (*QueuesUpstreamRequest) ProtoMessage() {}
func (*QueuesUpstreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{20}
}
func (m *QueuesUpstreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesUpstreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesUpstreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesUpstreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesUpstreamRequest.Merge(m, src)
}
func (m *QueuesUpstreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueuesUpstreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesUpstreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesUpstreamRequest proto.InternalMessageInfo

func (m *QueuesUpstreamRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *QueuesUpstreamRequest) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type QueuesUpstreamResponse struct {
	RefRequestID         string                    `protobuf:"bytes,1,opt,name=RefRequestID,proto3" json:"RefRequestID,omitempty"`
	Results              []*SendQueueMessageResult `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
	IsError              bool                      `protobuf:"varint,3,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string                    `protobuf:"bytes,4,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *QueuesUpstreamResponse) Reset()      { *m = QueuesUpstreamResponse{} }
func (*QueuesUpstreamResponse) ProtoMessage() {}
func (*QueuesUpstreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{21}
}
func (m *QueuesUpstreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesUpstreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesUpstreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesUpstreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesUpstreamResponse.Merge(m, src)
}
func (m *QueuesUpstreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueuesUpstreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesUpstreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesUpstreamResponse proto.InternalMessageInfo

func (m *QueuesUpstreamResponse) GetRefRequestID() string {
	if m != nil {
		return m.RefRequestID
	}
	return ""
}

func (m *QueuesUpstreamResponse) GetResults() []*SendQueueMessageResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *QueuesUpstreamResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *QueuesUpstreamResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type QueuesDownstreamRequest struct {
	RequestID            string                      `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string                      `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	RequestTypeData      QueuesDownstreamRequestType `protobuf:"varint,3,opt,name=RequestTypeData,proto3,enum=kubemq.QueuesDownstreamRequestType" json:"RequestTypeData,omitempty"`
	Channel              string                      `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	MaxItems             int32                       `protobuf:"varint,5,opt,name=MaxItems,proto3" json:"MaxItems,omitempty"`
	WaitTimeout          int32                       `protobuf:"varint,6,opt,name=WaitTimeout,proto3" json:"WaitTimeout,omitempty"`
	AutoAck              bool                        `protobuf:"varint,7,opt,name=AutoAck,proto3" json:"AutoAck,omitempty"`
	ReQueueChannel       string                      `protobuf:"bytes,8,opt,name=ReQueueChannel,proto3" json:"ReQueueChannel,omitempty"`
	SequenceRange        []int64                     `protobuf:"varint,9,rep,packed,name=SequenceRange,proto3" json:"SequenceRange,omitempty"`
	RefTransactionId     string                      `protobuf:"bytes,10,opt,name=RefTransactionId,proto3" json:"RefTransactionId,omitempty"`
	Metadata             map[string]string           `protobuf:"bytes,12,rep,name=Metadata,proto3" json:"Metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *QueuesDownstreamRequest) Reset()      { *m = QueuesDownstreamRequest{} }
func (*QueuesDownstreamRequest) ProtoMessage() {}
func (*QueuesDownstreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{22}
}
func (m *QueuesDownstreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesDownstreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesDownstreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesDownstreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesDownstreamRequest.Merge(m, src)
}
func (m *QueuesDownstreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueuesDownstreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesDownstreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesDownstreamRequest proto.InternalMessageInfo

func (m *QueuesDownstreamRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetRequestTypeData() QueuesDownstreamRequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return QueuesDownstreamRequestType_PollRequestTypeUnknown
}

func (m *QueuesDownstreamRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetMaxItems() int32 {
	if m != nil {
		return m.MaxItems
	}
	return 0
}

func (m *QueuesDownstreamRequest) GetWaitTimeout() int32 {
	if m != nil {
		return m.WaitTimeout
	}
	return 0
}

func (m *QueuesDownstreamRequest) GetAutoAck() bool {
	if m != nil {
		return m.AutoAck
	}
	return false
}

func (m *QueuesDownstreamRequest) GetReQueueChannel() string {
	if m != nil {
		return m.ReQueueChannel
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetSequenceRange() []int64 {
	if m != nil {
		return m.SequenceRange
	}
	return nil
}

func (m *QueuesDownstreamRequest) GetRefTransactionId() string {
	if m != nil {
		return m.RefTransactionId
	}
	return ""
}

func (m *QueuesDownstreamRequest) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type QueuesDownstreamResponse struct {
	TransactionId        string                      `protobuf:"bytes,1,opt,name=TransactionId,proto3" json:"TransactionId,omitempty"`
	RefRequestId         string                      `protobuf:"bytes,2,opt,name=RefRequestId,proto3" json:"RefRequestId,omitempty"`
	RequestTypeData      QueuesDownstreamRequestType `protobuf:"varint,3,opt,name=RequestTypeData,proto3,enum=kubemq.QueuesDownstreamRequestType" json:"RequestTypeData,omitempty"`
	Messages             []*QueueMessage             `protobuf:"bytes,4,rep,name=Messages,proto3" json:"Messages,omitempty"`
	ActiveOffsets        []int64                     `protobuf:"varint,5,rep,packed,name=ActiveOffsets,proto3" json:"ActiveOffsets,omitempty"`
	IsError              bool                        `protobuf:"varint,6,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string                      `protobuf:"bytes,7,opt,name=Error,proto3" json:"Error,omitempty"`
	TransactionComplete  bool                        `protobuf:"varint,8,opt,name=TransactionComplete,proto3" json:"TransactionComplete,omitempty"`
	Metadata             map[string]string           `protobuf:"bytes,9,rep,name=Metadata,proto3" json:"Metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *QueuesDownstreamResponse) Reset()      { *m = QueuesDownstreamResponse{} }
func (*QueuesDownstreamResponse) ProtoMessage() {}
func (*QueuesDownstreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{23}
}
func (m *QueuesDownstreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesDownstreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesDownstreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesDownstreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesDownstreamResponse.Merge(m, src)
}
func (m *QueuesDownstreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueuesDownstreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesDownstreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesDownstreamResponse proto.InternalMessageInfo

func (m *QueuesDownstreamResponse) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *QueuesDownstreamResponse) GetRefRequestId() string {
	if m != nil {
		return m.RefRequestId
	}
	return ""
}

func (m *QueuesDownstreamResponse) GetRequestTypeData() QueuesDownstreamRequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return QueuesDownstreamRequestType_PollRequestTypeUnknown
}

func (m *QueuesDownstreamResponse) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *QueuesDownstreamResponse) GetActiveOffsets() []int64 {
	if m != nil {
		return m.ActiveOffsets
	}
	return nil
}

func (m *QueuesDownstreamResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *QueuesDownstreamResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *QueuesDownstreamResponse) GetTransactionComplete() bool {
	if m != nil {
		return m.TransactionComplete
	}
	return false
}

func (m *QueuesDownstreamResponse) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type QueueInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Messages             int64    `protobuf:"varint,2,opt,name=Messages,proto3" json:"Messages,omitempty"`
	Bytes                int64    `protobuf:"varint,3,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
	FirstSequence        int64    `protobuf:"varint,4,opt,name=FirstSequence,proto3" json:"FirstSequence,omitempty"`
	LastSequence         int64    `protobuf:"varint,5,opt,name=LastSequence,proto3" json:"LastSequence,omitempty"`
	Sent                 int64    `protobuf:"varint,6,opt,name=Sent,proto3" json:"Sent,omitempty"`
	Delivered            int64    `protobuf:"varint,7,opt,name=Delivered,proto3" json:"Delivered,omitempty"`
	Waiting              int64    `protobuf:"varint,8,opt,name=Waiting,proto3" json:"Waiting,omitempty"`
	Subscribers          int64    `protobuf:"varint,9,opt,name=Subscribers,proto3" json:"Subscribers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueInfo) Reset()      { *m = QueueInfo{} }
func (*QueueInfo) ProtoMessage() {}
func (*QueueInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{24}
}
func (m *QueueInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueInfo.Merge(m, src)
}
func (m *QueueInfo) XXX_Size() int {
	return m.Size()
}
func (m *QueueInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueInfo.DiscardUnknown(m)
}

var xxx_messageInfo_QueueInfo proto.InternalMessageInfo

func (m *QueueInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueueInfo) GetMessages() int64 {
	if m != nil {
		return m.Messages
	}
	return 0
}

func (m *QueueInfo) GetBytes() int64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *QueueInfo) GetFirstSequence() int64 {
	if m != nil {
		return m.FirstSequence
	}
	return 0
}

func (m *QueueInfo) GetLastSequence() int64 {
	if m != nil {
		return m.LastSequence
	}
	return 0
}

func (m *QueueInfo) GetSent() int64 {
	if m != nil {
		return m.Sent
	}
	return 0
}

func (m *QueueInfo) GetDelivered() int64 {
	if m != nil {
		return m.Delivered
	}
	return 0
}

func (m *QueueInfo) GetWaiting() int64 {
	if m != nil {
		return m.Waiting
	}
	return 0
}

func (m *QueueInfo) GetSubscribers() int64 {
	if m != nil {
		return m.Subscribers
	}
	return 0
}

type QueuesInfo struct {
	TotalQueue           int32        `protobuf:"varint,1,opt,name=TotalQueue,proto3" json:"TotalQueue,omitempty"`
	Sent                 int64        `protobuf:"varint,2,opt,name=Sent,proto3" json:"Sent,omitempty"`
	Delivered            int64        `protobuf:"varint,3,opt,name=Delivered,proto3" json:"Delivered,omitempty"`
	Waiting              int64        `protobuf:"varint,4,opt,name=Waiting,proto3" json:"Waiting,omitempty"`
	Queues               []*QueueInfo `protobuf:"bytes,5,rep,name=Queues,proto3" json:"Queues,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *QueuesInfo) Reset()      { *m = QueuesInfo{} }
func (*QueuesInfo) ProtoMessage() {}
func (*QueuesInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{25}
}
func (m *QueuesInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesInfo.Merge(m, src)
}
func (m *QueuesInfo) XXX_Size() int {
	return m.Size()
}
func (m *QueuesInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesInfo.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesInfo proto.InternalMessageInfo

func (m *QueuesInfo) GetTotalQueue() int32 {
	if m != nil {
		return m.TotalQueue
	}
	return 0
}

func (m *QueuesInfo) GetSent() int64 {
	if m != nil {
		return m.Sent
	}
	return 0
}

func (m *QueuesInfo) GetDelivered() int64 {
	if m != nil {
		return m.Delivered
	}
	return 0
}

func (m *QueuesInfo) GetWaiting() int64 {
	if m != nil {
		return m.Waiting
	}
	return 0
}

func (m *QueuesInfo) GetQueues() []*QueueInfo {
	if m != nil {
		return m.Queues
	}
	return nil
}

type QueuesInfoRequest struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	QueueName            string   `protobuf:"bytes,2,opt,name=QueueName,proto3" json:"QueueName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueuesInfoRequest) Reset()      { *m = QueuesInfoRequest{} }
func (*QueuesInfoRequest) ProtoMessage() {}
func (*QueuesInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{26}
}
func (m *QueuesInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesInfoRequest.Merge(m, src)
}
func (m *QueuesInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueuesInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesInfoRequest proto.InternalMessageInfo

func (m *QueuesInfoRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *QueuesInfoRequest) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

type QueuesInfoResponse struct {
	RefRequestID         string      `protobuf:"bytes,1,opt,name=RefRequestID,proto3" json:"RefRequestID,omitempty"`
	Info                 *QueuesInfo `protobuf:"bytes,2,opt,name=Info,proto3" json:"Info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *QueuesInfoResponse) Reset()      { *m = QueuesInfoResponse{} }
func (*QueuesInfoResponse) ProtoMessage() {}
func (*QueuesInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{27}
}
func (m *QueuesInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuesInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuesInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuesInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuesInfoResponse.Merge(m, src)
}
func (m *QueuesInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueuesInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuesInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueuesInfoResponse proto.InternalMessageInfo

func (m *QueuesInfoResponse) GetRefRequestID() string {
	if m != nil {
		return m.RefRequestID
	}
	return ""
}

func (m *QueuesInfoResponse) GetInfo() *QueuesInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type TopicsUpstreamRequest struct {
	RequestID            string                    `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RequestTypeData      TopicsUpstreamRequestType `protobuf:"varint,2,opt,name=RequestTypeData,proto3,enum=kubemq.TopicsUpstreamRequestType" json:"RequestTypeData,omitempty"`
	ClientID             string                    `protobuf:"bytes,3,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Messages             []*QueueMessage           `protobuf:"bytes,4,rep,name=Messages,proto3" json:"Messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TopicsUpstreamRequest) Reset()      { *m = TopicsUpstreamRequest{} }
func (*TopicsUpstreamRequest) ProtoMessage() {}
func (*TopicsUpstreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{28}
}
func (m *TopicsUpstreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicsUpstreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicsUpstreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicsUpstreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicsUpstreamRequest.Merge(m, src)
}
func (m *TopicsUpstreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *TopicsUpstreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicsUpstreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TopicsUpstreamRequest proto.InternalMessageInfo

func (m *TopicsUpstreamRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *TopicsUpstreamRequest) GetRequestTypeData() TopicsUpstreamRequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return TopicsUpstreamRequestType_TopicsUpstreamRequestUnknown
}

func (m *TopicsUpstreamRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *TopicsUpstreamRequest) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type TopicsUpstreamResponse struct {
	RefRequestID         string                       `protobuf:"bytes,1,opt,name=RefRequestID,proto3" json:"RefRequestID,omitempty"`
	RequestTypeData      TopicsUpstreamRequestType    `protobuf:"varint,2,opt,name=RequestTypeData,proto3,enum=kubemq.TopicsUpstreamRequestType" json:"RequestTypeData,omitempty"`
	TopicResults         map[string]*SendTopicResults `protobuf:"bytes,3,rep,name=TopicResults,proto3" json:"TopicResults,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IsError              bool                         `protobuf:"varint,4,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string                       `protobuf:"bytes,5,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *TopicsUpstreamResponse) Reset()      { *m = TopicsUpstreamResponse{} }
func (*TopicsUpstreamResponse) ProtoMessage() {}
func (*TopicsUpstreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{29}
}
func (m *TopicsUpstreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicsUpstreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicsUpstreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicsUpstreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicsUpstreamResponse.Merge(m, src)
}
func (m *TopicsUpstreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *TopicsUpstreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicsUpstreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TopicsUpstreamResponse proto.InternalMessageInfo

func (m *TopicsUpstreamResponse) GetRefRequestID() string {
	if m != nil {
		return m.RefRequestID
	}
	return ""
}

func (m *TopicsUpstreamResponse) GetRequestTypeData() TopicsUpstreamRequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return TopicsUpstreamRequestType_TopicsUpstreamRequestUnknown
}

func (m *TopicsUpstreamResponse) GetTopicResults() map[string]*SendTopicResults {
	if m != nil {
		return m.TopicResults
	}
	return nil
}

func (m *TopicsUpstreamResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *TopicsUpstreamResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SendPartitionResults struct {
	PartitionResults     []*SendQueueMessageResult `protobuf:"bytes,1,rep,name=PartitionResults,proto3" json:"PartitionResults,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SendPartitionResults) Reset()      { *m = SendPartitionResults{} }
func (*SendPartitionResults) ProtoMessage() {}
func (*SendPartitionResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{30}
}
func (m *SendPartitionResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPartitionResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPartitionResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPartitionResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPartitionResults.Merge(m, src)
}
func (m *SendPartitionResults) XXX_Size() int {
	return m.Size()
}
func (m *SendPartitionResults) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPartitionResults.DiscardUnknown(m)
}

var xxx_messageInfo_SendPartitionResults proto.InternalMessageInfo

func (m *SendPartitionResults) GetPartitionResults() []*SendQueueMessageResult {
	if m != nil {
		return m.PartitionResults
	}
	return nil
}

type SendTopicResults struct {
	TopicResults         map[int32]*SendPartitionResults `protobuf:"bytes,1,rep,name=TopicResults,proto3" json:"TopicResults,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *SendTopicResults) Reset()      { *m = SendTopicResults{} }
func (*SendTopicResults) ProtoMessage() {}
func (*SendTopicResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{31}
}
func (m *SendTopicResults) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTopicResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTopicResults.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendTopicResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTopicResults.Merge(m, src)
}
func (m *SendTopicResults) XXX_Size() int {
	return m.Size()
}
func (m *SendTopicResults) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTopicResults.DiscardUnknown(m)
}

var xxx_messageInfo_SendTopicResults proto.InternalMessageInfo

func (m *SendTopicResults) GetTopicResults() map[int32]*SendPartitionResults {
	if m != nil {
		return m.TopicResults
	}
	return nil
}

type TopicRecordHeader struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicRecordHeader) Reset()      { *m = TopicRecordHeader{} }
func (*TopicRecordHeader) ProtoMessage() {}
func (*TopicRecordHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{32}
}
func (m *TopicRecordHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicRecordHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicRecordHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicRecordHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicRecordHeader.Merge(m, src)
}
func (m *TopicRecordHeader) XXX_Size() int {
	return m.Size()
}
func (m *TopicRecordHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicRecordHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TopicRecordHeader proto.InternalMessageInfo

func (m *TopicRecordHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *TopicRecordHeader) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type TopicRecord struct {
	Headers              []*TopicRecordHeader `protobuf:"bytes,1,rep,name=Headers,proto3" json:"Headers,omitempty"`
	Topic                string               `protobuf:"bytes,2,opt,name=Topic,proto3" json:"Topic,omitempty"`
	Partition            uint32               `protobuf:"varint,3,opt,name=Partition,proto3" json:"Partition,omitempty"`
	Timestamp            uint64               `protobuf:"varint,4,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Key                  []byte               `protobuf:"bytes,5,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                []byte               `protobuf:"bytes,6,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TopicRecord) Reset()      { *m = TopicRecord{} }
func (*TopicRecord) ProtoMessage() {}
func (*TopicRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{33}
}
func (m *TopicRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicRecord.Merge(m, src)
}
func (m *TopicRecord) XXX_Size() int {
	return m.Size()
}
func (m *TopicRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TopicRecord proto.InternalMessageInfo

func (m *TopicRecord) GetHeaders() []*TopicRecordHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *TopicRecord) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *TopicRecord) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *TopicRecord) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TopicRecord) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TopicRecord) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type TopicPartition struct {
	Topic                string   `protobuf:"bytes,1,opt,name=Topic,proto3" json:"Topic,omitempty"`
	Partition            uint32   `protobuf:"varint,2,opt,name=Partition,proto3" json:"Partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicPartition) Reset()      { *m = TopicPartition{} }
func (*TopicPartition) ProtoMessage() {}
func (*TopicPartition) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{34}
}
func (m *TopicPartition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicPartition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicPartition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicPartition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicPartition.Merge(m, src)
}
func (m *TopicPartition) XXX_Size() int {
	return m.Size()
}
func (m *TopicPartition) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicPartition.DiscardUnknown(m)
}

var xxx_messageInfo_TopicPartition proto.InternalMessageInfo

func (m *TopicPartition) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *TopicPartition) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type TopicsSubscriptionRequest struct {
	SubscriptionRequestType  TopicsSubscriptionRequestType  `protobuf:"varint,1,opt,name=SubscriptionRequestType,proto3,enum=kubemq.TopicsSubscriptionRequestType" json:"SubscriptionRequestType,omitempty"`
	Topics                   []string                       `protobuf:"bytes,2,rep,name=Topics,proto3" json:"Topics,omitempty"`
	TopicPartitions          []*TopicPartition              `protobuf:"bytes,3,rep,name=TopicPartitions,proto3" json:"TopicPartitions,omitempty"`
	GroupID                  string                         `protobuf:"bytes,4,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	MemberID                 string                         `protobuf:"bytes,5,opt,name=MemberID,proto3" json:"MemberID,omitempty"`
	IsStatic                 bool                           `protobuf:"varint,6,opt,name=IsStatic,proto3" json:"IsStatic,omitempty"`
	SubscriptionStrategyType TopicsSubscriptionStrategyType `protobuf:"varint,7,opt,name=SubscriptionStrategyType,proto3,enum=kubemq.TopicsSubscriptionStrategyType" json:"SubscriptionStrategyType,omitempty"`
	SubscriptionOffsetType   TopicsSubscriptionOffsetType   `protobuf:"varint,8,opt,name=SubscriptionOffsetType,proto3,enum=kubemq.TopicsSubscriptionOffsetType" json:"SubscriptionOffsetType,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                       `json:"-"`
	XXX_unrecognized         []byte                         `json:"-"`
	XXX_sizecache            int32                          `json:"-"`
}

func (m *TopicsSubscriptionRequest) Reset()      { *m = TopicsSubscriptionRequest{} }
func (*TopicsSubscriptionRequest) ProtoMessage() {}
func (*TopicsSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{35}
}
func (m *TopicsSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicsSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicsSubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicsSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicsSubscriptionRequest.Merge(m, src)
}
func (m *TopicsSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *TopicsSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicsSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TopicsSubscriptionRequest proto.InternalMessageInfo

func (m *TopicsSubscriptionRequest) GetSubscriptionRequestType() TopicsSubscriptionRequestType {
	if m != nil {
		return m.SubscriptionRequestType
	}
	return TopicsSubscriptionRequestType_SubscriptionRequestTypeUndefined
}

func (m *TopicsSubscriptionRequest) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func (m *TopicsSubscriptionRequest) GetTopicPartitions() []*TopicPartition {
	if m != nil {
		return m.TopicPartitions
	}
	return nil
}

func (m *TopicsSubscriptionRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *TopicsSubscriptionRequest) GetMemberID() string {
	if m != nil {
		return m.MemberID
	}
	return ""
}

func (m *TopicsSubscriptionRequest) GetIsStatic() bool {
	if m != nil {
		return m.IsStatic
	}
	return false
}

func (m *TopicsSubscriptionRequest) GetSubscriptionStrategyType() TopicsSubscriptionStrategyType {
	if m != nil {
		return m.SubscriptionStrategyType
	}
	return TopicsSubscriptionStrategyType_SubscriptionStrategyTypeUndefined
}

func (m *TopicsSubscriptionRequest) GetSubscriptionOffsetType() TopicsSubscriptionOffsetType {
	if m != nil {
		return m.SubscriptionOffsetType
	}
	return TopicsSubscriptionOffsetType_SubscriptionOffsetTypeUndefined
}

type TopicsSubscriptionEvent struct {
	SubscriptionID        string                      `protobuf:"bytes,1,opt,name=SubscriptionID,proto3" json:"SubscriptionID,omitempty"`
	SubscriptionEventType TopicsSubscriptionEventType `protobuf:"varint,2,opt,name=SubscriptionEventType,proto3,enum=kubemq.TopicsSubscriptionEventType" json:"SubscriptionEventType,omitempty"`
	GroupID               string                      `protobuf:"bytes,3,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	MemberID              string                      `protobuf:"bytes,4,opt,name=MemberID,proto3" json:"MemberID,omitempty"`
	Assigned              []*TopicPartition           `protobuf:"bytes,5,rep,name=Assigned,proto3" json:"Assigned,omitempty"`
	ReSyncAt              int64                       `protobuf:"varint,6,opt,name=ReSyncAt,proto3" json:"ReSyncAt,omitempty"`
	IsError               bool                        `protobuf:"varint,15,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                 string                      `protobuf:"bytes,16,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                    `json:"-"`
	XXX_unrecognized      []byte                      `json:"-"`
	XXX_sizecache         int32                       `json:"-"`
}

func (m *TopicsSubscriptionEvent) Reset()      { *m = TopicsSubscriptionEvent{} }
func (*TopicsSubscriptionEvent) ProtoMessage() {}
func (*TopicsSubscriptionEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{36}
}
func (m *TopicsSubscriptionEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicsSubscriptionEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicsSubscriptionEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicsSubscriptionEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicsSubscriptionEvent.Merge(m, src)
}
func (m *TopicsSubscriptionEvent) XXX_Size() int {
	return m.Size()
}
func (m *TopicsSubscriptionEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicsSubscriptionEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TopicsSubscriptionEvent proto.InternalMessageInfo

func (m *TopicsSubscriptionEvent) GetSubscriptionID() string {
	if m != nil {
		return m.SubscriptionID
	}
	return ""
}

func (m *TopicsSubscriptionEvent) GetSubscriptionEventType() TopicsSubscriptionEventType {
	if m != nil {
		return m.SubscriptionEventType
	}
	return TopicsSubscriptionEventType_SubscriptionEventTypeUndefined
}

func (m *TopicsSubscriptionEvent) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *TopicsSubscriptionEvent) GetMemberID() string {
	if m != nil {
		return m.MemberID
	}
	return ""
}

func (m *TopicsSubscriptionEvent) GetAssigned() []*TopicPartition {
	if m != nil {
		return m.Assigned
	}
	return nil
}

func (m *TopicsSubscriptionEvent) GetReSyncAt() int64 {
	if m != nil {
		return m.ReSyncAt
	}
	return 0
}

func (m *TopicsSubscriptionEvent) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *TopicsSubscriptionEvent) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type TopicsDownstreamRequest struct {
	RequestID             string                      `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	DownstreamRequestType TopicsDownstreamRequestType `protobuf:"varint,2,opt,name=DownstreamRequestType,proto3,enum=kubemq.TopicsDownstreamRequestType" json:"DownstreamRequestType,omitempty"`
	Data                  []byte                      `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                    `json:"-"`
	XXX_unrecognized      []byte                      `json:"-"`
	XXX_sizecache         int32                       `json:"-"`
}

func (m *TopicsDownstreamRequest) Reset()      { *m = TopicsDownstreamRequest{} }
func (*TopicsDownstreamRequest) ProtoMessage() {}
func (*TopicsDownstreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{37}
}
func (m *TopicsDownstreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicsDownstreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicsDownstreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicsDownstreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicsDownstreamRequest.Merge(m, src)
}
func (m *TopicsDownstreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *TopicsDownstreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicsDownstreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TopicsDownstreamRequest proto.InternalMessageInfo

func (m *TopicsDownstreamRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *TopicsDownstreamRequest) GetDownstreamRequestType() TopicsDownstreamRequestType {
	if m != nil {
		return m.DownstreamRequestType
	}
	return TopicsDownstreamRequestType_DownstreamRequestTypeUndefined
}

func (m *TopicsDownstreamRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TopicsDownstreamResponse struct {
	TransactionID        string   `protobuf:"bytes,1,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	RefRequestID         string   `protobuf:"bytes,2,opt,name=RefRequestID,proto3" json:"RefRequestID,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	IsError              bool     `protobuf:"varint,15,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string   `protobuf:"bytes,16,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicsDownstreamResponse) Reset()      { *m = TopicsDownstreamResponse{} }
func (*TopicsDownstreamResponse) ProtoMessage() {}
func (*TopicsDownstreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c4052a8d0b3cbdc, []int{38}
}
func (m *TopicsDownstreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicsDownstreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicsDownstreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicsDownstreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicsDownstreamResponse.Merge(m, src)
}
func (m *TopicsDownstreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *TopicsDownstreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicsDownstreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TopicsDownstreamResponse proto.InternalMessageInfo

func (m *TopicsDownstreamResponse) GetTransactionID() string {
	if m != nil {
		return m.TransactionID
	}
	return ""
}

func (m *TopicsDownstreamResponse) GetRefRequestID() string {
	if m != nil {
		return m.RefRequestID
	}
	return ""
}

func (m *TopicsDownstreamResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TopicsDownstreamResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *TopicsDownstreamResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterEnum("kubemq.StreamRequestType", StreamRequestType_name, StreamRequestType_value)
	proto.RegisterEnum("kubemq.QueuesDownstreamRequestType", QueuesDownstreamRequestType_name, QueuesDownstreamRequestType_value)
	proto.RegisterEnum("kubemq.TopicsUpstreamRequestType", TopicsUpstreamRequestType_name, TopicsUpstreamRequestType_value)
	proto.RegisterEnum("kubemq.TopicsSubscriptionStrategyType", TopicsSubscriptionStrategyType_name, TopicsSubscriptionStrategyType_value)
	proto.RegisterEnum("kubemq.TopicsSubscriptionOffsetType", TopicsSubscriptionOffsetType_name, TopicsSubscriptionOffsetType_value)
	proto.RegisterEnum("kubemq.TopicsSubscriptionRequestType", TopicsSubscriptionRequestType_name, TopicsSubscriptionRequestType_value)
	proto.RegisterEnum("kubemq.TopicsSubscriptionEventType", TopicsSubscriptionEventType_name, TopicsSubscriptionEventType_value)
	proto.RegisterEnum("kubemq.TopicsDownstreamRequestType", TopicsDownstreamRequestType_name, TopicsDownstreamRequestType_value)
	proto.RegisterEnum("kubemq.Subscribe_SubscribeType", Subscribe_SubscribeType_name, Subscribe_SubscribeType_value)
	proto.RegisterEnum("kubemq.Subscribe_EventsStoreType", Subscribe_EventsStoreType_name, Subscribe_EventsStoreType_value)
	proto.RegisterEnum("kubemq.Request_RequestType", Request_RequestType_name, Request_RequestType_value)
	proto.RegisterType((*PingResult)(nil), "kubemq.PingResult")
	proto.RegisterType((*Empty)(nil), "kubemq.Empty")
	proto.RegisterType((*Result)(nil), "kubemq.Result")
	proto.RegisterType((*Event)(nil), "kubemq.Event")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Event.TagsEntry")
	proto.RegisterType((*EventReceive)(nil), "kubemq.EventReceive")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.EventReceive.TagsEntry")
	proto.RegisterType((*Subscribe)(nil), "kubemq.Subscribe")
	proto.RegisterType((*Request)(nil), "kubemq.Request")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Request.TagsEntry")
	proto.RegisterType((*Response)(nil), "kubemq.Response")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Response.TagsEntry")
	proto.RegisterType((*QueueMessage)(nil), "kubemq.QueueMessage")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.QueueMessage.TagsEntry")
	proto.RegisterType((*QueueMessagesBatchRequest)(nil), "kubemq.QueueMessagesBatchRequest")
	proto.RegisterType((*QueueMessagesBatchResponse)(nil), "kubemq.QueueMessagesBatchResponse")
	proto.RegisterType((*QueueMessageAttributes)(nil), "kubemq.QueueMessageAttributes")
	proto.RegisterType((*QueueMessagePolicy)(nil), "kubemq.QueueMessagePolicy")
	proto.RegisterType((*SendQueueMessageResult)(nil), "kubemq.SendQueueMessageResult")
	proto.RegisterType((*ReceiveQueueMessagesRequest)(nil), "kubemq.ReceiveQueueMessagesRequest")
	proto.RegisterType((*ReceiveQueueMessagesResponse)(nil), "kubemq.ReceiveQueueMessagesResponse")
	proto.RegisterType((*AckAllQueueMessagesRequest)(nil), "kubemq.AckAllQueueMessagesRequest")
	proto.RegisterType((*AckAllQueueMessagesResponse)(nil), "kubemq.AckAllQueueMessagesResponse")
	proto.RegisterType((*StreamQueueMessagesRequest)(nil), "kubemq.StreamQueueMessagesRequest")
	proto.RegisterType((*StreamQueueMessagesResponse)(nil), "kubemq.StreamQueueMessagesResponse")
	proto.RegisterType((*QueuesUpstreamRequest)(nil), "kubemq.QueuesUpstreamRequest")
	proto.RegisterType((*QueuesUpstreamResponse)(nil), "kubemq.QueuesUpstreamResponse")
	proto.RegisterType((*QueuesDownstreamRequest)(nil), "kubemq.QueuesDownstreamRequest")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.QueuesDownstreamRequest.MetadataEntry")
	proto.RegisterType((*QueuesDownstreamResponse)(nil), "kubemq.QueuesDownstreamResponse")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.QueuesDownstreamResponse.MetadataEntry")
	proto.RegisterType((*QueueInfo)(nil), "kubemq.QueueInfo")
	proto.RegisterType((*QueuesInfo)(nil), "kubemq.QueuesInfo")
	proto.RegisterType((*QueuesInfoRequest)(nil), "kubemq.QueuesInfoRequest")
	proto.RegisterType((*QueuesInfoResponse)(nil), "kubemq.QueuesInfoResponse")
	proto.RegisterType((*TopicsUpstreamRequest)(nil), "kubemq.TopicsUpstreamRequest")
	proto.RegisterType((*TopicsUpstreamResponse)(nil), "kubemq.TopicsUpstreamResponse")
	proto.RegisterMapType((map[string]*SendTopicResults)(nil), "kubemq.TopicsUpstreamResponse.TopicResultsEntry")
	proto.RegisterType((*SendPartitionResults)(nil), "kubemq.SendPartitionResults")
	proto.RegisterType((*SendTopicResults)(nil), "kubemq.SendTopicResults")
	proto.RegisterMapType((map[int32]*SendPartitionResults)(nil), "kubemq.SendTopicResults.TopicResultsEntry")
	proto.RegisterType((*TopicRecordHeader)(nil), "kubemq.TopicRecordHeader")
	proto.RegisterType((*TopicRecord)(nil), "kubemq.TopicRecord")
	proto.RegisterType((*TopicPartition)(nil), "kubemq.TopicPartition")
	proto.RegisterType((*TopicsSubscriptionRequest)(nil), "kubemq.TopicsSubscriptionRequest")
	proto.RegisterType((*TopicsSubscriptionEvent)(nil), "kubemq.TopicsSubscriptionEvent")
	proto.RegisterType((*TopicsDownstreamRequest)(nil), "kubemq.TopicsDownstreamRequest")
	proto.RegisterType((*TopicsDownstreamResponse)(nil), "kubemq.TopicsDownstreamResponse")
}

func init() { proto.RegisterFile("kubemq_go.proto", fileDescriptor_3c4052a8d0b3cbdc) }

var fileDescriptor_3c4052a8d0b3cbdc = []byte{
	// 3265 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x1a, 0x4d, 0x8f, 0x1c, 0x47,
	0x75, 0xbb, 0x7b, 0x3e, 0x76, 0xde, 0x7e, 0xf5, 0x96, 0xd7, 0xeb, 0xf1, 0xec, 0x66, 0xbc, 0x69,
	0x3b, 0x66, 0xd9, 0x38, 0x2b, 0xb3, 0x11, 0x4a, 0x44, 0x94, 0x28, 0x63, 0xef, 0x26, 0xde, 0xd8,
	0x6b, 0x3b, 0x3d, 0x6b, 0xa3, 0x08, 0x50, 0xd2, 0x3b, 0x53, 0xb3, 0x6e, 0x76, 0xa6, 0x7b, 0xd2,
	0xdd, 0xb3, 0xf1, 0xdc, 0x40, 0x08, 0x09, 0x24, 0x0e, 0x9c, 0x42, 0x80, 0x0b, 0x12, 0x28, 0x8a,
	0xf8, 0x05, 0x51, 0xe0, 0xc2, 0x0d, 0x89, 0x4b, 0xc4, 0x09, 0x71, 0x22, 0x46, 0x5c, 0x22, 0x0e,
	0x9c, 0x10, 0x12, 0x17, 0x54, 0x5f, 0xdd, 0xd5, 0x3d, 0xd5, 0xb3, 0x1e, 0xb3, 0x84, 0x5b, 0xbf,
	0x57, 0xaf, 0x5e, 0xbd, 0xaf, 0x7a, 0xf5, 0x5e, 0x75, 0xc1, 0xc2, 0xd1, 0xe0, 0x00, 0xf7, 0xde,
	0x7d, 0xfb, 0xd0, 0xdf, 0xec, 0x07, 0x7e, 0xe4, 0xa3, 0x12, 0x43, 0xd4, 0xe0, 0xd0, 0x17, 0x38,
	0xeb, 0x7d, 0x0d, 0xe0, 0xae, 0xeb, 0x1d, 0xda, 0x38, 0x1c, 0x74, 0x23, 0x84, 0xa0, 0x70, 0xc3,
	0x0f, 0xa3, 0xaa, 0xb6, 0xa6, 0xad, 0x57, 0x6c, 0xfa, 0x8d, 0xaa, 0x50, 0xbe, 0x8f, 0x83, 0xd0,
	0xf5, 0xbd, 0xaa, 0x4e, 0xd1, 0x02, 0x44, 0xeb, 0xb0, 0xd0, 0xc4, 0xc1, 0x31, 0x0e, 0x9a, 0x91,
	0x13, 0x44, 0xfb, 0x6e, 0x0f, 0x57, 0x8d, 0x35, 0x6d, 0xdd, 0xb0, 0xb3, 0x68, 0x74, 0x15, 0xce,
	0x30, 0xd4, 0xbd, 0x3e, 0x81, 0x9b, 0xb8, 0xe5, 0x7b, 0xed, 0xb0, 0x5a, 0xa0, 0xd4, 0xaa, 0x21,
	0xab, 0x0c, 0xc5, 0x9d, 0x5e, 0x3f, 0x1a, 0x5a, 0xb7, 0xa0, 0xc4, 0x85, 0xab, 0x42, 0x79, 0xe7,
	0x18, 0x7b, 0xd1, 0xee, 0x36, 0x97, 0x4f, 0x80, 0x44, 0xec, 0x26, 0xf6, 0x22, 0x2a, 0xdf, 0xb4,
	0x4d, 0xbf, 0xd1, 0x12, 0x14, 0x77, 0x82, 0xc0, 0x0f, 0xa8, 0x48, 0x15, 0x9b, 0x01, 0xd6, 0xf7,
	0x74, 0x28, 0xd2, 0x59, 0x63, 0xb8, 0xd5, 0x60, 0xfa, 0x7a, 0xd7, 0x65, 0x43, 0x4c, 0xe3, 0x18,
	0x26, 0xb3, 0xae, 0x3f, 0x70, 0x3c, 0x0f, 0x77, 0x39, 0x5f, 0x01, 0x92, 0x59, 0x7b, 0x38, 0x72,
	0xda, 0x4e, 0xe4, 0x50, 0xbd, 0x2a, 0x76, 0x0c, 0x13, 0xf9, 0xae, 0xf9, 0xed, 0x61, 0xb5, 0xb8,
	0xa6, 0xad, 0xcf, 0xda, 0xf4, 0x9b, 0xc8, 0xd7, 0x8c, 0xfc, 0x00, 0x57, 0x4b, 0x54, 0x68, 0x06,
	0xa0, 0x67, 0xa1, 0xb0, 0xef, 0x1c, 0x86, 0xd5, 0xf2, 0x9a, 0xb1, 0x3e, 0xb3, 0x75, 0x6e, 0x93,
	0xb9, 0x6c, 0x93, 0x8a, 0xb6, 0x49, 0x46, 0x76, 0xbc, 0x28, 0x18, 0xda, 0x94, 0xa8, 0xf6, 0x02,
	0x54, 0x62, 0x14, 0x32, 0xc1, 0x38, 0xc2, 0x43, 0xae, 0x0b, 0xf9, 0x24, 0x2b, 0x1c, 0x3b, 0xdd,
	0x01, 0xe6, 0x4a, 0x30, 0xe0, 0x6b, 0xfa, 0x8b, 0x9a, 0xf5, 0x53, 0x1d, 0x66, 0x29, 0x4b, 0x1b,
	0xb7, 0xb0, 0x7b, 0x8c, 0xc7, 0x18, 0x43, 0x52, 0x58, 0xcf, 0x57, 0xd8, 0xc8, 0x51, 0xb8, 0x20,
	0x29, 0xbc, 0x0a, 0x15, 0xe2, 0xe0, 0x30, 0x72, 0x7a, 0x7d, 0x6a, 0x09, 0xc3, 0x4e, 0x10, 0x84,
	0x5b, 0x13, 0xbf, 0x3b, 0xc0, 0x5e, 0x8b, 0x59, 0xa4, 0x60, 0xc7, 0x30, 0xda, 0x4a, 0x19, 0xa5,
	0x9e, 0x32, 0x0a, 0xd7, 0xe0, 0xf4, 0x6c, 0xf3, 0x9b, 0x02, 0x54, 0x9a, 0x83, 0x83, 0xb0, 0x15,
	0xb8, 0x07, 0x18, 0xed, 0xc1, 0x62, 0x0c, 0xec, 0x0f, 0xfb, 0x78, 0x9b, 0x68, 0x4b, 0xf8, 0xcc,
	0x6f, 0x5d, 0x10, 0x72, 0xc4, 0x04, 0x9b, 0x29, 0x52, 0x7b, 0x74, 0xe6, 0x13, 0x86, 0xd6, 0x12,
	0x14, 0x5f, 0x0f, 0xfc, 0x41, 0x9f, 0xc7, 0x15, 0x03, 0x50, 0x13, 0xce, 0x50, 0x0b, 0x84, 0x34,
	0x72, 0x62, 0xe1, 0x8a, 0x54, 0xb8, 0xa7, 0x47, 0x85, 0xcb, 0x10, 0xdb, 0xaa, 0xd9, 0x68, 0x0b,
	0x96, 0x32, 0xe8, 0xfb, 0xd4, 0x4c, 0x25, 0xea, 0x2f, 0xe5, 0x98, 0xd5, 0x82, 0xb9, 0x94, 0xa6,
	0xa8, 0x06, 0xcb, 0x29, 0xc4, 0x3d, 0xaf, 0x8d, 0x3b, 0xae, 0x87, 0xdb, 0xe6, 0x14, 0x02, 0x28,
	0x31, 0x26, 0xa6, 0x86, 0x16, 0x60, 0x46, 0x62, 0x68, 0xea, 0x68, 0x16, 0xa6, 0xaf, 0xfb, 0xbd,
	0x9e, 0xe3, 0xb5, 0x43, 0xd3, 0x40, 0x33, 0x50, 0x7e, 0x73, 0x80, 0x03, 0x17, 0x87, 0x66, 0xc1,
	0xfa, 0x95, 0x06, 0x0b, 0x99, 0xd5, 0xd1, 0x2a, 0x54, 0x33, 0x28, 0x79, 0x25, 0x13, 0x66, 0x69,
	0x02, 0xba, 0x8d, 0xdf, 0xbb, 0xe3, 0x75, 0x87, 0xa6, 0x86, 0x10, 0xcc, 0x53, 0xcc, 0x6b, 0x81,
	0xdf, 0x7b, 0xcd, 0x0d, 0xc2, 0xc8, 0xd4, 0xd1, 0x22, 0xcc, 0xc5, 0xb8, 0x5b, 0x4e, 0x18, 0x99,
	0x06, 0x3a, 0x03, 0x0b, 0x14, 0xd5, 0x88, 0x44, 0x04, 0x9a, 0x05, 0x22, 0x2b, 0x47, 0x92, 0x98,
	0x35, 0x8b, 0x68, 0x09, 0x4c, 0x09, 0xb1, 0x8d, 0xbb, 0x91, 0x63, 0x96, 0xac, 0xef, 0x17, 0xa0,
	0x6c, 0x93, 0x59, 0x61, 0x44, 0x02, 0x9e, 0x7f, 0xc6, 0xdb, 0x2a, 0x41, 0xa0, 0x1d, 0x58, 0xe0,
	0x40, 0xec, 0x3a, 0x9d, 0xba, 0x6e, 0x45, 0xb8, 0x8e, 0x0f, 0x6f, 0x4a, 0x64, 0x76, 0x76, 0x4e,
	0x2a, 0xa2, 0x8c, 0xfc, 0x88, 0x2a, 0xe4, 0xef, 0xdd, 0x62, 0xce, 0xde, 0x2d, 0x49, 0x7b, 0xd7,
	0x82, 0x59, 0x1b, 0xf7, 0xbb, 0x43, 0xc1, 0xae, 0x4c, 0xe7, 0xa4, 0x70, 0x64, 0x35, 0x62, 0x09,
	0x7f, 0x10, 0x55, 0xa7, 0xd7, 0xb4, 0xf5, 0xa2, 0x2d, 0x40, 0x2a, 0xa3, 0xd3, 0x7a, 0x80, 0x6f,
	0xe2, 0x61, 0xb5, 0xc2, 0x65, 0xe4, 0x70, 0x3c, 0xb6, 0xbf, 0x7f, 0xab, 0x0a, 0x74, 0x5a, 0x0c,
	0xd3, 0xb4, 0xde, 0x77, 0xbc, 0xea, 0x0c, 0x93, 0x84, 0x7c, 0xa3, 0xe7, 0x78, 0x2e, 0x98, 0xa5,
	0xb9, 0xe0, 0x7c, 0xd6, 0x56, 0xa7, 0x96, 0x06, 0x5e, 0x86, 0x19, 0xc9, 0xd4, 0x68, 0x19, 0x90,
	0x04, 0xde, 0xf3, 0x8e, 0x3c, 0xff, 0x3d, 0xcf, 0x9c, 0x22, 0x31, 0xca, 0x23, 0xd6, 0xd4, 0x50,
	0x05, 0x8a, 0x24, 0x60, 0x87, 0xa6, 0x6e, 0x7d, 0xd7, 0x80, 0x69, 0x1b, 0x87, 0x7d, 0xdf, 0x0b,
	0x71, 0xca, 0x47, 0x5a, 0xc6, 0x47, 0xa9, 0x20, 0xd1, 0xb3, 0x41, 0x92, 0xb5, 0xbb, 0xa1, 0xb0,
	0xfb, 0xa4, 0x07, 0x8f, 0xb0, 0xf8, 0x0d, 0x37, 0xe2, 0x67, 0x4f, 0x0c, 0xa7, 0x73, 0x74, 0x59,
	0x91, 0xa3, 0x77, 0x1e, 0xe2, 0xd6, 0x20, 0xc2, 0x6d, 0xea, 0xe2, 0x69, 0x3b, 0x86, 0x93, 0xe3,
	0xb6, 0x22, 0x1d, 0xb7, 0xb1, 0x07, 0x41, 0xf2, 0xe0, 0x26, 0xf7, 0xe0, 0x0c, 0xf5, 0x60, 0x2d,
	0xf1, 0x20, 0xb3, 0xd6, 0xe9, 0xb9, 0xf0, 0x0f, 0x06, 0xcc, 0xbe, 0x39, 0xc0, 0x03, 0xbc, 0x87,
	0xc3, 0xd0, 0x39, 0x24, 0xf9, 0xa2, 0xc2, 0x3f, 0x93, 0x0d, 0x19, 0x23, 0xbe, 0xa0, 0x63, 0x5f,
	0x9c, 0x65, 0xa5, 0xf4, 0x59, 0x26, 0xcb, 0x99, 0xb5, 0x00, 0x7a, 0x05, 0xa0, 0x11, 0x45, 0x81,
	0x7b, 0x30, 0x88, 0x70, 0x48, 0xdd, 0x92, 0x33, 0x33, 0xa1, 0xb2, 0xa5, 0x19, 0x68, 0x0b, 0x4a,
	0x77, 0xfd, 0xae, 0xdb, 0x1a, 0x52, 0xaf, 0x49, 0x36, 0x97, 0xe7, 0x32, 0x0a, 0x9b, 0x53, 0x12,
	0xb3, 0xee, 0xfb, 0x7d, 0xb7, 0x25, 0xfc, 0x49, 0x01, 0x62, 0xc1, 0xbb, 0x4e, 0x10, 0xb9, 0x11,
	0xa9, 0x06, 0xd9, 0x76, 0x4d, 0x10, 0x24, 0x5a, 0x63, 0x80, 0xec, 0xf5, 0x19, 0x16, 0xad, 0x32,
	0xee, 0xc9, 0xbd, 0x79, 0x08, 0xe7, 0x65, 0x71, 0xc3, 0x6b, 0x4e, 0xd4, 0x7a, 0x20, 0x52, 0x6d,
	0x15, 0xca, 0x14, 0x4e, 0xea, 0x17, 0x0e, 0xa2, 0xab, 0xc4, 0x3f, 0x6c, 0x46, 0x55, 0xa7, 0x36,
	0x5f, 0x52, 0x69, 0x6f, 0xc7, 0x54, 0xd6, 0x8f, 0x35, 0xa8, 0xa9, 0x56, 0xe2, 0x9b, 0x39, 0x7f,
	0xa9, 0x17, 0x49, 0xea, 0x27, 0x95, 0xaa, 0x58, 0x29, 0xf6, 0x51, 0x13, 0x7b, 0xed, 0xd4, 0x6a,
	0x94, 0xcc, 0x16, 0xe4, 0xa8, 0x0e, 0x70, 0xc3, 0x39, 0xc6, 0x74, 0xcf, 0x84, 0x34, 0xc2, 0xa6,
	0x6d, 0x09, 0x63, 0xfd, 0x42, 0x87, 0x65, 0xb5, 0x9f, 0xd3, 0x3b, 0x56, 0x1b, 0x57, 0x55, 0xe9,
	0x99, 0xaa, 0x8a, 0xec, 0x86, 0xed, 0xaf, 0xde, 0xe9, 0xd0, 0x10, 0x35, 0xf8, 0x6e, 0x10, 0x08,
	0x96, 0x79, 0x68, 0x69, 0x75, 0xdd, 0x1f, 0x78, 0x11, 0x8d, 0xed, 0xa2, 0x9d, 0xc2, 0x11, 0xee,
	0x36, 0xb6, 0x7d, 0x9a, 0x0f, 0x8a, 0x2c, 0x1f, 0x08, 0x18, 0x5d, 0x81, 0x45, 0xf1, 0x4d, 0x8e,
	0x56, 0x2a, 0x3d, 0x4d, 0x37, 0x15, 0x7b, 0x74, 0x80, 0xac, 0xb6, 0xf3, 0xb0, 0xef, 0x06, 0x0e,
	0x09, 0x93, 0x46, 0xc4, 0x53, 0x4f, 0x0a, 0x47, 0xe4, 0xdd, 0xc6, 0x5d, 0x67, 0x88, 0xdb, 0xfb,
	0x3e, 0x0d, 0x64, 0xc3, 0x4e, 0x10, 0xd6, 0x27, 0x1a, 0xa0, 0xd1, 0x70, 0x26, 0x62, 0x24, 0x4c,
	0x44, 0xdb, 0xa1, 0x51, 0x5d, 0x46, 0x07, 0x88, 0x18, 0x94, 0xa3, 0x20, 0xd4, 0x99, 0xd2, 0x32,
	0x8e, 0x34, 0x3d, 0x7b, 0xce, 0xc3, 0x94, 0x6d, 0x0c, 0x4a, 0x96, 0x45, 0xa7, 0x29, 0x99, 0x01,
	0x58, 0x86, 0xc8, 0xa2, 0xad, 0x4f, 0x74, 0x58, 0x56, 0xc7, 0xc8, 0x09, 0x39, 0x6b, 0x19, 0x4a,
	0xa4, 0xd9, 0x69, 0xb0, 0xd6, 0xc7, 0xb0, 0x39, 0x34, 0x62, 0x4f, 0xe3, 0x24, 0x7b, 0x16, 0x32,
	0xf6, 0x24, 0x61, 0xbe, 0x1b, 0xb2, 0x8c, 0xce, 0x5c, 0x2b, 0xc0, 0x24, 0xd3, 0x97, 0xe4, 0x4c,
	0x5f, 0x07, 0xb0, 0x71, 0x27, 0x5d, 0x1f, 0x48, 0x18, 0x16, 0x2b, 0x1d, 0x96, 0x52, 0xa6, 0x59,
	0x9e, 0x14, 0x30, 0x8b, 0xb5, 0x4e, 0x92, 0x58, 0x2a, 0x22, 0xd6, 0x12, 0x1c, 0x91, 0xc7, 0xc6,
	0x9d, 0x1b, 0x4e, 0xf8, 0x80, 0xe6, 0x9d, 0x8a, 0x2d, 0x40, 0xeb, 0x6f, 0x1a, 0xac, 0xc8, 0xd6,
	0x14, 0xdb, 0xf6, 0xf1, 0xca, 0xb0, 0x27, 0xcb, 0xfa, 0x57, 0xe1, 0xcc, 0x9e, 0xf3, 0xf0, 0xf6,
	0xa0, 0x77, 0x80, 0x83, 0x3b, 0x9d, 0x38, 0xc1, 0xb0, 0x4d, 0xa2, 0x1a, 0x22, 0xc1, 0xf0, 0x75,
	0xc7, 0x8d, 0xe4, 0xee, 0xb7, 0xc8, 0xc2, 0x26, 0x83, 0x26, 0x3e, 0xdd, 0x0d, 0xef, 0x62, 0xe7,
	0x88, 0x9f, 0xce, 0x1c, 0xb2, 0x7e, 0xa4, 0xc3, 0xaa, 0x5a, 0x4f, 0x9e, 0x99, 0xc6, 0x2b, 0x3a,
	0x71, 0x22, 0x44, 0x1b, 0x60, 0x26, 0x6b, 0xd0, 0x75, 0xdb, 0x3c, 0xd4, 0x47, 0xf0, 0x34, 0xd6,
	0x39, 0x8e, 0x06, 0x19, 0x6e, 0x73, 0x63, 0x64, 0xd1, 0x92, 0x7a, 0x45, 0x59, 0x3d, 0x39, 0xe0,
	0x4a, 0x39, 0x01, 0x57, 0x96, 0x3b, 0xf9, 0x9f, 0x69, 0x50, 0x6b, 0xb4, 0x8e, 0x1a, 0xdd, 0xee,
	0x17, 0xe6, 0x75, 0x85, 0x0f, 0x0b, 0x4a, 0x1f, 0x5a, 0x3f, 0xd1, 0x60, 0x45, 0x29, 0xdc, 0x63,
	0xb9, 0x6a, 0x03, 0xcc, 0x46, 0xa7, 0x83, 0x5b, 0x11, 0x6e, 0x4b, 0x2e, 0x23, 0xd9, 0x7b, 0x04,
	0x2f, 0x9b, 0xcd, 0xc8, 0x31, 0x5b, 0x41, 0x36, 0xdb, 0xbf, 0x75, 0xa8, 0x35, 0xa3, 0x00, 0x3b,
	0xbd, 0x53, 0x36, 0xdb, 0x1d, 0x38, 0xcb, 0xf8, 0x66, 0xbb, 0x1a, 0x83, 0x76, 0x35, 0x71, 0xa5,
	0x3e, 0x42, 0x64, 0xab, 0xe7, 0x8d, 0xe9, 0x5e, 0xae, 0xc0, 0xe2, 0x7d, 0x37, 0x74, 0x0f, 0xdc,
	0xae, 0x1b, 0x0d, 0xd3, 0xbb, 0x69, 0x74, 0x40, 0xe5, 0xb5, 0x92, 0x7a, 0xe7, 0xad, 0x91, 0x9a,
	0xbf, 0x13, 0x1f, 0x98, 0x65, 0x6a, 0x72, 0x19, 0x85, 0x5e, 0x81, 0x85, 0x3d, 0xbf, 0xed, 0x76,
	0xdc, 0xd8, 0x03, 0xbc, 0xa4, 0x52, 0xef, 0xa5, 0x2c, 0xb1, 0xf5, 0x77, 0x0d, 0x56, 0x94, 0xd6,
	0x7f, 0xac, 0xb8, 0xc8, 0x35, 0xb1, 0xfe, 0x84, 0x26, 0xde, 0x84, 0xb2, 0x50, 0xc3, 0x18, 0xa3,
	0x86, 0x20, 0x92, 0x83, 0xad, 0x90, 0x13, 0x6c, 0x45, 0x39, 0xd8, 0x0e, 0xe1, 0x2c, 0x65, 0x14,
	0xde, 0xeb, 0x87, 0xb2, 0x00, 0xa7, 0x9d, 0xaa, 0xac, 0x0f, 0x35, 0x5e, 0x20, 0x49, 0x2b, 0x71,
	0x93, 0xb2, 0xc3, 0x25, 0xbb, 0x5a, 0x0a, 0xf7, 0x5f, 0x54, 0x6e, 0x93, 0x6e, 0xbf, 0xf7, 0x0b,
	0x70, 0x8e, 0x09, 0xba, 0xed, 0xbf, 0xe7, 0x4d, 0x62, 0x94, 0x71, 0x7b, 0x6f, 0x6f, 0xf4, 0x2e,
	0x81, 0xed, 0xba, 0x8b, 0x29, 0xbb, 0x8d, 0xae, 0xa9, 0xbe, 0x53, 0x18, 0x7f, 0x6f, 0xe0, 0x3c,
	0xdc, 0x8d, 0x70, 0x4f, 0x6c, 0xb8, 0x18, 0x26, 0xbb, 0x47, 0x6c, 0x28, 0x7f, 0x10, 0xf1, 0x3d,
	0x26, 0xa3, 0x08, 0xdf, 0xc6, 0x20, 0xf2, 0x1b, 0xad, 0x23, 0xba, 0xb7, 0xa6, 0x6d, 0x01, 0xa2,
	0xcb, 0x30, 0x6f, 0xb3, 0x53, 0x4d, 0x2c, 0xcc, 0x6a, 0x84, 0x0c, 0x16, 0x5d, 0x82, 0x39, 0xb1,
	0x17, 0x6d, 0xc7, 0x3b, 0xc4, 0xd5, 0xca, 0x9a, 0xb1, 0x6e, 0xd8, 0x69, 0x24, 0xc9, 0x9f, 0xa4,
	0xb6, 0x08, 0x1c, 0x2f, 0x74, 0x5a, 0xa4, 0x7a, 0xd8, 0x6d, 0xf3, 0xa2, 0x61, 0x04, 0x8f, 0x76,
	0xa5, 0xfe, 0x8d, 0xdd, 0x29, 0x3c, 0x77, 0x82, 0xcd, 0x36, 0x05, 0x3d, 0x6b, 0xd1, 0xe2, 0xe9,
	0xb5, 0x97, 0x60, 0x2e, 0x35, 0x34, 0x51, 0x7b, 0xf3, 0x4f, 0x03, 0xaa, 0xa3, 0x0b, 0xf2, 0x18,
	0xbe, 0x04, 0x73, 0x69, 0x6d, 0x18, 0xcb, 0x34, 0x32, 0x13, 0xe9, 0x6d, 0xbe, 0x46, 0x0a, 0x77,
	0xda, 0x91, 0x22, 0xef, 0xd4, 0xc2, 0x63, 0x15, 0x15, 0x97, 0x60, 0xae, 0xd1, 0x8a, 0xdc, 0x63,
	0x7c, 0xa7, 0xd3, 0x09, 0x71, 0x44, 0xc2, 0x88, 0x7a, 0x30, 0x85, 0x9c, 0xb4, 0x18, 0x20, 0xf5,
	0x98, 0x64, 0x8b, 0xeb, 0x7e, 0xaf, 0xdf, 0xc5, 0x11, 0xe6, 0x97, 0x14, 0xaa, 0x21, 0xf4, 0x86,
	0xe4, 0xf7, 0x0a, 0x95, 0x7c, 0x33, 0xdf, 0x02, 0xfc, 0x66, 0xe2, 0x7f, 0xe2, 0xf8, 0x1f, 0xea,
	0x50, 0xa1, 0x2b, 0xee, 0x7a, 0x1d, 0x1f, 0x21, 0x28, 0xdc, 0x76, 0x7a, 0x58, 0xfc, 0x80, 0x21,
	0xdf, 0xec, 0x8a, 0x41, 0x2a, 0x03, 0x0c, 0xc9, 0x9c, 0x4b, 0x50, 0xbc, 0x36, 0x8c, 0x70, 0xc8,
	0x2b, 0x7c, 0x06, 0x10, 0x23, 0xd3, 0xfb, 0xcd, 0xf8, 0x28, 0x63, 0xe5, 0x7d, 0x1a, 0x49, 0xe2,
	0xe5, 0x96, 0x23, 0x11, 0xb1, 0x3b, 0xf9, 0x14, 0x2e, 0xfe, 0xb3, 0xc2, 0xee, 0x7f, 0xd9, 0x9f,
	0x15, 0xd6, 0x38, 0xb8, 0xc7, 0x98, 0x54, 0x79, 0xe5, 0xb8, 0x71, 0x60, 0x08, 0xe2, 0x3a, 0xb2,
	0xe7, 0x5d, 0xef, 0x90, 0x37, 0x69, 0x02, 0x24, 0x09, 0x22, 0xbe, 0x16, 0x0e, 0x42, 0x5a, 0xe5,
	0x1b, 0xb6, 0x8c, 0xb2, 0x7e, 0xa9, 0x01, 0x30, 0xeb, 0x53, 0x63, 0xd4, 0x01, 0xf6, 0xfd, 0xc8,
	0x61, 0x35, 0x14, 0xef, 0xda, 0x24, 0x4c, 0xea, 0xb7, 0x8f, 0x52, 0x38, 0x63, 0x8c, 0x70, 0x85,
	0xb4, 0x70, 0x5f, 0x86, 0x12, 0x5b, 0x99, 0x06, 0xe4, 0xcc, 0xd6, 0x62, 0x2a, 0x1a, 0x88, 0x38,
	0x36, 0x27, 0xb0, 0xee, 0xc0, 0x62, 0x22, 0xe4, 0xe3, 0x25, 0xef, 0x55, 0xee, 0x63, 0xea, 0x5b,
	0x7e, 0xcb, 0x17, 0x23, 0xac, 0x77, 0x78, 0xeb, 0xca, 0x19, 0x4e, 0x70, 0x70, 0x5d, 0x86, 0x02,
	0x99, 0x43, 0x59, 0xce, 0x6c, 0xa1, 0x74, 0x04, 0x53, 0x6e, 0x74, 0xdc, 0xfa, 0x54, 0x83, 0xb3,
	0xb4, 0xd7, 0x9a, 0xf0, 0x24, 0xbe, 0x99, 0x77, 0x49, 0x1d, 0xff, 0x5f, 0x50, 0x72, 0x9d, 0xfc,
	0xaa, 0x7a, 0xe2, 0x44, 0x62, 0x7d, 0xae, 0xc3, 0x72, 0x76, 0xf1, 0x09, 0x2c, 0x77, 0xaa, 0x9a,
	0xed, 0xc3, 0x2c, 0xa5, 0x16, 0x45, 0x84, 0x41, 0x35, 0xb8, 0x9a, 0xc7, 0x49, 0x5c, 0x74, 0x4a,
	0x53, 0x58, 0x4a, 0x49, 0x71, 0x99, 0xb4, 0xda, 0xaa, 0xbd, 0x05, 0x8b, 0x23, 0x2c, 0x15, 0xa9,
	0x68, 0x53, 0x4e, 0x45, 0x33, 0x5b, 0x55, 0xb9, 0xd4, 0x91, 0xe7, 0xcb, 0x49, 0xea, 0x00, 0x96,
	0xc8, 0x70, 0xdc, 0x8e, 0x0b, 0x11, 0xdf, 0x00, 0x33, 0x8b, 0xab, 0x6a, 0x8f, 0x55, 0x41, 0x8d,
	0xcc, 0xb3, 0x7e, 0xa7, 0x81, 0x99, 0x95, 0x01, 0xdd, 0xce, 0x58, 0x96, 0x31, 0xdf, 0xc8, 0x93,
	0xf9, 0x24, 0x9b, 0xd6, 0xbe, 0x75, 0x82, 0x8d, 0x8a, 0xcc, 0x46, 0x5b, 0x69, 0x1b, 0xad, 0xca,
	0xeb, 0x65, 0x05, 0x97, 0xed, 0xf4, 0x52, 0xcc, 0xbe, 0xe5, 0x07, 0xed, 0x1b, 0xd8, 0x69, 0xe3,
	0x80, 0xb0, 0xbf, 0x99, 0xb8, 0xe0, 0x26, 0x3b, 0x0d, 0xee, 0xc7, 0xec, 0x67, 0x6d, 0x06, 0x58,
	0xbf, 0xd5, 0x60, 0x46, 0x9a, 0x8d, 0x9e, 0x87, 0x32, 0xe3, 0x20, 0xd4, 0x3e, 0x9f, 0x0a, 0x28,
	0x79, 0x0d, 0x5b, 0x50, 0x26, 0xf7, 0xb6, 0x7a, 0xee, 0xbd, 0x2d, 0xd9, 0x7b, 0x73, 0xf2, 0xbd,
	0x6d, 0xea, 0x0e, 0xb1, 0x40, 0xbb, 0x1e, 0xe9, 0x0e, 0x91, 0x8b, 0xcf, 0x2e, 0xb1, 0xd3, 0xe2,
	0x97, 0x64, 0xf1, 0xb7, 0x61, 0x9e, 0x2e, 0x96, 0xf0, 0x8d, 0x65, 0xd1, 0x72, 0x65, 0xd1, 0x33,
	0xb2, 0x58, 0x9f, 0x1b, 0x70, 0x9e, 0xed, 0x17, 0x7e, 0x30, 0xf4, 0x99, 0xa9, 0x59, 0xb6, 0x7a,
	0x1b, 0xce, 0x29, 0xd0, 0x64, 0x1f, 0xf2, 0x9f, 0xb2, 0xcf, 0xa4, 0xf7, 0x5c, 0x0e, 0xb1, 0x9d,
	0xc7, 0x05, 0x2d, 0x43, 0x89, 0xcd, 0xa4, 0x8d, 0x40, 0xc5, 0xe6, 0x10, 0x7a, 0x15, 0x16, 0xd2,
	0xca, 0x89, 0x4d, 0xbe, 0x9c, 0x5a, 0x30, 0x89, 0x8d, 0x2c, 0x39, 0xd9, 0xcd, 0xf4, 0xbf, 0xed,
	0xee, 0xb6, 0x28, 0xaa, 0x39, 0xc8, 0xce, 0xf7, 0xde, 0x01, 0x0e, 0x76, 0xb7, 0x93, 0x9f, 0x71,
	0x0c, 0x26, 0x63, 0xbb, 0x61, 0x33, 0x72, 0x22, 0xb7, 0x25, 0x7e, 0xd6, 0x08, 0x18, 0x1d, 0x40,
	0x55, 0x56, 0xa3, 0x19, 0x05, 0x4e, 0x84, 0x0f, 0x87, 0xd4, 0x1a, 0x65, 0x6a, 0x8d, 0xcb, 0xf9,
	0xd6, 0x90, 0xa9, 0xed, 0x5c, 0x3e, 0xe8, 0x9b, 0xf1, 0xaf, 0x5c, 0x3a, 0xc6, 0xea, 0x33, 0xba,
	0xc2, 0x34, 0x5d, 0xe1, 0x52, 0xfe, 0x0a, 0x09, 0xad, 0x9d, 0xc3, 0xc3, 0xfa, 0xa3, 0x0e, 0xe7,
	0x46, 0x27, 0xb2, 0xf7, 0x19, 0x97, 0x61, 0x5e, 0x46, 0xc6, 0x69, 0x3c, 0x83, 0x45, 0x6f, 0xc1,
	0xd9, 0x91, 0xc9, 0x54, 0x40, 0x3d, 0x5d, 0xd7, 0xe6, 0xac, 0xc3, 0xdb, 0x63, 0x15, 0x5a, 0x76,
	0x99, 0x91, 0xef, 0xb2, 0x42, 0xc6, 0x65, 0x5b, 0x30, 0xdd, 0x08, 0x43, 0xf7, 0xd0, 0xa3, 0xb7,
	0xe2, 0xe3, 0x62, 0x24, 0xa6, 0x63, 0xb7, 0xa3, 0xcd, 0xa1, 0xd7, 0x6a, 0x88, 0x52, 0x2b, 0x86,
	0xe5, 0x63, 0x60, 0x21, 0xe7, 0x18, 0x30, 0xe5, 0x16, 0xf3, 0x43, 0x4d, 0x18, 0x75, 0xd2, 0x16,
	0xf3, 0x2d, 0x38, 0xab, 0xac, 0xfb, 0xd5, 0xa6, 0x54, 0xb7, 0x08, 0x6a, 0x0e, 0xa4, 0x54, 0x8b,
	0x9b, 0x8d, 0x59, 0x9b, 0x7e, 0x5b, 0x1f, 0x69, 0x50, 0x1d, 0x65, 0xa5, 0x6e, 0x79, 0xb6, 0x55,
	0x2d, 0xcf, 0xf6, 0xc8, 0x49, 0xaf, 0x2b, 0x4e, 0x7a, 0xc5, 0xd2, 0x93, 0xda, 0x74, 0xe3, 0xd7,
	0x1a, 0x2c, 0x8e, 0x5c, 0xa1, 0xa0, 0x55, 0xa8, 0x8e, 0x20, 0x93, 0x5f, 0xc3, 0x88, 0xf4, 0xb4,
	0xf4, 0x7a, 0x94, 0x9f, 0x7c, 0xa6, 0x86, 0xe6, 0x01, 0x1a, 0xad, 0x23, 0x01, 0xd3, 0xd7, 0x07,
	0x36, 0xfe, 0x36, 0x6e, 0x45, 0x02, 0x65, 0xa0, 0x25, 0x30, 0xe9, 0xad, 0xd1, 0x30, 0xb9, 0xc9,
	0x32, 0x0b, 0x8c, 0x30, 0xc4, 0x9e, 0xb8, 0x49, 0x32, 0x8b, 0xe8, 0x1c, 0x9c, 0x21, 0xc7, 0x51,
	0xe6, 0x8a, 0xc9, 0x2c, 0x6d, 0x7c, 0xae, 0xc1, 0xca, 0x98, 0x2e, 0x0e, 0xd5, 0x60, 0xf9, 0xae,
	0xdf, 0xed, 0x2a, 0x85, 0x2e, 0x83, 0xf1, 0x3a, 0x8e, 0x4c, 0x0d, 0x01, 0x94, 0xd8, 0x05, 0x26,
	0x7b, 0x96, 0xd1, 0x68, 0x1d, 0xd1, 0xde, 0x9a, 0x3d, 0xcb, 0xb8, 0xcd, 0x87, 0x0a, 0x68, 0x0e,
	0x2a, 0xb7, 0xe3, 0xb1, 0x22, 0xd1, 0x8f, 0x77, 0xec, 0x64, 0xb8, 0x84, 0x4c, 0xe2, 0x1f, 0x0a,
	0x33, 0x8a, 0x32, 0x51, 0x24, 0xd5, 0xea, 0x99, 0xd3, 0xe8, 0x2c, 0x2c, 0x4a, 0x5e, 0x25, 0xc9,
	0x6d, 0x10, 0x9a, 0x15, 0x42, 0x79, 0xbd, 0xeb, 0x87, 0xf8, 0xda, 0x90, 0x55, 0x89, 0x26, 0x48,
	0x28, 0xf6, 0x64, 0xcc, 0x9c, 0xd9, 0xe8, 0x89, 0xe3, 0x42, 0x51, 0xa8, 0xa1, 0x35, 0x58, 0x55,
	0x0e, 0x26, 0xfa, 0x2e, 0xd2, 0x4e, 0x09, 0x37, 0xbc, 0xf6, 0x6b, 0x7e, 0x70, 0x48, 0x35, 0x9f,
	0x83, 0x0a, 0xb1, 0x6b, 0x23, 0x1c, 0x7a, 0x2d, 0xa6, 0x3c, 0x01, 0xc9, 0x66, 0x34, 0x8d, 0x0d,
	0x0f, 0xea, 0xe3, 0x73, 0x29, 0x7a, 0x06, 0x9e, 0xce, 0x1b, 0x93, 0x5f, 0xa7, 0x54, 0xa0, 0xc8,
	0x4c, 0x42, 0x83, 0xc2, 0xf6, 0x07, 0x5e, 0xdb, 0xf6, 0x0f, 0x5c, 0xcf, 0xd4, 0x89, 0xe9, 0x9b,
	0x91, 0xdb, 0x3a, 0x1a, 0x9a, 0xc6, 0xc6, 0xc7, 0x9a, 0x50, 0x41, 0x9d, 0x42, 0xd1, 0x45, 0xb8,
	0xa0, 0x1e, 0xf9, 0x7f, 0x3f, 0x85, 0xd9, 0xf8, 0x81, 0x06, 0x4f, 0x8d, 0x3d, 0x85, 0xd1, 0x25,
	0x58, 0xcb, 0x19, 0x92, 0x85, 0xbf, 0x00, 0x2b, 0x39, 0x54, 0x6f, 0xf8, 0xae, 0x67, 0x6a, 0xc4,
	0xcb, 0x39, 0x04, 0xb7, 0xb0, 0x73, 0x8c, 0x4d, 0x7d, 0xe3, 0x03, 0x1d, 0x56, 0xc6, 0xe4, 0x7f,
	0x64, 0x41, 0x5d, 0x39, 0x20, 0x8b, 0x91, 0x47, 0x13, 0xf7, 0xaf, 0xa6, 0x96, 0x15, 0x35, 0x39,
	0x60, 0x68, 0x2e, 0x37, 0x75, 0xf4, 0x25, 0xb8, 0x38, 0x86, 0x40, 0x5c, 0x4e, 0x98, 0x46, 0xee,
	0x6a, 0x37, 0xb0, 0x13, 0x44, 0x07, 0xd8, 0x89, 0xcc, 0x02, 0xaa, 0x43, 0x4d, 0x49, 0xc3, 0xb4,
	0x2e, 0x66, 0x43, 0x23, 0x1e, 0xa7, 0x87, 0x18, 0xd9, 0x66, 0x24, 0x59, 0xfc, 0x5c, 0x13, 0xa6,
	0x51, 0x27, 0x0b, 0x0b, 0xea, 0xca, 0x01, 0xd9, 0x34, 0x57, 0x60, 0x5d, 0x49, 0xa3, 0xf0, 0x8a,
	0xa9, 0xa1, 0x0d, 0xb8, 0x7c, 0x22, 0x35, 0x95, 0xd5, 0xd4, 0xb7, 0xfe, 0x3c, 0x0d, 0xfc, 0xd5,
	0x2a, 0xba, 0xc2, 0xb6, 0x25, 0x2b, 0x0e, 0xe6, 0x52, 0x6f, 0x00, 0x6b, 0xf3, 0xd2, 0x23, 0x92,
	0x41, 0x37, 0xb2, 0xa6, 0xd0, 0x0b, 0xac, 0x97, 0x10, 0xcf, 0xc3, 0xc8, 0x52, 0x27, 0x4e, 0x5a,
	0xd7, 0xae, 0x6a, 0xe8, 0x55, 0xf9, 0xc1, 0x9f, 0xcf, 0xe6, 0xa3, 0xc5, 0x91, 0xd7, 0x74, 0xb5,
	0x25, 0xd5, 0x2b, 0x44, 0x6b, 0xea, 0xaa, 0x86, 0x5e, 0x86, 0x33, 0x12, 0x07, 0xae, 0xa0, 0x92,
	0xc7, 0x42, 0xe6, 0xf5, 0x12, 0x9d, 0xbe, 0x05, 0x33, 0x44, 0x72, 0x71, 0x62, 0x67, 0x69, 0x6a,
	0x66, 0xf6, 0xc1, 0x8c, 0x35, 0x85, 0xbe, 0x02, 0xb3, 0x6c, 0x0e, 0x3f, 0x3c, 0x47, 0x68, 0x6a,
	0x89, 0xee, 0xf4, 0x51, 0xed, 0x14, 0xe9, 0xdc, 0xb2, 0x9d, 0x19, 0x52, 0xb6, 0xdc, 0xb5, 0x13,
	0x3a, 0x39, 0x6b, 0x0a, 0x39, 0xa3, 0x7f, 0xaf, 0xd9, 0xa3, 0x09, 0xf4, 0xb4, 0x8a, 0x63, 0xea,
	0xe9, 0x46, 0xcd, 0x1a, 0x47, 0x12, 0x6b, 0xd8, 0x82, 0x25, 0xd5, 0xbf, 0x4f, 0x74, 0x31, 0xd1,
	0x34, 0xf7, 0x0f, 0x70, 0xed, 0xd2, 0x78, 0x22, 0x69, 0x11, 0x34, 0xfa, 0x73, 0x06, 0x59, 0xe9,
	0xdf, 0x2a, 0xca, 0x15, 0x2e, 0x8e, 0xa5, 0x11, 0x0b, 0xd0, 0x00, 0x7b, 0x07, 0xce, 0x28, 0xfe,
	0x0c, 0x26, 0xab, 0xe4, 0xff, 0xd3, 0x4c, 0x56, 0x19, 0xf3, 0x6b, 0xd1, 0x9a, 0x42, 0xcf, 0x42,
	0xe1, 0xae, 0xeb, 0x1d, 0xa2, 0xb4, 0xcf, 0x6b, 0xf1, 0xed, 0x50, 0xf2, 0xde, 0xdb, 0x9a, 0x42,
	0xdf, 0x00, 0x33, 0x5b, 0x2b, 0xa0, 0x0b, 0x27, 0xdc, 0x05, 0xd7, 0xd6, 0x4e, 0xba, 0x2a, 0xe5,
	0xba, 0xde, 0x83, 0xf9, 0xf4, 0x5f, 0x19, 0xf4, 0x54, 0x7a, 0x66, 0xe6, 0x5c, 0xae, 0xd5, 0xf3,
	0x86, 0x53, 0x6c, 0x77, 0x52, 0xb7, 0x84, 0xe7, 0x15, 0xb7, 0x5e, 0x9c, 0x5d, 0x4d, 0x35, 0x24,
	0x58, 0x5d, 0x5b, 0xff, 0xd3, 0x67, 0xf5, 0xa9, 0x7f, 0x7c, 0x56, 0xd7, 0xfe, 0xf5, 0x59, 0x5d,
	0xfb, 0xce, 0xa3, 0xba, 0xf6, 0xd1, 0xa3, 0xba, 0xf6, 0xf1, 0xa3, 0xba, 0xf6, 0xfb, 0x47, 0x75,
	0xed, 0xd3, 0x47, 0x75, 0xed, 0x2f, 0x8f, 0xea, 0xda, 0x07, 0x7f, 0xad, 0x4f, 0x1d, 0x94, 0xe8,
	0x63, 0xf9, 0xe7, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x10, 0xca, 0xa5, 0xfb, 0x53, 0x2f, 0x00,
	0x00,
}

func (this *PingResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PingResult)
	if !ok {
		that2, ok := that.(PingResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ServerStartTime != that1.ServerStartTime {
		return false
	}
	if this.ServerUpTimeSeconds != that1.ServerUpTimeSeconds {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Result) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Result)
	if !ok {
		that2, ok := that.(Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Sent != that1.Sent {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Store != that1.Store {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *EventReceive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventReceive)
	if !ok {
		that2, ok := that.(EventReceive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Subscribe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Subscribe)
	if !ok {
		that2, ok := that.(Subscribe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscribeTypeData != that1.SubscribeTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if this.EventsStoreTypeData != that1.EventsStoreTypeData {
		return false
	}
	if this.EventsStoreTypeValue != that1.EventsStoreTypeValue {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.CacheKey != that1.CacheKey {
		return false
	}
	if this.CacheTTL != that1.CacheTTL {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.CacheHit != that1.CacheHit {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessage)
	if !ok {
		that2, ok := that.(QueueMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MessageID != that1.MessageID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !this.Attributes.Equal(that1.Attributes) {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.PartitionKey != that1.PartitionKey {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessagesBatchRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagesBatchRequest)
	if !ok {
		that2, ok := that.(QueueMessagesBatchRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BatchID != that1.BatchID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessagesBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagesBatchResponse)
	if !ok {
		that2, ok := that.(QueueMessagesBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BatchID != that1.BatchID {
		return false
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	if this.HaveErrors != that1.HaveErrors {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessageAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessageAttributes)
	if !ok {
		that2, ok := that.(QueueMessageAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	if this.MD5OfBody != that1.MD5OfBody {
		return false
	}
	if this.ReceiveCount != that1.ReceiveCount {
		return false
	}
	if this.ReRouted != that1.ReRouted {
		return false
	}
	if this.ReRoutedFromQueue != that1.ReRoutedFromQueue {
		return false
	}
	if this.ExpirationAt != that1.ExpirationAt {
		return false
	}
	if this.DelayedTo != that1.DelayedTo {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueMessagePolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagePolicy)
	if !ok {
		that2, ok := that.(QueueMessagePolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpirationSeconds != that1.ExpirationSeconds {
		return false
	}
	if this.DelaySeconds != that1.DelaySeconds {
		return false
	}
	if this.MaxReceiveCount != that1.MaxReceiveCount {
		return false
	}
	if this.MaxReceiveQueue != that1.MaxReceiveQueue {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SendQueueMessageResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendQueueMessageResult)
	if !ok {
		that2, ok := that.(SendQueueMessageResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MessageID != that1.MessageID {
		return false
	}
	if this.SentAt != that1.SentAt {
		return false
	}
	if this.ExpirationAt != that1.ExpirationAt {
		return false
	}
	if this.DelayedTo != that1.DelayedTo {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if this.RefChannel != that1.RefChannel {
		return false
	}
	if this.RefTopic != that1.RefTopic {
		return false
	}
	if this.RefPartition != that1.RefPartition {
		return false
	}
	if this.RefHash != that1.RefHash {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReceiveQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReceiveQueueMessagesRequest)
	if !ok {
		that2, ok := that.(ReceiveQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.MaxNumberOfMessages != that1.MaxNumberOfMessages {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if this.IsPeak != that1.IsPeak {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReceiveQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReceiveQueueMessagesResponse)
	if !ok {
		that2, ok := that.(ReceiveQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if this.MessagesReceived != that1.MessagesReceived {
		return false
	}
	if this.MessagesExpired != that1.MessagesExpired {
		return false
	}
	if this.IsPeak != that1.IsPeak {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AckAllQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AckAllQueueMessagesRequest)
	if !ok {
		that2, ok := that.(AckAllQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AckAllQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AckAllQueueMessagesResponse)
	if !ok {
		that2, ok := that.(AckAllQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AffectedMessages != that1.AffectedMessages {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StreamQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamQueueMessagesRequest)
	if !ok {
		that2, ok := that.(StreamQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.StreamRequestTypeData != that1.StreamRequestTypeData {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.VisibilitySeconds != that1.VisibilitySeconds {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if this.RefSequence != that1.RefSequence {
		return false
	}
	if !this.ModifiedMessage.Equal(that1.ModifiedMessage) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StreamQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamQueueMessagesResponse)
	if !ok {
		that2, ok := that.(StreamQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.StreamRequestTypeData != that1.StreamRequestTypeData {
		return false
	}
	if !this.Message.Equal(that1.Message) {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesUpstreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesUpstreamRequest)
	if !ok {
		that2, ok := that.(QueuesUpstreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesUpstreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesUpstreamResponse)
	if !ok {
		that2, ok := that.(QueuesUpstreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RefRequestID != that1.RefRequestID {
		return false
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesDownstreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesDownstreamRequest)
	if !ok {
		that2, ok := that.(QueuesDownstreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.MaxItems != that1.MaxItems {
		return false
	}
	if this.WaitTimeout != that1.WaitTimeout {
		return false
	}
	if this.AutoAck != that1.AutoAck {
		return false
	}
	if this.ReQueueChannel != that1.ReQueueChannel {
		return false
	}
	if len(this.SequenceRange) != len(that1.SequenceRange) {
		return false
	}
	for i := range this.SequenceRange {
		if this.SequenceRange[i] != that1.SequenceRange[i] {
			return false
		}
	}
	if this.RefTransactionId != that1.RefTransactionId {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesDownstreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesDownstreamResponse)
	if !ok {
		that2, ok := that.(QueuesDownstreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TransactionId != that1.TransactionId {
		return false
	}
	if this.RefRequestId != that1.RefRequestId {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if len(this.ActiveOffsets) != len(that1.ActiveOffsets) {
		return false
	}
	for i := range this.ActiveOffsets {
		if this.ActiveOffsets[i] != that1.ActiveOffsets[i] {
			return false
		}
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if this.TransactionComplete != that1.TransactionComplete {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueueInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueInfo)
	if !ok {
		that2, ok := that.(QueueInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Messages != that1.Messages {
		return false
	}
	if this.Bytes != that1.Bytes {
		return false
	}
	if this.FirstSequence != that1.FirstSequence {
		return false
	}
	if this.LastSequence != that1.LastSequence {
		return false
	}
	if this.Sent != that1.Sent {
		return false
	}
	if this.Delivered != that1.Delivered {
		return false
	}
	if this.Waiting != that1.Waiting {
		return false
	}
	if this.Subscribers != that1.Subscribers {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesInfo)
	if !ok {
		that2, ok := that.(QueuesInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalQueue != that1.TotalQueue {
		return false
	}
	if this.Sent != that1.Sent {
		return false
	}
	if this.Delivered != that1.Delivered {
		return false
	}
	if this.Waiting != that1.Waiting {
		return false
	}
	if len(this.Queues) != len(that1.Queues) {
		return false
	}
	for i := range this.Queues {
		if !this.Queues[i].Equal(that1.Queues[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesInfoRequest)
	if !ok {
		that2, ok := that.(QueuesInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.QueueName != that1.QueueName {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *QueuesInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueuesInfoResponse)
	if !ok {
		that2, ok := that.(QueuesInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RefRequestID != that1.RefRequestID {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicsUpstreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicsUpstreamRequest)
	if !ok {
		that2, ok := that.(TopicsUpstreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicsUpstreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicsUpstreamResponse)
	if !ok {
		that2, ok := that.(TopicsUpstreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RefRequestID != that1.RefRequestID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if len(this.TopicResults) != len(that1.TopicResults) {
		return false
	}
	for i := range this.TopicResults {
		if !this.TopicResults[i].Equal(that1.TopicResults[i]) {
			return false
		}
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SendPartitionResults) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPartitionResults)
	if !ok {
		that2, ok := that.(SendPartitionResults)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PartitionResults) != len(that1.PartitionResults) {
		return false
	}
	for i := range this.PartitionResults {
		if !this.PartitionResults[i].Equal(that1.PartitionResults[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SendTopicResults) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendTopicResults)
	if !ok {
		that2, ok := that.(SendTopicResults)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TopicResults) != len(that1.TopicResults) {
		return false
	}
	for i := range this.TopicResults {
		if !this.TopicResults[i].Equal(that1.TopicResults[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicRecordHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicRecordHeader)
	if !ok {
		that2, ok := that.(TopicRecordHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicRecord)
	if !ok {
		that2, ok := that.(TopicRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicPartition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicPartition)
	if !ok {
		that2, ok := that.(TopicPartition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicsSubscriptionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicsSubscriptionRequest)
	if !ok {
		that2, ok := that.(TopicsSubscriptionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscriptionRequestType != that1.SubscriptionRequestType {
		return false
	}
	if len(this.Topics) != len(that1.Topics) {
		return false
	}
	for i := range this.Topics {
		if this.Topics[i] != that1.Topics[i] {
			return false
		}
	}
	if len(this.TopicPartitions) != len(that1.TopicPartitions) {
		return false
	}
	for i := range this.TopicPartitions {
		if !this.TopicPartitions[i].Equal(that1.TopicPartitions[i]) {
			return false
		}
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if this.IsStatic != that1.IsStatic {
		return false
	}
	if this.SubscriptionStrategyType != that1.SubscriptionStrategyType {
		return false
	}
	if this.SubscriptionOffsetType != that1.SubscriptionOffsetType {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicsSubscriptionEvent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicsSubscriptionEvent)
	if !ok {
		that2, ok := that.(TopicsSubscriptionEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscriptionID != that1.SubscriptionID {
		return false
	}
	if this.SubscriptionEventType != that1.SubscriptionEventType {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.Assigned) != len(that1.Assigned) {
		return false
	}
	for i := range this.Assigned {
		if !this.Assigned[i].Equal(that1.Assigned[i]) {
			return false
		}
	}
	if this.ReSyncAt != that1.ReSyncAt {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicsDownstreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicsDownstreamRequest)
	if !ok {
		that2, ok := that.(TopicsDownstreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.DownstreamRequestType != that1.DownstreamRequestType {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TopicsDownstreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicsDownstreamResponse)
	if !ok {
		that2, ok := that.(TopicsDownstreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TransactionID != that1.TransactionID {
		return false
	}
	if this.RefRequestID != that1.RefRequestID {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PingResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.PingResult{")
	s = append(s, "Host: "+fmt.Sprintf("%#v", this.Host)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "ServerStartTime: "+fmt.Sprintf("%#v", this.ServerStartTime)+",\n")
	s = append(s, "ServerUpTimeSeconds: "+fmt.Sprintf("%#v", this.ServerUpTimeSeconds)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&kubemq.Empty{")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.Result{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Sent: "+fmt.Sprintf("%#v", this.Sent)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.Event{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Store: "+fmt.Sprintf("%#v", this.Store)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EventReceive) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.EventReceive{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Sequence: "+fmt.Sprintf("%#v", this.Sequence)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Subscribe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.Subscribe{")
	s = append(s, "SubscribeTypeData: "+fmt.Sprintf("%#v", this.SubscribeTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "EventsStoreTypeData: "+fmt.Sprintf("%#v", this.EventsStoreTypeData)+",\n")
	s = append(s, "EventsStoreTypeValue: "+fmt.Sprintf("%#v", this.EventsStoreTypeValue)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&kubemq.Request{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "CacheKey: "+fmt.Sprintf("%#v", this.CacheKey)+",\n")
	s = append(s, "CacheTTL: "+fmt.Sprintf("%#v", this.CacheTTL)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&kubemq.Response{")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "CacheHit: "+fmt.Sprintf("%#v", this.CacheHit)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Executed: "+fmt.Sprintf("%#v", this.Executed)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&kubemq.QueueMessage{")
	s = append(s, "MessageID: "+fmt.Sprintf("%#v", this.MessageID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	s = append(s, "Partition: "+fmt.Sprintf("%#v", this.Partition)+",\n")
	s = append(s, "PartitionKey: "+fmt.Sprintf("%#v", this.PartitionKey)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagesBatchRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.QueueMessagesBatchRequest{")
	s = append(s, "BatchID: "+fmt.Sprintf("%#v", this.BatchID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagesBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.QueueMessagesBatchResponse{")
	s = append(s, "BatchID: "+fmt.Sprintf("%#v", this.BatchID)+",\n")
	if this.Results != nil {
		s = append(s, "Results: "+fmt.Sprintf("%#v", this.Results)+",\n")
	}
	s = append(s, "HaveErrors: "+fmt.Sprintf("%#v", this.HaveErrors)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessageAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.QueueMessageAttributes{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Sequence: "+fmt.Sprintf("%#v", this.Sequence)+",\n")
	s = append(s, "MD5OfBody: "+fmt.Sprintf("%#v", this.MD5OfBody)+",\n")
	s = append(s, "ReceiveCount: "+fmt.Sprintf("%#v", this.ReceiveCount)+",\n")
	s = append(s, "ReRouted: "+fmt.Sprintf("%#v", this.ReRouted)+",\n")
	s = append(s, "ReRoutedFromQueue: "+fmt.Sprintf("%#v", this.ReRoutedFromQueue)+",\n")
	s = append(s, "ExpirationAt: "+fmt.Sprintf("%#v", this.ExpirationAt)+",\n")
	s = append(s, "DelayedTo: "+fmt.Sprintf("%#v", this.DelayedTo)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagePolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.QueueMessagePolicy{")
	s = append(s, "ExpirationSeconds: "+fmt.Sprintf("%#v", this.ExpirationSeconds)+",\n")
	s = append(s, "DelaySeconds: "+fmt.Sprintf("%#v", this.DelaySeconds)+",\n")
	s = append(s, "MaxReceiveCount: "+fmt.Sprintf("%#v", this.MaxReceiveCount)+",\n")
	s = append(s, "MaxReceiveQueue: "+fmt.Sprintf("%#v", this.MaxReceiveQueue)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendQueueMessageResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&kubemq.SendQueueMessageResult{")
	s = append(s, "MessageID: "+fmt.Sprintf("%#v", this.MessageID)+",\n")
	s = append(s, "SentAt: "+fmt.Sprintf("%#v", this.SentAt)+",\n")
	s = append(s, "ExpirationAt: "+fmt.Sprintf("%#v", this.ExpirationAt)+",\n")
	s = append(s, "DelayedTo: "+fmt.Sprintf("%#v", this.DelayedTo)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "RefChannel: "+fmt.Sprintf("%#v", this.RefChannel)+",\n")
	s = append(s, "RefTopic: "+fmt.Sprintf("%#v", this.RefTopic)+",\n")
	s = append(s, "RefPartition: "+fmt.Sprintf("%#v", this.RefPartition)+",\n")
	s = append(s, "RefHash: "+fmt.Sprintf("%#v", this.RefHash)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReceiveQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.ReceiveQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "MaxNumberOfMessages: "+fmt.Sprintf("%#v", this.MaxNumberOfMessages)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	s = append(s, "IsPeak: "+fmt.Sprintf("%#v", this.IsPeak)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReceiveQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.ReceiveQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	s = append(s, "MessagesReceived: "+fmt.Sprintf("%#v", this.MessagesReceived)+",\n")
	s = append(s, "MessagesExpired: "+fmt.Sprintf("%#v", this.MessagesExpired)+",\n")
	s = append(s, "IsPeak: "+fmt.Sprintf("%#v", this.IsPeak)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AckAllQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.AckAllQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AckAllQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.AckAllQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "AffectedMessages: "+fmt.Sprintf("%#v", this.AffectedMessages)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.StreamQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "StreamRequestTypeData: "+fmt.Sprintf("%#v", this.StreamRequestTypeData)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "VisibilitySeconds: "+fmt.Sprintf("%#v", this.VisibilitySeconds)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	s = append(s, "RefSequence: "+fmt.Sprintf("%#v", this.RefSequence)+",\n")
	if this.ModifiedMessage != nil {
		s = append(s, "ModifiedMessage: "+fmt.Sprintf("%#v", this.ModifiedMessage)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&kubemq.StreamQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "StreamRequestTypeData: "+fmt.Sprintf("%#v", this.StreamRequestTypeData)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesUpstreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.QueuesUpstreamRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesUpstreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.QueuesUpstreamResponse{")
	s = append(s, "RefRequestID: "+fmt.Sprintf("%#v", this.RefRequestID)+",\n")
	if this.Results != nil {
		s = append(s, "Results: "+fmt.Sprintf("%#v", this.Results)+",\n")
	}
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesDownstreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&kubemq.QueuesDownstreamRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "MaxItems: "+fmt.Sprintf("%#v", this.MaxItems)+",\n")
	s = append(s, "WaitTimeout: "+fmt.Sprintf("%#v", this.WaitTimeout)+",\n")
	s = append(s, "AutoAck: "+fmt.Sprintf("%#v", this.AutoAck)+",\n")
	s = append(s, "ReQueueChannel: "+fmt.Sprintf("%#v", this.ReQueueChannel)+",\n")
	s = append(s, "SequenceRange: "+fmt.Sprintf("%#v", this.SequenceRange)+",\n")
	s = append(s, "RefTransactionId: "+fmt.Sprintf("%#v", this.RefTransactionId)+",\n")
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesDownstreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&kubemq.QueuesDownstreamResponse{")
	s = append(s, "TransactionId: "+fmt.Sprintf("%#v", this.TransactionId)+",\n")
	s = append(s, "RefRequestId: "+fmt.Sprintf("%#v", this.RefRequestId)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	s = append(s, "ActiveOffsets: "+fmt.Sprintf("%#v", this.ActiveOffsets)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "TransactionComplete: "+fmt.Sprintf("%#v", this.TransactionComplete)+",\n")
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&kubemq.QueueInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	s = append(s, "Bytes: "+fmt.Sprintf("%#v", this.Bytes)+",\n")
	s = append(s, "FirstSequence: "+fmt.Sprintf("%#v", this.FirstSequence)+",\n")
	s = append(s, "LastSequence: "+fmt.Sprintf("%#v", this.LastSequence)+",\n")
	s = append(s, "Sent: "+fmt.Sprintf("%#v", this.Sent)+",\n")
	s = append(s, "Delivered: "+fmt.Sprintf("%#v", this.Delivered)+",\n")
	s = append(s, "Waiting: "+fmt.Sprintf("%#v", this.Waiting)+",\n")
	s = append(s, "Subscribers: "+fmt.Sprintf("%#v", this.Subscribers)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&kubemq.QueuesInfo{")
	s = append(s, "TotalQueue: "+fmt.Sprintf("%#v", this.TotalQueue)+",\n")
	s = append(s, "Sent: "+fmt.Sprintf("%#v", this.Sent)+",\n")
	s = append(s, "Delivered: "+fmt.Sprintf("%#v", this.Delivered)+",\n")
	s = append(s, "Waiting: "+fmt.Sprintf("%#v", this.Waiting)+",\n")
	if this.Queues != nil {
		s = append(s, "Queues: "+fmt.Sprintf("%#v", this.Queues)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.QueuesInfoRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "QueueName: "+fmt.Sprintf("%#v", this.QueueName)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueuesInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.QueuesInfoResponse{")
	s = append(s, "RefRequestID: "+fmt.Sprintf("%#v", this.RefRequestID)+",\n")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicsUpstreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.TopicsUpstreamRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicsUpstreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&kubemq.TopicsUpstreamResponse{")
	s = append(s, "RefRequestID: "+fmt.Sprintf("%#v", this.RefRequestID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	keysForTopicResults := make([]string, 0, len(this.TopicResults))
	for k, _ := range this.TopicResults {
		keysForTopicResults = append(keysForTopicResults, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTopicResults)
	mapStringForTopicResults := "map[string]*SendTopicResults{"
	for _, k := range keysForTopicResults {
		mapStringForTopicResults += fmt.Sprintf("%#v: %#v,", k, this.TopicResults[k])
	}
	mapStringForTopicResults += "}"
	if this.TopicResults != nil {
		s = append(s, "TopicResults: "+mapStringForTopicResults+",\n")
	}
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPartitionResults) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&kubemq.SendPartitionResults{")
	if this.PartitionResults != nil {
		s = append(s, "PartitionResults: "+fmt.Sprintf("%#v", this.PartitionResults)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendTopicResults) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&kubemq.SendTopicResults{")
	keysForTopicResults := make([]int32, 0, len(this.TopicResults))
	for k, _ := range this.TopicResults {
		keysForTopicResults = append(keysForTopicResults, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForTopicResults)
	mapStringForTopicResults := "map[int32]*SendPartitionResults{"
	for _, k := range keysForTopicResults {
		mapStringForTopicResults += fmt.Sprintf("%#v: %#v,", k, this.TopicResults[k])
	}
	mapStringForTopicResults += "}"
	if this.TopicResults != nil {
		s = append(s, "TopicResults: "+mapStringForTopicResults+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicRecordHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.TopicRecordHeader{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicRecord) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.TopicRecord{")
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	s = append(s, "Partition: "+fmt.Sprintf("%#v", this.Partition)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicPartition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.TopicPartition{")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	s = append(s, "Partition: "+fmt.Sprintf("%#v", this.Partition)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicsSubscriptionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.TopicsSubscriptionRequest{")
	s = append(s, "SubscriptionRequestType: "+fmt.Sprintf("%#v", this.SubscriptionRequestType)+",\n")
	s = append(s, "Topics: "+fmt.Sprintf("%#v", this.Topics)+",\n")
	if this.TopicPartitions != nil {
		s = append(s, "TopicPartitions: "+fmt.Sprintf("%#v", this.TopicPartitions)+",\n")
	}
	s = append(s, "GroupID: "+fmt.Sprintf("%#v", this.GroupID)+",\n")
	s = append(s, "MemberID: "+fmt.Sprintf("%#v", this.MemberID)+",\n")
	s = append(s, "IsStatic: "+fmt.Sprintf("%#v", this.IsStatic)+",\n")
	s = append(s, "SubscriptionStrategyType: "+fmt.Sprintf("%#v", this.SubscriptionStrategyType)+",\n")
	s = append(s, "SubscriptionOffsetType: "+fmt.Sprintf("%#v", this.SubscriptionOffsetType)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicsSubscriptionEvent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.TopicsSubscriptionEvent{")
	s = append(s, "SubscriptionID: "+fmt.Sprintf("%#v", this.SubscriptionID)+",\n")
	s = append(s, "SubscriptionEventType: "+fmt.Sprintf("%#v", this.SubscriptionEventType)+",\n")
	s = append(s, "GroupID: "+fmt.Sprintf("%#v", this.GroupID)+",\n")
	s = append(s, "MemberID: "+fmt.Sprintf("%#v", this.MemberID)+",\n")
	if this.Assigned != nil {
		s = append(s, "Assigned: "+fmt.Sprintf("%#v", this.Assigned)+",\n")
	}
	s = append(s, "ReSyncAt: "+fmt.Sprintf("%#v", this.ReSyncAt)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicsDownstreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.TopicsDownstreamRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "DownstreamRequestType: "+fmt.Sprintf("%#v", this.DownstreamRequestType)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopicsDownstreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&kubemq.TopicsDownstreamResponse{")
	s = append(s, "TransactionID: "+fmt.Sprintf("%#v", this.TransactionID)+",\n")
	s = append(s, "RefRequestID: "+fmt.Sprintf("%#v", this.RefRequestID)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringKubemqGo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KubemqClient is the client API for Kubemq service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KubemqClient interface {
	SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error)
	SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error)
	SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error)
	SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error)
	SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error)
	SendQueueMessage(ctx context.Context, in *QueueMessage, opts ...grpc.CallOption) (*SendQueueMessageResult, error)
	SendQueueMessagesBatch(ctx context.Context, in *QueueMessagesBatchRequest, opts ...grpc.CallOption) (*QueueMessagesBatchResponse, error)
	ReceiveQueueMessages(ctx context.Context, in *ReceiveQueueMessagesRequest, opts ...grpc.CallOption) (*ReceiveQueueMessagesResponse, error)
	StreamQueueMessage(ctx context.Context, opts ...grpc.CallOption) (Kubemq_StreamQueueMessageClient, error)
	AckAllQueueMessages(ctx context.Context, in *AckAllQueueMessagesRequest, opts ...grpc.CallOption) (*AckAllQueueMessagesResponse, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResult, error)
	QueuesDownstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesDownstreamClient, error)
	QueuesUpstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesUpstreamClient, error)
	QueuesInfo(ctx context.Context, in *QueuesInfoRequest, opts ...grpc.CallOption) (*QueuesInfoResponse, error)
}

type kubemqClient struct {
	cc *grpc.ClientConn
}

func NewKubemqClient(cc *grpc.ClientConn) KubemqClient {
	return &kubemqClient{cc}
}

func (c *kubemqClient) SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[0], "/kubemq.kubemq/SendEventsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSendEventsStreamClient{stream}
	return x, nil
}

type Kubemq_SendEventsStreamClient interface {
	Send(*Event) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type kubemqSendEventsStreamClient struct {
	grpc.ClientStream
}

func (x *kubemqSendEventsStreamClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[1], "/kubemq.kubemq/SubscribeToEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToEventsClient interface {
	Recv() (*EventReceive, error)
	grpc.ClientStream
}

type kubemqSubscribeToEventsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToEventsClient) Recv() (*EventReceive, error) {
	m := new(EventReceive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[2], "/kubemq.kubemq/SubscribeToRequests", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToRequestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToRequestsClient interface {
	Recv() (*Request, error)
	grpc.ClientStream
}

type kubemqSubscribeToRequestsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToRequestsClient) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendQueueMessage(ctx context.Context, in *QueueMessage, opts ...grpc.CallOption) (*SendQueueMessageResult, error) {
	out := new(SendQueueMessageResult)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendQueueMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendQueueMessagesBatch(ctx context.Context, in *QueueMessagesBatchRequest, opts ...grpc.CallOption) (*QueueMessagesBatchResponse, error) {
	out := new(QueueMessagesBatchResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendQueueMessagesBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) ReceiveQueueMessages(ctx context.Context, in *ReceiveQueueMessagesRequest, opts ...grpc.CallOption) (*ReceiveQueueMessagesResponse, error) {
	out := new(ReceiveQueueMessagesResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/ReceiveQueueMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) StreamQueueMessage(ctx context.Context, opts ...grpc.CallOption) (Kubemq_StreamQueueMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[3], "/kubemq.kubemq/StreamQueueMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqStreamQueueMessageClient{stream}
	return x, nil
}

type Kubemq_StreamQueueMessageClient interface {
	Send(*StreamQueueMessagesRequest) error
	Recv() (*StreamQueueMessagesResponse, error)
	grpc.ClientStream
}

type kubemqStreamQueueMessageClient struct {
	grpc.ClientStream
}

func (x *kubemqStreamQueueMessageClient) Send(m *StreamQueueMessagesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqStreamQueueMessageClient) Recv() (*StreamQueueMessagesResponse, error) {
	m := new(StreamQueueMessagesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) AckAllQueueMessages(ctx context.Context, in *AckAllQueueMessagesRequest, opts ...grpc.CallOption) (*AckAllQueueMessagesResponse, error) {
	out := new(AckAllQueueMessagesResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/AckAllQueueMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResult, error) {
	out := new(PingResult)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) QueuesDownstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesDownstreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[4], "/kubemq.kubemq/QueuesDownstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqQueuesDownstreamClient{stream}
	return x, nil
}

type Kubemq_QueuesDownstreamClient interface {
	Send(*QueuesDownstreamRequest) error
	Recv() (*QueuesDownstreamResponse, error)
	grpc.ClientStream
}

type kubemqQueuesDownstreamClient struct {
	grpc.ClientStream
}

func (x *kubemqQueuesDownstreamClient) Send(m *QueuesDownstreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqQueuesDownstreamClient) Recv() (*QueuesDownstreamResponse, error) {
	m := new(QueuesDownstreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) QueuesUpstream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_QueuesUpstreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[5], "/kubemq.kubemq/QueuesUpstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqQueuesUpstreamClient{stream}
	return x, nil
}

type Kubemq_QueuesUpstreamClient interface {
	Send(*QueuesUpstreamRequest) error
	Recv() (*QueuesUpstreamResponse, error)
	grpc.ClientStream
}

type kubemqQueuesUpstreamClient struct {
	grpc.ClientStream
}

func (x *kubemqQueuesUpstreamClient) Send(m *QueuesUpstreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqQueuesUpstreamClient) Recv() (*QueuesUpstreamResponse, error) {
	m := new(QueuesUpstreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) QueuesInfo(ctx context.Context, in *QueuesInfoRequest, opts ...grpc.CallOption) (*QueuesInfoResponse, error) {
	out := new(QueuesInfoResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/QueuesInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KubemqServer is the server API for Kubemq service.
type KubemqServer interface {
	SendEvent(context.Context, *Event) (*Result, error)
	SendEventsStream(Kubemq_SendEventsStreamServer) error
	SubscribeToEvents(*Subscribe, Kubemq_SubscribeToEventsServer) error
	SubscribeToRequests(*Subscribe, Kubemq_SubscribeToRequestsServer) error
	SendRequest(context.Context, *Request) (*Response, error)
	SendResponse(context.Context, *Response) (*Empty, error)
	SendQueueMessage(context.Context, *QueueMessage) (*SendQueueMessageResult, error)
	SendQueueMessagesBatch(context.Context, *QueueMessagesBatchRequest) (*QueueMessagesBatchResponse, error)
	ReceiveQueueMessages(context.Context, *ReceiveQueueMessagesRequest) (*ReceiveQueueMessagesResponse, error)
	StreamQueueMessage(Kubemq_StreamQueueMessageServer) error
	AckAllQueueMessages(context.Context, *AckAllQueueMessagesRequest) (*AckAllQueueMessagesResponse, error)
	Ping(context.Context, *Empty) (*PingResult, error)
	QueuesDownstream(Kubemq_QueuesDownstreamServer) error
	QueuesUpstream(Kubemq_QueuesUpstreamServer) error
	QueuesInfo(context.Context, *QueuesInfoRequest) (*QueuesInfoResponse, error)
}

func RegisterKubemqServer(s *grpc.Server, srv KubemqServer) {
	s.RegisterService(&_Kubemq_serviceDesc, srv)
}

func _Kubemq_SendEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendEventsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).SendEventsStream(&kubemqSendEventsStreamServer{stream})
}

type Kubemq_SendEventsStreamServer interface {
	Send(*Result) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type kubemqSendEventsStreamServer struct {
	grpc.ServerStream
}

func (x *kubemqSendEventsStreamServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToEvents(m, &kubemqSubscribeToEventsServer{stream})
}

type Kubemq_SubscribeToEventsServer interface {
	Send(*EventReceive) error
	grpc.ServerStream
}

type kubemqSubscribeToEventsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToEventsServer) Send(m *EventReceive) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SubscribeToRequests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToRequests(m, &kubemqSubscribeToRequestsServer{stream})
}

type Kubemq_SubscribeToRequestsServer interface {
	Send(*Request) error
	grpc.ServerStream
}

type kubemqSubscribeToRequestsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToRequestsServer) Send(m *Request) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendRequest(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendResponse(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendQueueMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendQueueMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendQueueMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendQueueMessage(ctx, req.(*QueueMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendQueueMessagesBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueMessagesBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendQueueMessagesBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendQueueMessagesBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendQueueMessagesBatch(ctx, req.(*QueueMessagesBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_ReceiveQueueMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveQueueMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).ReceiveQueueMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/ReceiveQueueMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).ReceiveQueueMessages(ctx, req.(*ReceiveQueueMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_StreamQueueMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).StreamQueueMessage(&kubemqStreamQueueMessageServer{stream})
}

type Kubemq_StreamQueueMessageServer interface {
	Send(*StreamQueueMessagesResponse) error
	Recv() (*StreamQueueMessagesRequest, error)
	grpc.ServerStream
}

type kubemqStreamQueueMessageServer struct {
	grpc.ServerStream
}

func (x *kubemqStreamQueueMessageServer) Send(m *StreamQueueMessagesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqStreamQueueMessageServer) Recv() (*StreamQueueMessagesRequest, error) {
	m := new(StreamQueueMessagesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_AckAllQueueMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckAllQueueMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).AckAllQueueMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/AckAllQueueMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).AckAllQueueMessages(ctx, req.(*AckAllQueueMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_QueuesDownstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).QueuesDownstream(&kubemqQueuesDownstreamServer{stream})
}

type Kubemq_QueuesDownstreamServer interface {
	Send(*QueuesDownstreamResponse) error
	Recv() (*QueuesDownstreamRequest, error)
	grpc.ServerStream
}

type kubemqQueuesDownstreamServer struct {
	grpc.ServerStream
}

func (x *kubemqQueuesDownstreamServer) Send(m *QueuesDownstreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqQueuesDownstreamServer) Recv() (*QueuesDownstreamRequest, error) {
	m := new(QueuesDownstreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_QueuesUpstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).QueuesUpstream(&kubemqQueuesUpstreamServer{stream})
}

type Kubemq_QueuesUpstreamServer interface {
	Send(*QueuesUpstreamResponse) error
	Recv() (*QueuesUpstreamRequest, error)
	grpc.ServerStream
}

type kubemqQueuesUpstreamServer struct {
	grpc.ServerStream
}

func (x *kubemqQueuesUpstreamServer) Send(m *QueuesUpstreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqQueuesUpstreamServer) Recv() (*QueuesUpstreamRequest, error) {
	m := new(QueuesUpstreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_QueuesInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueuesInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).QueuesInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/QueuesInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).QueuesInfo(ctx, req.(*QueuesInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Kubemq_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kubemq.kubemq",
	HandlerType: (*KubemqServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEvent",
			Handler:    _Kubemq_SendEvent_Handler,
		},
		{
			MethodName: "SendRequest",
			Handler:    _Kubemq_SendRequest_Handler,
		},
		{
			MethodName: "SendResponse",
			Handler:    _Kubemq_SendResponse_Handler,
		},
		{
			MethodName: "SendQueueMessage",
			Handler:    _Kubemq_SendQueueMessage_Handler,
		},
		{
			MethodName: "SendQueueMessagesBatch",
			Handler:    _Kubemq_SendQueueMessagesBatch_Handler,
		},
		{
			MethodName: "ReceiveQueueMessages",
			Handler:    _Kubemq_ReceiveQueueMessages_Handler,
		},
		{
			MethodName: "AckAllQueueMessages",
			Handler:    _Kubemq_AckAllQueueMessages_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Kubemq_Ping_Handler,
		},
		{
			MethodName: "QueuesInfo",
			Handler:    _Kubemq_QueuesInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendEventsStream",
			Handler:       _Kubemq_SendEventsStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _Kubemq_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToRequests",
			Handler:       _Kubemq_SubscribeToRequests_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamQueueMessage",
			Handler:       _Kubemq_StreamQueueMessage_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "QueuesDownstream",
			Handler:       _Kubemq_QueuesDownstream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "QueuesUpstream",
			Handler:       _Kubemq_QueuesUpstream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "kubemq_go.proto",
}

func (m *PingResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ServerStartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ServerStartTime))
	}
	if m.ServerUpTimeSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ServerUpTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if m.Sent {
		dAtA[i] = 0x10
		i++
		if m.Sent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Store {
		dAtA[i] = 0x30
		i++
		if m.Store {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x3a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EventReceive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReceive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sequence))
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x3a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Subscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscribe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscribeTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.EventsStoreTypeData != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeValue))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timeout))
	}
	if len(m.CacheKey) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.CacheKey)))
		i += copy(dAtA[i:], m.CacheKey)
	}
	if m.CacheTTL != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.CacheTTL))
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x62
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.RequestID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.CacheHit {
		dAtA[i] = 0x30
		i++
		if m.CacheHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Executed {
		dAtA[i] = 0x40
		i++
		if m.Executed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x5a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MessageID)))
		i += copy(dAtA[i:], m.MessageID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x32
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Attributes != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Attributes.Size()))
		n1, err := m.Attributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Policy != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Policy.Size()))
		n2, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Topic) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Partition))
	}
	if len(m.PartitionKey) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.PartitionKey)))
		i += copy(dAtA[i:], m.PartitionKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessagesBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagesBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BatchID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.BatchID)))
		i += copy(dAtA[i:], m.BatchID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessagesBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagesBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BatchID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.BatchID)))
		i += copy(dAtA[i:], m.BatchID)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HaveErrors {
		dAtA[i] = 0x18
		i++
		if m.HaveErrors {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessageAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessageAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sequence))
	}
	if len(m.MD5OfBody) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MD5OfBody)))
		i += copy(dAtA[i:], m.MD5OfBody)
	}
	if m.ReceiveCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ReceiveCount))
	}
	if m.ReRouted {
		dAtA[i] = 0x28
		i++
		if m.ReRouted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ReRoutedFromQueue) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReRoutedFromQueue)))
		i += copy(dAtA[i:], m.ReRoutedFromQueue)
	}
	if m.ExpirationAt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelayedTo))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessagePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagePolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpirationSeconds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationSeconds))
	}
	if m.DelaySeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelaySeconds))
	}
	if m.MaxReceiveCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxReceiveCount))
	}
	if len(m.MaxReceiveQueue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MaxReceiveQueue)))
		i += copy(dAtA[i:], m.MaxReceiveQueue)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendQueueMessageResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendQueueMessageResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MessageID)))
		i += copy(dAtA[i:], m.MessageID)
	}
	if m.SentAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SentAt))
	}
	if m.ExpirationAt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelayedTo))
	}
	if m.IsError {
		dAtA[i] = 0x28
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.RefChannel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefChannel)))
		i += copy(dAtA[i:], m.RefChannel)
	}
	if len(m.RefTopic) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefTopic)))
		i += copy(dAtA[i:], m.RefTopic)
	}
	if m.RefPartition != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RefPartition))
	}
	if len(m.RefHash) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefHash)))
		i += copy(dAtA[i:], m.RefHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReceiveQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.MaxNumberOfMessages != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxNumberOfMessages))
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.IsPeak {
		dAtA[i] = 0x30
		i++
		if m.IsPeak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReceiveQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MessagesReceived != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MessagesReceived))
	}
	if m.MessagesExpired != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MessagesExpired))
	}
	if m.IsPeak {
		dAtA[i] = 0x28
		i++
		if m.IsPeak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsError {
		dAtA[i] = 0x30
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AckAllQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckAllQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AckAllQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckAllQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.AffectedMessages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.AffectedMessages))
	}
	if m.IsError {
		dAtA[i] = 0x18
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if m.StreamRequestTypeData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.StreamRequestTypeData))
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.VisibilitySeconds != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.VisibilitySeconds))
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.RefSequence != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RefSequence))
	}
	if m.ModifiedMessage != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ModifiedMessage.Size()))
		n3, err := m.ModifiedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.StreamRequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.StreamRequestTypeData))
	}
	if m.Message != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Message.Size()))
		n4, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IsError {
		dAtA[i] = 0x20
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesUpstreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesUpstreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesUpstreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesUpstreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefRequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefRequestID)))
		i += copy(dAtA[i:], m.RefRequestID)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsError {
		dAtA[i] = 0x18
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesDownstreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesDownstreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.MaxItems != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxItems))
	}
	if m.WaitTimeout != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeout))
	}
	if m.AutoAck {
		dAtA[i] = 0x38
		i++
		if m.AutoAck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ReQueueChannel) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReQueueChannel)))
		i += copy(dAtA[i:], m.ReQueueChannel)
	}
	if len(m.SequenceRange) > 0 {
		dAtA6 := make([]byte, len(m.SequenceRange)*10)
		var j5 int
		for _, num1 := range m.SequenceRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.RefTransactionId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefTransactionId)))
		i += copy(dAtA[i:], m.RefTransactionId)
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x62
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesDownstreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesDownstreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if len(m.RefRequestId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefRequestId)))
		i += copy(dAtA[i:], m.RefRequestId)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ActiveOffsets) > 0 {
		dAtA8 := make([]byte, len(m.ActiveOffsets)*10)
		var j7 int
		for _, num1 := range m.ActiveOffsets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.IsError {
		dAtA[i] = 0x30
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.TransactionComplete {
		dAtA[i] = 0x40
		i++
		if m.TransactionComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x4a
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Messages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Messages))
	}
	if m.Bytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Bytes))
	}
	if m.FirstSequence != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.FirstSequence))
	}
	if m.LastSequence != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.LastSequence))
	}
	if m.Sent != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sent))
	}
	if m.Delivered != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Delivered))
	}
	if m.Waiting != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Waiting))
	}
	if m.Subscribers != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Subscribers))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalQueue != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.TotalQueue))
	}
	if m.Sent != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sent))
	}
	if m.Delivered != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Delivered))
	}
	if m.Waiting != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Waiting))
	}
	if len(m.Queues) > 0 {
		for _, msg := range m.Queues {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.QueueName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.QueueName)))
		i += copy(dAtA[i:], m.QueueName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueuesInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuesInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefRequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefRequestID)))
		i += copy(dAtA[i:], m.RefRequestID)
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Info.Size()))
		n9, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicsUpstreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicsUpstreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicsUpstreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicsUpstreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefRequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefRequestID)))
		i += copy(dAtA[i:], m.RefRequestID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.TopicResults) > 0 {
		for k, _ := range m.TopicResults {
			dAtA[i] = 0x1a
			i++
			v := m.TopicResults[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovKubemqGo(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + msgSize
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintKubemqGo(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	if m.IsError {
		dAtA[i] = 0x20
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendPartitionResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPartitionResults) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PartitionResults) > 0 {
		for _, msg := range m.PartitionResults {
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendTopicResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTopicResults) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TopicResults) > 0 {
		for k, _ := range m.TopicResults {
			dAtA[i] = 0xa
			i++
			v := m.TopicResults[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovKubemqGo(uint64(msgSize))
			}
			mapSize := 1 + sovKubemqGo(uint64(k)) + msgSize
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintKubemqGo(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicRecordHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicRecordHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Topic) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Partition))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicPartition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicPartition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicsSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicsSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubscriptionRequestType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscriptionRequestType))
	}
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TopicPartitions) > 0 {
		for _, msg := range m.TopicPartitions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GroupID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if len(m.MemberID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MemberID)))
		i += copy(dAtA[i:], m.MemberID)
	}
	if m.IsStatic {
		dAtA[i] = 0x30
		i++
		if m.IsStatic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SubscriptionStrategyType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscriptionStrategyType))
	}
	if m.SubscriptionOffsetType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscriptionOffsetType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicsSubscriptionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicsSubscriptionEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubscriptionID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.SubscriptionID)))
		i += copy(dAtA[i:], m.SubscriptionID)
	}
	if m.SubscriptionEventType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscriptionEventType))
	}
	if len(m.GroupID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if len(m.MemberID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MemberID)))
		i += copy(dAtA[i:], m.MemberID)
	}
	if len(m.Assigned) > 0 {
		for _, msg := range m.Assigned {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ReSyncAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ReSyncAt))
	}
	if m.IsError {
		dAtA[i] = 0x78
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicsDownstreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicsDownstreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.DownstreamRequestType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DownstreamRequestType))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicsDownstreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicsDownstreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransactionID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.TransactionID)))
		i += copy(dAtA[i:], m.TransactionID)
	}
	if len(m.RefRequestID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RefRequestID)))
		i += copy(dAtA[i:], m.RefRequestID)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.IsError {
		dAtA[i] = 0x78
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintKubemqGo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedPingResult(r randyKubemqGo, easy bool) *PingResult {
	this := &PingResult{}
	this.Host = string(randStringKubemqGo(r))
	this.Version = string(randStringKubemqGo(r))
	this.ServerStartTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ServerStartTime *= -1
	}
	this.ServerUpTimeSeconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ServerUpTimeSeconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedEmpty(r randyKubemqGo, easy bool) *Empty {
	this := &Empty{}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 1)
	}
	return this
}

func NewPopulatedResult(r randyKubemqGo, easy bool) *Result {
	this := &Result{}
	this.EventID = string(randStringKubemqGo(r))
	this.Sent = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 4)
	}
	return this
}

func NewPopulatedEvent(r randyKubemqGo, easy bool) *Event {
	this := &Event{}
	this.EventID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v1 := r.Intn(100)
	this.Body = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Store = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v2 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v2; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 8)
	}
	return this
}

func NewPopulatedEventReceive(r randyKubemqGo, easy bool) *EventReceive {
	this := &EventReceive{}
	this.EventID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v3 := r.Intn(100)
	this.Body = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Sequence = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v4; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 8)
	}
	return this
}

func NewPopulatedSubscribe(r randyKubemqGo, easy bool) *Subscribe {
	this := &Subscribe{}
	this.SubscribeTypeData = Subscribe_SubscribeType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Group = string(randStringKubemqGo(r))
	this.EventsStoreTypeData = Subscribe_EventsStoreType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.EventsStoreTypeValue = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EventsStoreTypeValue *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 7)
	}
	return this
}

func NewPopulatedRequest(r randyKubemqGo, easy bool) *Request {
	this := &Request{}
	this.RequestID = string(randStringKubemqGo(r))
	this.RequestTypeData = Request_RequestType([]int32{0, 1, 2}[r.Intn(3)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v5 := r.Intn(100)
	this.Body = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Timeout = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Timeout *= -1
	}
	this.CacheKey = string(randStringKubemqGo(r))
	this.CacheTTL = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CacheTTL *= -1
	}
	v6 := r.Intn(100)
	this.Span = make([]byte, v6)
	for i := 0; i < v6; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v7; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 13)
	}
	return this
}

func NewPopulatedResponse(r randyKubemqGo, easy bool) *Response {
	this := &Response{}
	this.ClientID = string(randStringKubemqGo(r))
	this.RequestID = string(randStringKubemqGo(r))
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v8 := r.Intn(100)
	this.Body = make([]byte, v8)
	for i := 0; i < v8; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.CacheHit = bool(bool(r.Intn(2) == 0))
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Executed = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	v9 := r.Intn(100)
	this.Span = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v10; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 12)
	}
	return this
}

func NewPopulatedQueueMessage(r randyKubemqGo, easy bool) *QueueMessage {
	this := &QueueMessage{}
	this.MessageID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v11 := r.Intn(100)
	this.Body = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v12 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v12; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if r.Intn(10) != 0 {
		this.Attributes = NewPopulatedQueueMessageAttributes(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Policy = NewPopulatedQueueMessagePolicy(r, easy)
	}
	this.Topic = string(randStringKubemqGo(r))
	this.Partition = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Partition *= -1
	}
	this.PartitionKey = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 12)
	}
	return this
}

func NewPopulatedQueueMessagesBatchRequest(r randyKubemqGo, easy bool) *QueueMessagesBatchRequest {
	this := &QueueMessagesBatchRequest{}
	this.BatchID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v13)
		for i := 0; i < v13; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedQueueMessagesBatchResponse(r randyKubemqGo, easy bool) *QueueMessagesBatchResponse {
	this := &QueueMessagesBatchResponse{}
	this.BatchID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.Results = make([]*SendQueueMessageResult, v14)
		for i := 0; i < v14; i++ {
			this.Results[i] = NewPopulatedSendQueueMessageResult(r, easy)
		}
	}
	this.HaveErrors = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 4)
	}
	return this
}

func NewPopulatedQueueMessageAttributes(r randyKubemqGo, easy bool) *QueueMessageAttributes {
	this := &QueueMessageAttributes{}
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Sequence = uint64(uint64(r.Uint32()))
	this.MD5OfBody = string(randStringKubemqGo(r))
	this.ReceiveCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ReceiveCount *= -1
	}
	this.ReRouted = bool(bool(r.Intn(2) == 0))
	this.ReRoutedFromQueue = string(randStringKubemqGo(r))
	this.ExpirationAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ExpirationAt *= -1
	}
	this.DelayedTo = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DelayedTo *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 9)
	}
	return this
}

func NewPopulatedQueueMessagePolicy(r randyKubemqGo, easy bool) *QueueMessagePolicy {
	this := &QueueMessagePolicy{}
	this.ExpirationSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ExpirationSeconds *= -1
	}
	this.DelaySeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DelaySeconds *= -1
	}
	this.MaxReceiveCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxReceiveCount *= -1
	}
	this.MaxReceiveQueue = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedSendQueueMessageResult(r randyKubemqGo, easy bool) *SendQueueMessageResult {
	this := &SendQueueMessageResult{}
	this.MessageID = string(randStringKubemqGo(r))
	this.SentAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentAt *= -1
	}
	this.ExpirationAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ExpirationAt *= -1
	}
	this.DelayedTo = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DelayedTo *= -1
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	this.RefChannel = string(randStringKubemqGo(r))
	this.RefTopic = string(randStringKubemqGo(r))
	this.RefPartition = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RefPartition *= -1
	}
	this.RefHash = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 11)
	}
	return this
}

func NewPopulatedReceiveQueueMessagesRequest(r randyKubemqGo, easy bool) *ReceiveQueueMessagesRequest {
	this := &ReceiveQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.MaxNumberOfMessages = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxNumberOfMessages *= -1
	}
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	this.IsPeak = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 7)
	}
	return this
}

func NewPopulatedReceiveQueueMessagesResponse(r randyKubemqGo, easy bool) *ReceiveQueueMessagesResponse {
	this := &ReceiveQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v15)
		for i := 0; i < v15; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	this.MessagesReceived = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MessagesReceived *= -1
	}
	this.MessagesExpired = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MessagesExpired *= -1
	}
	this.IsPeak = bool(bool(r.Intn(2) == 0))
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 8)
	}
	return this
}

func NewPopulatedAckAllQueueMessagesRequest(r randyKubemqGo, easy bool) *AckAllQueueMessagesRequest {
	this := &AckAllQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedAckAllQueueMessagesResponse(r randyKubemqGo, easy bool) *AckAllQueueMessagesResponse {
	this := &AckAllQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	this.AffectedMessages = uint64(uint64(r.Uint32()))
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedStreamQueueMessagesRequest(r randyKubemqGo, easy bool) *StreamQueueMessagesRequest {
	this := &StreamQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.StreamRequestTypeData = StreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.Channel = string(randStringKubemqGo(r))
	this.VisibilitySeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.VisibilitySeconds *= -1
	}
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	this.RefSequence = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.ModifiedMessage = NewPopulatedQueueMessage(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 9)
	}
	return this
}

func NewPopulatedStreamQueueMessagesResponse(r randyKubemqGo, easy bool) *StreamQueueMessagesResponse {
	this := &StreamQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	this.StreamRequestTypeData = StreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	if r.Intn(10) != 0 {
		this.Message = NewPopulatedQueueMessage(r, easy)
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 6)
	}
	return this
}

func NewPopulatedQueuesUpstreamRequest(r randyKubemqGo, easy bool) *QueuesUpstreamRequest {
	this := &QueuesUpstreamRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v16)
		for i := 0; i < v16; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedQueuesUpstreamResponse(r randyKubemqGo, easy bool) *QueuesUpstreamResponse {
	this := &QueuesUpstreamResponse{}
	this.RefRequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.Results = make([]*SendQueueMessageResult, v17)
		for i := 0; i < v17; i++ {
			this.Results[i] = NewPopulatedSendQueueMessageResult(r, easy)
		}
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedQueuesDownstreamRequest(r randyKubemqGo, easy bool) *QueuesDownstreamRequest {
	this := &QueuesDownstreamRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.RequestTypeData = QueuesDownstreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}[r.Intn(12)])
	this.Channel = string(randStringKubemqGo(r))
	this.MaxItems = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxItems *= -1
	}
	this.WaitTimeout = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeout *= -1
	}
	this.AutoAck = bool(bool(r.Intn(2) == 0))
	this.ReQueueChannel = string(randStringKubemqGo(r))
	v18 := r.Intn(10)
	this.SequenceRange = make([]int64, v18)
	for i := 0; i < v18; i++ {
		this.SequenceRange[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.SequenceRange[i] *= -1
		}
	}
	this.RefTransactionId = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v19 := r.Intn(10)
		this.Metadata = make(map[string]string)
		for i := 0; i < v19; i++ {
			this.Metadata[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 13)
	}
	return this
}

func NewPopulatedQueuesDownstreamResponse(r randyKubemqGo, easy bool) *QueuesDownstreamResponse {
	this := &QueuesDownstreamResponse{}
	this.TransactionId = string(randStringKubemqGo(r))
	this.RefRequestId = string(randStringKubemqGo(r))
	this.RequestTypeData = QueuesDownstreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}[r.Intn(12)])
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v20)
		for i := 0; i < v20; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	v21 := r.Intn(10)
	this.ActiveOffsets = make([]int64, v21)
	for i := 0; i < v21; i++ {
		this.ActiveOffsets[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.ActiveOffsets[i] *= -1
		}
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	this.TransactionComplete = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v22 := r.Intn(10)
		this.Metadata = make(map[string]string)
		for i := 0; i < v22; i++ {
			this.Metadata[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 10)
	}
	return this
}

func NewPopulatedQueueInfo(r randyKubemqGo, easy bool) *QueueInfo {
	this := &QueueInfo{}
	this.Name = string(randStringKubemqGo(r))
	this.Messages = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Messages *= -1
	}
	this.Bytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Bytes *= -1
	}
	this.FirstSequence = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FirstSequence *= -1
	}
	this.LastSequence = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastSequence *= -1
	}
	this.Sent = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Sent *= -1
	}
	this.Delivered = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Delivered *= -1
	}
	this.Waiting = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Waiting *= -1
	}
	this.Subscribers = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Subscribers *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 10)
	}
	return this
}

func NewPopulatedQueuesInfo(r randyKubemqGo, easy bool) *QueuesInfo {
	this := &QueuesInfo{}
	this.TotalQueue = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TotalQueue *= -1
	}
	this.Sent = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Sent *= -1
	}
	this.Delivered = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Delivered *= -1
	}
	this.Waiting = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Waiting *= -1
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(5)
		this.Queues = make([]*QueueInfo, v23)
		for i := 0; i < v23; i++ {
			this.Queues[i] = NewPopulatedQueueInfo(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 6)
	}
	return this
}

func NewPopulatedQueuesInfoRequest(r randyKubemqGo, easy bool) *QueuesInfoRequest {
	this := &QueuesInfoRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.QueueName = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedQueuesInfoResponse(r randyKubemqGo, easy bool) *QueuesInfoResponse {
	this := &QueuesInfoResponse{}
	this.RefRequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		this.Info = NewPopulatedQueuesInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedTopicsUpstreamRequest(r randyKubemqGo, easy bool) *TopicsUpstreamRequest {
	this := &TopicsUpstreamRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.RequestTypeData = TopicsUpstreamRequestType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.ClientID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v24 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v24)
		for i := 0; i < v24; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 5)
	}
	return this
}

func NewPopulatedTopicsUpstreamResponse(r randyKubemqGo, easy bool) *TopicsUpstreamResponse {
	this := &TopicsUpstreamResponse{}
	this.RefRequestID = string(randStringKubemqGo(r))
	this.RequestTypeData = TopicsUpstreamRequestType([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		v25 := r.Intn(10)
		this.TopicResults = make(map[string]*SendTopicResults)
		for i := 0; i < v25; i++ {
			this.TopicResults[randStringKubemqGo(r)] = NewPopulatedSendTopicResults(r, easy)
		}
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 6)
	}
	return this
}

func NewPopulatedSendPartitionResults(r randyKubemqGo, easy bool) *SendPartitionResults {
	this := &SendPartitionResults{}
	if r.Intn(10) != 0 {
		v26 := r.Intn(5)
		this.PartitionResults = make([]*SendQueueMessageResult, v26)
		for i := 0; i < v26; i++ {
			this.PartitionResults[i] = NewPopulatedSendQueueMessageResult(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 2)
	}
	return this
}

func NewPopulatedSendTopicResults(r randyKubemqGo, easy bool) *SendTopicResults {
	this := &SendTopicResults{}
	if r.Intn(10) != 0 {
		v27 := r.Intn(10)
		this.TopicResults = make(map[int32]*SendPartitionResults)
		for i := 0; i < v27; i++ {
			this.TopicResults[int32(r.Int31())] = NewPopulatedSendPartitionResults(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 2)
	}
	return this
}

func NewPopulatedTopicRecordHeader(r randyKubemqGo, easy bool) *TopicRecordHeader {
	this := &TopicRecordHeader{}
	this.Key = string(randStringKubemqGo(r))
	v28 := r.Intn(100)
	this.Value = make([]byte, v28)
	for i := 0; i < v28; i++ {
		this.Value[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedTopicRecord(r randyKubemqGo, easy bool) *TopicRecord {
	this := &TopicRecord{}
	if r.Intn(10) != 0 {
		v29 := r.Intn(5)
		this.Headers = make([]*TopicRecordHeader, v29)
		for i := 0; i < v29; i++ {
			this.Headers[i] = NewPopulatedTopicRecordHeader(r, easy)
		}
	}
	this.Topic = string(randStringKubemqGo(r))
	this.Partition = uint32(r.Uint32())
	this.Timestamp = uint64(uint64(r.Uint32()))
	v30 := r.Intn(100)
	this.Key = make([]byte, v30)
	for i := 0; i < v30; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v31 := r.Intn(100)
	this.Value = make([]byte, v31)
	for i := 0; i < v31; i++ {
		this.Value[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 7)
	}
	return this
}

func NewPopulatedTopicPartition(r randyKubemqGo, easy bool) *TopicPartition {
	this := &TopicPartition{}
	this.Topic = string(randStringKubemqGo(r))
	this.Partition = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 3)
	}
	return this
}

func NewPopulatedTopicsSubscriptionRequest(r randyKubemqGo, easy bool) *TopicsSubscriptionRequest {
	this := &TopicsSubscriptionRequest{}
	this.SubscriptionRequestType = TopicsSubscriptionRequestType([]int32{0, 1, 2}[r.Intn(3)])
	v32 := r.Intn(10)
	this.Topics = make([]string, v32)
	for i := 0; i < v32; i++ {
		this.Topics[i] = string(randStringKubemqGo(r))
	}
	if r.Intn(10) != 0 {
		v33 := r.Intn(5)
		this.TopicPartitions = make([]*TopicPartition, v33)
		for i := 0; i < v33; i++ {
			this.TopicPartitions[i] = NewPopulatedTopicPartition(r, easy)
		}
	}
	this.GroupID = string(randStringKubemqGo(r))
	this.MemberID = string(randStringKubemqGo(r))
	this.IsStatic = bool(bool(r.Intn(2) == 0))
	this.SubscriptionStrategyType = TopicsSubscriptionStrategyType([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.SubscriptionOffsetType = TopicsSubscriptionOffsetType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 9)
	}
	return this
}

func NewPopulatedTopicsSubscriptionEvent(r randyKubemqGo, easy bool) *TopicsSubscriptionEvent {
	this := &TopicsSubscriptionEvent{}
	this.SubscriptionID = string(randStringKubemqGo(r))
	this.SubscriptionEventType = TopicsSubscriptionEventType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.GroupID = string(randStringKubemqGo(r))
	this.MemberID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v34 := r.Intn(5)
		this.Assigned = make([]*TopicPartition, v34)
		for i := 0; i < v34; i++ {
			this.Assigned[i] = NewPopulatedTopicPartition(r, easy)
		}
	}
	this.ReSyncAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ReSyncAt *= -1
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 17)
	}
	return this
}

func NewPopulatedTopicsDownstreamRequest(r randyKubemqGo, easy bool) *TopicsDownstreamRequest {
	this := &TopicsDownstreamRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.DownstreamRequestType = TopicsDownstreamRequestType([]int32{0, 1, 2}[r.Intn(3)])
	v35 := r.Intn(100)
	this.Data = make([]byte, v35)
	for i := 0; i < v35; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 4)
	}
	return this
}

func NewPopulatedTopicsDownstreamResponse(r randyKubemqGo, easy bool) *TopicsDownstreamResponse {
	this := &TopicsDownstreamResponse{}
	this.TransactionID = string(randStringKubemqGo(r))
	this.RefRequestID = string(randStringKubemqGo(r))
	v36 := r.Intn(100)
	this.Data = make([]byte, v36)
	for i := 0; i < v36; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedKubemqGo(r, 17)
	}
	return this
}

type randyKubemqGo interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneKubemqGo(r randyKubemqGo) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringKubemqGo(r randyKubemqGo) string {
	v37 := r.Intn(100)
	tmps := make([]rune, v37)
	for i := 0; i < v37; i++ {
		tmps[i] = randUTF8RuneKubemqGo(r)
	}
	return string(tmps)
}
func randUnrecognizedKubemqGo(r randyKubemqGo, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldKubemqGo(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldKubemqGo(dAtA []byte, r randyKubemqGo, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		v38 := r.Int63()
		if r.Intn(2) == 0 {
			v38 *= -1
		}
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(v38))
	case 1:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateKubemqGo(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *PingResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ServerStartTime != 0 {
		n += 1 + sovKubemqGo(uint64(m.ServerStartTime))
	}
	if m.ServerUpTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.ServerUpTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Sent {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Store {
		n += 2
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventReceive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sequence))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subscribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscribeTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.EventsStoreTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeValue))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timeout))
	}
	l = len(m.CacheKey)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheTTL != 0 {
		n += 1 + sovKubemqGo(uint64(m.CacheTTL))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheHit {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Executed {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.Attributes != nil {
		l = m.Attributes.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovKubemqGo(uint64(m.Partition))
	}
	l = len(m.PartitionKey)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessagesBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessagesBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.HaveErrors {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessageAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sequence))
	}
	l = len(m.MD5OfBody)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ReceiveCount != 0 {
		n += 1 + sovKubemqGo(uint64(m.ReceiveCount))
	}
	if m.ReRouted {
		n += 2
	}
	l = len(m.ReRoutedFromQueue)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ExpirationAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelayedTo))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessagePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationSeconds))
	}
	if m.DelaySeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelaySeconds))
	}
	if m.MaxReceiveCount != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxReceiveCount))
	}
	l = len(m.MaxReceiveQueue)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendQueueMessageResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.SentAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.SentAt))
	}
	if m.ExpirationAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelayedTo))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RefChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RefTopic)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RefPartition != 0 {
		n += 1 + sovKubemqGo(uint64(m.RefPartition))
	}
	l = len(m.RefHash)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReceiveQueueMessagesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.MaxNumberOfMessages != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxNumberOfMessages))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.IsPeak {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReceiveQueueMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.MessagesReceived != 0 {
		n += 1 + sovKubemqGo(uint64(m.MessagesReceived))
	}
	if m.MessagesExpired != 0 {
		n += 1 + sovKubemqGo(uint64(m.MessagesExpired))
	}
	if m.IsPeak {
		n += 2
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AckAllQueueMessagesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AckAllQueueMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.AffectedMessages != 0 {
		n += 1 + sovKubemqGo(uint64(m.AffectedMessages))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamQueueMessagesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.StreamRequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.StreamRequestTypeData))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.VisibilitySeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.VisibilitySeconds))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.RefSequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.RefSequence))
	}
	if m.ModifiedMessage != nil {
		l = m.ModifiedMessage.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamQueueMessagesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.StreamRequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.StreamRequestTypeData))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesUpstreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesUpstreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RefRequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesDownstreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.MaxItems != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxItems))
	}
	if m.WaitTimeout != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeout))
	}
	if m.AutoAck {
		n += 2
	}
	l = len(m.ReQueueChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.SequenceRange) > 0 {
		l = 0
		for _, e := range m.SequenceRange {
			l += sovKubemqGo(uint64(e))
		}
		n += 1 + sovKubemqGo(uint64(l)) + l
	}
	l = len(m.RefTransactionId)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesDownstreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RefRequestId)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if len(m.ActiveOffsets) > 0 {
		l = 0
		for _, e := range m.ActiveOffsets {
			l += sovKubemqGo(uint64(e))
		}
		n += 1 + sovKubemqGo(uint64(l)) + l
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.TransactionComplete {
		n += 2
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Messages != 0 {
		n += 1 + sovKubemqGo(uint64(m.Messages))
	}
	if m.Bytes != 0 {
		n += 1 + sovKubemqGo(uint64(m.Bytes))
	}
	if m.FirstSequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.FirstSequence))
	}
	if m.LastSequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.LastSequence))
	}
	if m.Sent != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sent))
	}
	if m.Delivered != 0 {
		n += 1 + sovKubemqGo(uint64(m.Delivered))
	}
	if m.Waiting != 0 {
		n += 1 + sovKubemqGo(uint64(m.Waiting))
	}
	if m.Subscribers != 0 {
		n += 1 + sovKubemqGo(uint64(m.Subscribers))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalQueue != 0 {
		n += 1 + sovKubemqGo(uint64(m.TotalQueue))
	}
	if m.Sent != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sent))
	}
	if m.Delivered != 0 {
		n += 1 + sovKubemqGo(uint64(m.Delivered))
	}
	if m.Waiting != 0 {
		n += 1 + sovKubemqGo(uint64(m.Waiting))
	}
	if len(m.Queues) > 0 {
		for _, e := range m.Queues {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.QueueName)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueuesInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RefRequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicsUpstreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicsUpstreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RefRequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	if len(m.TopicResults) > 0 {
		for k, v := range m.TopicResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovKubemqGo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendPartitionResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionResults) > 0 {
		for _, e := range m.PartitionResults {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendTopicResults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TopicResults) > 0 {
		for k, v := range m.TopicResults {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovKubemqGo(uint64(l))
			}
			mapEntrySize := 1 + sovKubemqGo(uint64(k)) + l
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicRecordHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovKubemqGo(uint64(m.Partition))
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicPartition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovKubemqGo(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicsSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubscriptionRequestType != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscriptionRequestType))
	}
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			l = len(s)
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if len(m.TopicPartitions) > 0 {
		for _, e := range m.TopicPartitions {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.MemberID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.IsStatic {
		n += 2
	}
	if m.SubscriptionStrategyType != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscriptionStrategyType))
	}
	if m.SubscriptionOffsetType != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscriptionOffsetType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicsSubscriptionEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.SubscriptionEventType != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscriptionEventType))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.MemberID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Assigned) > 0 {
		for _, e := range m.Assigned {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.ReSyncAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.ReSyncAt))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicsDownstreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.DownstreamRequestType != 0 {
		n += 1 + sovKubemqGo(uint64(m.DownstreamRequestType))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicsDownstreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RefRequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovKubemqGo(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovKubemqGo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKubemqGo(x uint64) (n int) {
	return sovKubemqGo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *PingResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PingResult{`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`ServerStartTime:` + fmt.Sprintf("%v", this.ServerStartTime) + `,`,
		`ServerUpTimeSeconds:` + fmt.Sprintf("%v", this.ServerUpTimeSeconds) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Result{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Sent:` + fmt.Sprintf("%v", this.Sent) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Event{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Store:` + fmt.Sprintf("%v", this.Store) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventReceive) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&EventReceive{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Sequence:` + fmt.Sprintf("%v", this.Sequence) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Subscribe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Subscribe{`,
		`SubscribeTypeData:` + fmt.Sprintf("%v", this.SubscribeTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`EventsStoreTypeData:` + fmt.Sprintf("%v", this.EventsStoreTypeData) + `,`,
		`EventsStoreTypeValue:` + fmt.Sprintf("%v", this.EventsStoreTypeValue) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Request{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`CacheKey:` + fmt.Sprintf("%v", this.CacheKey) + `,`,
		`CacheTTL:` + fmt.Sprintf("%v", this.CacheTTL) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Response{`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`CacheHit:` + fmt.Sprintf("%v", this.CacheHit) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Executed:` + fmt.Sprintf("%v", this.Executed) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessage) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&QueueMessage{`,
		`MessageID:` + fmt.Sprintf("%v", this.MessageID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Attributes:` + strings.Replace(fmt.Sprintf("%v", this.Attributes), "QueueMessageAttributes", "QueueMessageAttributes", 1) + `,`,
		`Policy:` + strings.Replace(fmt.Sprintf("%v", this.Policy), "QueueMessagePolicy", "QueueMessagePolicy", 1) + `,`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`PartitionKey:` + fmt.Sprintf("%v", this.PartitionKey) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagesBatchRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagesBatchRequest{`,
		`BatchID:` + fmt.Sprintf("%v", this.BatchID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagesBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagesBatchResponse{`,
		`BatchID:` + fmt.Sprintf("%v", this.BatchID) + `,`,
		`Results:` + strings.Replace(fmt.Sprintf("%v", this.Results), "SendQueueMessageResult", "SendQueueMessageResult", 1) + `,`,
		`HaveErrors:` + fmt.Sprintf("%v", this.HaveErrors) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessageAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessageAttributes{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Sequence:` + fmt.Sprintf("%v", this.Sequence) + `,`,
		`MD5OfBody:` + fmt.Sprintf("%v", this.MD5OfBody) + `,`,
		`ReceiveCount:` + fmt.Sprintf("%v", this.ReceiveCount) + `,`,
		`ReRouted:` + fmt.Sprintf("%v", this.ReRouted) + `,`,
		`ReRoutedFromQueue:` + fmt.Sprintf("%v", this.ReRoutedFromQueue) + `,`,
		`ExpirationAt:` + fmt.Sprintf("%v", this.ExpirationAt) + `,`,
		`DelayedTo:` + fmt.Sprintf("%v", this.DelayedTo) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagePolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagePolicy{`,
		`ExpirationSeconds:` + fmt.Sprintf("%v", this.ExpirationSeconds) + `,`,
		`DelaySeconds:` + fmt.Sprintf("%v", this.DelaySeconds) + `,`,
		`MaxReceiveCount:` + fmt.Sprintf("%v", this.MaxReceiveCount) + `,`,
		`MaxReceiveQueue:` + fmt.Sprintf("%v", this.MaxReceiveQueue) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendQueueMessageResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendQueueMessageResult{`,
		`MessageID:` + fmt.Sprintf("%v", this.MessageID) + `,`,
		`SentAt:` + fmt.Sprintf("%v", this.SentAt) + `,`,
		`ExpirationAt:` + fmt.Sprintf("%v", this.ExpirationAt) + `,`,
		`DelayedTo:` + fmt.Sprintf("%v", this.DelayedTo) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`RefChannel:` + fmt.Sprintf("%v", this.RefChannel) + `,`,
		`RefTopic:` + fmt.Sprintf("%v", this.RefTopic) + `,`,
		`RefPartition:` + fmt.Sprintf("%v", this.RefPartition) + `,`,
		`RefHash:` + fmt.Sprintf("%v", this.RefHash) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReceiveQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReceiveQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`MaxNumberOfMessages:` + fmt.Sprintf("%v", this.MaxNumberOfMessages) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`IsPeak:` + fmt.Sprintf("%v", this.IsPeak) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReceiveQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReceiveQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`MessagesReceived:` + fmt.Sprintf("%v", this.MessagesReceived) + `,`,
		`MessagesExpired:` + fmt.Sprintf("%v", this.MessagesExpired) + `,`,
		`IsPeak:` + fmt.Sprintf("%v", this.IsPeak) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AckAllQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AckAllQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AckAllQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AckAllQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`AffectedMessages:` + fmt.Sprintf("%v", this.AffectedMessages) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`StreamRequestTypeData:` + fmt.Sprintf("%v", this.StreamRequestTypeData) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`VisibilitySeconds:` + fmt.Sprintf("%v", this.VisibilitySeconds) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`RefSequence:` + fmt.Sprintf("%v", this.RefSequence) + `,`,
		`ModifiedMessage:` + strings.Replace(fmt.Sprintf("%v", this.ModifiedMessage), "QueueMessage", "QueueMessage", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`StreamRequestTypeData:` + fmt.Sprintf("%v", this.StreamRequestTypeData) + `,`,
		`Message:` + strings.Replace(fmt.Sprintf("%v", this.Message), "QueueMessage", "QueueMessage", 1) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesUpstreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueuesUpstreamRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesUpstreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueuesUpstreamResponse{`,
		`RefRequestID:` + fmt.Sprintf("%v", this.RefRequestID) + `,`,
		`Results:` + strings.Replace(fmt.Sprintf("%v", this.Results), "SendQueueMessageResult", "SendQueueMessageResult", 1) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesDownstreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%v: %v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	s := strings.Join([]string{`&QueuesDownstreamRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`MaxItems:` + fmt.Sprintf("%v", this.MaxItems) + `,`,
		`WaitTimeout:` + fmt.Sprintf("%v", this.WaitTimeout) + `,`,
		`AutoAck:` + fmt.Sprintf("%v", this.AutoAck) + `,`,
		`ReQueueChannel:` + fmt.Sprintf("%v", this.ReQueueChannel) + `,`,
		`SequenceRange:` + fmt.Sprintf("%v", this.SequenceRange) + `,`,
		`RefTransactionId:` + fmt.Sprintf("%v", this.RefTransactionId) + `,`,
		`Metadata:` + mapStringForMetadata + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesDownstreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%v: %v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	s := strings.Join([]string{`&QueuesDownstreamResponse{`,
		`TransactionId:` + fmt.Sprintf("%v", this.TransactionId) + `,`,
		`RefRequestId:` + fmt.Sprintf("%v", this.RefRequestId) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`ActiveOffsets:` + fmt.Sprintf("%v", this.ActiveOffsets) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`TransactionComplete:` + fmt.Sprintf("%v", this.TransactionComplete) + `,`,
		`Metadata:` + mapStringForMetadata + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Messages:` + fmt.Sprintf("%v", this.Messages) + `,`,
		`Bytes:` + fmt.Sprintf("%v", this.Bytes) + `,`,
		`FirstSequence:` + fmt.Sprintf("%v", this.FirstSequence) + `,`,
		`LastSequence:` + fmt.Sprintf("%v", this.LastSequence) + `,`,
		`Sent:` + fmt.Sprintf("%v", this.Sent) + `,`,
		`Delivered:` + fmt.Sprintf("%v", this.Delivered) + `,`,
		`Waiting:` + fmt.Sprintf("%v", this.Waiting) + `,`,
		`Subscribers:` + fmt.Sprintf("%v", this.Subscribers) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueuesInfo{`,
		`TotalQueue:` + fmt.Sprintf("%v", this.TotalQueue) + `,`,
		`Sent:` + fmt.Sprintf("%v", this.Sent) + `,`,
		`Delivered:` + fmt.Sprintf("%v", this.Delivered) + `,`,
		`Waiting:` + fmt.Sprintf("%v", this.Waiting) + `,`,
		`Queues:` + strings.Replace(fmt.Sprintf("%v", this.Queues), "QueueInfo", "QueueInfo", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueuesInfoRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`QueueName:` + fmt.Sprintf("%v", this.QueueName) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueuesInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueuesInfoResponse{`,
		`RefRequestID:` + fmt.Sprintf("%v", this.RefRequestID) + `,`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "QueuesInfo", "QueuesInfo", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicsUpstreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicsUpstreamRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicsUpstreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForTopicResults := make([]string, 0, len(this.TopicResults))
	for k, _ := range this.TopicResults {
		keysForTopicResults = append(keysForTopicResults, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTopicResults)
	mapStringForTopicResults := "map[string]*SendTopicResults{"
	for _, k := range keysForTopicResults {
		mapStringForTopicResults += fmt.Sprintf("%v: %v,", k, this.TopicResults[k])
	}
	mapStringForTopicResults += "}"
	s := strings.Join([]string{`&TopicsUpstreamResponse{`,
		`RefRequestID:` + fmt.Sprintf("%v", this.RefRequestID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`TopicResults:` + mapStringForTopicResults + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPartitionResults) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPartitionResults{`,
		`PartitionResults:` + strings.Replace(fmt.Sprintf("%v", this.PartitionResults), "SendQueueMessageResult", "SendQueueMessageResult", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendTopicResults) String() string {
	if this == nil {
		return "nil"
	}
	keysForTopicResults := make([]int32, 0, len(this.TopicResults))
	for k, _ := range this.TopicResults {
		keysForTopicResults = append(keysForTopicResults, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForTopicResults)
	mapStringForTopicResults := "map[int32]*SendPartitionResults{"
	for _, k := range keysForTopicResults {
		mapStringForTopicResults += fmt.Sprintf("%v: %v,", k, this.TopicResults[k])
	}
	mapStringForTopicResults += "}"
	s := strings.Join([]string{`&SendTopicResults{`,
		`TopicResults:` + mapStringForTopicResults + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicRecordHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicRecordHeader{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicRecord) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicRecord{`,
		`Headers:` + strings.Replace(fmt.Sprintf("%v", this.Headers), "TopicRecordHeader", "TopicRecordHeader", 1) + `,`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicPartition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicPartition{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicsSubscriptionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicsSubscriptionRequest{`,
		`SubscriptionRequestType:` + fmt.Sprintf("%v", this.SubscriptionRequestType) + `,`,
		`Topics:` + fmt.Sprintf("%v", this.Topics) + `,`,
		`TopicPartitions:` + strings.Replace(fmt.Sprintf("%v", this.TopicPartitions), "TopicPartition", "TopicPartition", 1) + `,`,
		`GroupID:` + fmt.Sprintf("%v", this.GroupID) + `,`,
		`MemberID:` + fmt.Sprintf("%v", this.MemberID) + `,`,
		`IsStatic:` + fmt.Sprintf("%v", this.IsStatic) + `,`,
		`SubscriptionStrategyType:` + fmt.Sprintf("%v", this.SubscriptionStrategyType) + `,`,
		`SubscriptionOffsetType:` + fmt.Sprintf("%v", this.SubscriptionOffsetType) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicsSubscriptionEvent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicsSubscriptionEvent{`,
		`SubscriptionID:` + fmt.Sprintf("%v", this.SubscriptionID) + `,`,
		`SubscriptionEventType:` + fmt.Sprintf("%v", this.SubscriptionEventType) + `,`,
		`GroupID:` + fmt.Sprintf("%v", this.GroupID) + `,`,
		`MemberID:` + fmt.Sprintf("%v", this.MemberID) + `,`,
		`Assigned:` + strings.Replace(fmt.Sprintf("%v", this.Assigned), "TopicPartition", "TopicPartition", 1) + `,`,
		`ReSyncAt:` + fmt.Sprintf("%v", this.ReSyncAt) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicsDownstreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicsDownstreamRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`DownstreamRequestType:` + fmt.Sprintf("%v", this.DownstreamRequestType) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicsDownstreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicsDownstreamResponse{`,
		`TransactionID:` + fmt.Sprintf("%v", this.TransactionID) + `,`,
		`RefRequestID:` + fmt.Sprintf("%v", this.RefRequestID) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringKubemqGo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *PingResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStartTime", wireType)
			}
			m.ServerStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUpTimeSeconds", wireType)
			}
			m.ServerUpTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerUpTimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sent = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Store = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReceive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReceive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReceive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscribeTypeData", wireType)
			}
			m.SubscribeTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscribeTypeData |= Subscribe_SubscribeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeData", wireType)
			}
			m.EventsStoreTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeData |= Subscribe_EventsStoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeValue", wireType)
			}
			m.EventsStoreTypeValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= Request_RequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTTL", wireType)
			}
			m.CacheTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheHit = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Executed = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = &QueueMessageAttributes{}
			}
			if err := m.Attributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &QueueMessagePolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagesBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagesBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagesBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagesBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagesBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagesBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SendQueueMessageResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveErrors", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HaveErrors = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessageAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessageAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessageAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MD5OfBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MD5OfBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveCount", wireType)
			}
			m.ReceiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReRouted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReRouted = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReRoutedFromQueue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReRoutedFromQueue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationAt", wireType)
			}
			m.ExpirationAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedTo", wireType)
			}
			m.DelayedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayedTo |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationSeconds", wireType)
			}
			m.ExpirationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelaySeconds", wireType)
			}
			m.DelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelaySeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReceiveCount", wireType)
			}
			m.MaxReceiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReceiveCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReceiveQueue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxReceiveQueue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendQueueMessageResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendQueueMessageResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendQueueMessageResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentAt", wireType)
			}
			m.SentAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SentAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationAt", wireType)
			}
			m.ExpirationAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedTo", wireType)
			}
			m.DelayedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayedTo |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefTopic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefTopic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefPartition", wireType)
			}
			m.RefPartition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefPartition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumberOfMessages", wireType)
			}
			m.MaxNumberOfMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumberOfMessages |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPeak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPeak = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagesReceived", wireType)
			}
			m.MessagesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessagesReceived |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagesExpired", wireType)
			}
			m.MessagesExpired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessagesExpired |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPeak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPeak = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckAllQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckAllQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckAllQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckAllQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckAllQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckAllQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedMessages", wireType)
			}
			m.AffectedMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedMessages |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRequestTypeData", wireType)
			}
			m.StreamRequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamRequestTypeData |= StreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibilitySeconds", wireType)
			}
			m.VisibilitySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VisibilitySeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefSequence", wireType)
			}
			m.RefSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModifiedMessage == nil {
				m.ModifiedMessage = &QueueMessage{}
			}
			if err := m.ModifiedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRequestTypeData", wireType)
			}
			m.StreamRequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamRequestTypeData |= StreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &QueueMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesUpstreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesUpstreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesUpstreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesUpstreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesUpstreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesUpstreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SendQueueMessageResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesDownstreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesDownstreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesDownstreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= QueuesDownstreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			m.MaxItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItems |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeout", wireType)
			}
			m.WaitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoAck = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReQueueChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReQueueChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SequenceRange = append(m.SequenceRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKubemqGo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthKubemqGo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SequenceRange) == 0 {
					m.SequenceRange = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SequenceRange = append(m.SequenceRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceRange", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefTransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefTransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesDownstreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesDownstreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesDownstreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= QueuesDownstreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActiveOffsets = append(m.ActiveOffsets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKubemqGo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthKubemqGo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActiveOffsets) == 0 {
					m.ActiveOffsets = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActiveOffsets = append(m.ActiveOffsets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveOffsets", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransactionComplete = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			m.Messages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Messages |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSequence", wireType)
			}
			m.FirstSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstSequence |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSequence", wireType)
			}
			m.LastSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSequence |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sent", wireType)
			}
			m.Sent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delivered", wireType)
			}
			m.Delivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delivered |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waiting", wireType)
			}
			m.Waiting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Waiting |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribers", wireType)
			}
			m.Subscribers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subscribers |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQueue", wireType)
			}
			m.TotalQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalQueue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sent", wireType)
			}
			m.Sent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delivered", wireType)
			}
			m.Delivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delivered |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waiting", wireType)
			}
			m.Waiting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Waiting |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, &QueueInfo{})
			if err := m.Queues[len(m.Queues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuesInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuesInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuesInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &QueuesInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicsUpstreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicsUpstreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicsUpstreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= TopicsUpstreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicsUpstreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicsUpstreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicsUpstreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= TopicsUpstreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicResults == nil {
				m.TopicResults = make(map[string]*SendTopicResults)
			}
			var mapkey string
			var mapvalue *SendTopicResults
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SendTopicResults{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TopicResults[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPartitionResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPartitionResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPartitionResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionResults = append(m.PartitionResults, &SendQueueMessageResult{})
			if err := m.PartitionResults[len(m.PartitionResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTopicResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTopicResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTopicResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicResults == nil {
				m.TopicResults = make(map[int32]*SendPartitionResults)
			}
			var mapkey int32
			var mapvalue *SendPartitionResults
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SendPartitionResults{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TopicResults[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicRecordHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicRecordHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicRecordHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &TopicRecordHeader{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicPartition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicPartition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicPartition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicsSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicsSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicsSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionRequestType", wireType)
			}
			m.SubscriptionRequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionRequestType |= TopicsSubscriptionRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicPartitions = append(m.TopicPartitions, &TopicPartition{})
			if err := m.TopicPartitions[len(m.TopicPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStatic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStatic = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionStrategyType", wireType)
			}
			m.SubscriptionStrategyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionStrategyType |= TopicsSubscriptionStrategyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionOffsetType", wireType)
			}
			m.SubscriptionOffsetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionOffsetType |= TopicsSubscriptionOffsetType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicsSubscriptionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicsSubscriptionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicsSubscriptionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionEventType", wireType)
			}
			m.SubscriptionEventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionEventType |= TopicsSubscriptionEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assigned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assigned = append(m.Assigned, &TopicPartition{})
			if err := m.Assigned[len(m.Assigned)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReSyncAt", wireType)
			}
			m.ReSyncAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReSyncAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicsDownstreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicsDownstreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicsDownstreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownstreamRequestType", wireType)
			}
			m.DownstreamRequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownstreamRequestType |= TopicsDownstreamRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicsDownstreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicsDownstreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicsDownstreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKubemqGo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthKubemqGo
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthKubemqGo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKubemqGo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthKubemqGo
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKubemqGo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKubemqGo   = fmt.Errorf("proto: integer overflow")
)
