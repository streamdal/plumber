// Code generated by counterfeiter. DO NOT EDIT.
package kinesisfakes

import (
	"context"
	"sync"

	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/service/kinesis"
	"github.com/aws/aws-sdk-go/service/kinesis/kinesisiface"
)

type FakeKinesisAPI struct {
	AddTagsToStreamStub        func(*kinesis.AddTagsToStreamInput) (*kinesis.AddTagsToStreamOutput, error)
	addTagsToStreamMutex       sync.RWMutex
	addTagsToStreamArgsForCall []struct {
		arg1 *kinesis.AddTagsToStreamInput
	}
	addTagsToStreamReturns struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}
	addTagsToStreamReturnsOnCall map[int]struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}
	AddTagsToStreamRequestStub        func(*kinesis.AddTagsToStreamInput) (*request.Request, *kinesis.AddTagsToStreamOutput)
	addTagsToStreamRequestMutex       sync.RWMutex
	addTagsToStreamRequestArgsForCall []struct {
		arg1 *kinesis.AddTagsToStreamInput
	}
	addTagsToStreamRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.AddTagsToStreamOutput
	}
	addTagsToStreamRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.AddTagsToStreamOutput
	}
	AddTagsToStreamWithContextStub        func(context.Context, *kinesis.AddTagsToStreamInput, ...request.Option) (*kinesis.AddTagsToStreamOutput, error)
	addTagsToStreamWithContextMutex       sync.RWMutex
	addTagsToStreamWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.AddTagsToStreamInput
		arg3 []request.Option
	}
	addTagsToStreamWithContextReturns struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}
	addTagsToStreamWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}
	CreateStreamStub        func(*kinesis.CreateStreamInput) (*kinesis.CreateStreamOutput, error)
	createStreamMutex       sync.RWMutex
	createStreamArgsForCall []struct {
		arg1 *kinesis.CreateStreamInput
	}
	createStreamReturns struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}
	createStreamReturnsOnCall map[int]struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}
	CreateStreamRequestStub        func(*kinesis.CreateStreamInput) (*request.Request, *kinesis.CreateStreamOutput)
	createStreamRequestMutex       sync.RWMutex
	createStreamRequestArgsForCall []struct {
		arg1 *kinesis.CreateStreamInput
	}
	createStreamRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.CreateStreamOutput
	}
	createStreamRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.CreateStreamOutput
	}
	CreateStreamWithContextStub        func(context.Context, *kinesis.CreateStreamInput, ...request.Option) (*kinesis.CreateStreamOutput, error)
	createStreamWithContextMutex       sync.RWMutex
	createStreamWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.CreateStreamInput
		arg3 []request.Option
	}
	createStreamWithContextReturns struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}
	createStreamWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}
	DecreaseStreamRetentionPeriodStub        func(*kinesis.DecreaseStreamRetentionPeriodInput) (*kinesis.DecreaseStreamRetentionPeriodOutput, error)
	decreaseStreamRetentionPeriodMutex       sync.RWMutex
	decreaseStreamRetentionPeriodArgsForCall []struct {
		arg1 *kinesis.DecreaseStreamRetentionPeriodInput
	}
	decreaseStreamRetentionPeriodReturns struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}
	decreaseStreamRetentionPeriodReturnsOnCall map[int]struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}
	DecreaseStreamRetentionPeriodRequestStub        func(*kinesis.DecreaseStreamRetentionPeriodInput) (*request.Request, *kinesis.DecreaseStreamRetentionPeriodOutput)
	decreaseStreamRetentionPeriodRequestMutex       sync.RWMutex
	decreaseStreamRetentionPeriodRequestArgsForCall []struct {
		arg1 *kinesis.DecreaseStreamRetentionPeriodInput
	}
	decreaseStreamRetentionPeriodRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.DecreaseStreamRetentionPeriodOutput
	}
	decreaseStreamRetentionPeriodRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.DecreaseStreamRetentionPeriodOutput
	}
	DecreaseStreamRetentionPeriodWithContextStub        func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...request.Option) (*kinesis.DecreaseStreamRetentionPeriodOutput, error)
	decreaseStreamRetentionPeriodWithContextMutex       sync.RWMutex
	decreaseStreamRetentionPeriodWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DecreaseStreamRetentionPeriodInput
		arg3 []request.Option
	}
	decreaseStreamRetentionPeriodWithContextReturns struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}
	decreaseStreamRetentionPeriodWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}
	DeleteStreamStub        func(*kinesis.DeleteStreamInput) (*kinesis.DeleteStreamOutput, error)
	deleteStreamMutex       sync.RWMutex
	deleteStreamArgsForCall []struct {
		arg1 *kinesis.DeleteStreamInput
	}
	deleteStreamReturns struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}
	deleteStreamReturnsOnCall map[int]struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}
	DeleteStreamRequestStub        func(*kinesis.DeleteStreamInput) (*request.Request, *kinesis.DeleteStreamOutput)
	deleteStreamRequestMutex       sync.RWMutex
	deleteStreamRequestArgsForCall []struct {
		arg1 *kinesis.DeleteStreamInput
	}
	deleteStreamRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.DeleteStreamOutput
	}
	deleteStreamRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.DeleteStreamOutput
	}
	DeleteStreamWithContextStub        func(context.Context, *kinesis.DeleteStreamInput, ...request.Option) (*kinesis.DeleteStreamOutput, error)
	deleteStreamWithContextMutex       sync.RWMutex
	deleteStreamWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DeleteStreamInput
		arg3 []request.Option
	}
	deleteStreamWithContextReturns struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}
	deleteStreamWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}
	DeregisterStreamConsumerStub        func(*kinesis.DeregisterStreamConsumerInput) (*kinesis.DeregisterStreamConsumerOutput, error)
	deregisterStreamConsumerMutex       sync.RWMutex
	deregisterStreamConsumerArgsForCall []struct {
		arg1 *kinesis.DeregisterStreamConsumerInput
	}
	deregisterStreamConsumerReturns struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}
	deregisterStreamConsumerReturnsOnCall map[int]struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}
	DeregisterStreamConsumerRequestStub        func(*kinesis.DeregisterStreamConsumerInput) (*request.Request, *kinesis.DeregisterStreamConsumerOutput)
	deregisterStreamConsumerRequestMutex       sync.RWMutex
	deregisterStreamConsumerRequestArgsForCall []struct {
		arg1 *kinesis.DeregisterStreamConsumerInput
	}
	deregisterStreamConsumerRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.DeregisterStreamConsumerOutput
	}
	deregisterStreamConsumerRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.DeregisterStreamConsumerOutput
	}
	DeregisterStreamConsumerWithContextStub        func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...request.Option) (*kinesis.DeregisterStreamConsumerOutput, error)
	deregisterStreamConsumerWithContextMutex       sync.RWMutex
	deregisterStreamConsumerWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DeregisterStreamConsumerInput
		arg3 []request.Option
	}
	deregisterStreamConsumerWithContextReturns struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}
	deregisterStreamConsumerWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}
	DescribeLimitsStub        func(*kinesis.DescribeLimitsInput) (*kinesis.DescribeLimitsOutput, error)
	describeLimitsMutex       sync.RWMutex
	describeLimitsArgsForCall []struct {
		arg1 *kinesis.DescribeLimitsInput
	}
	describeLimitsReturns struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}
	describeLimitsReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}
	DescribeLimitsRequestStub        func(*kinesis.DescribeLimitsInput) (*request.Request, *kinesis.DescribeLimitsOutput)
	describeLimitsRequestMutex       sync.RWMutex
	describeLimitsRequestArgsForCall []struct {
		arg1 *kinesis.DescribeLimitsInput
	}
	describeLimitsRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.DescribeLimitsOutput
	}
	describeLimitsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.DescribeLimitsOutput
	}
	DescribeLimitsWithContextStub        func(context.Context, *kinesis.DescribeLimitsInput, ...request.Option) (*kinesis.DescribeLimitsOutput, error)
	describeLimitsWithContextMutex       sync.RWMutex
	describeLimitsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DescribeLimitsInput
		arg3 []request.Option
	}
	describeLimitsWithContextReturns struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}
	describeLimitsWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}
	DescribeStreamStub        func(*kinesis.DescribeStreamInput) (*kinesis.DescribeStreamOutput, error)
	describeStreamMutex       sync.RWMutex
	describeStreamArgsForCall []struct {
		arg1 *kinesis.DescribeStreamInput
	}
	describeStreamReturns struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}
	describeStreamReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}
	DescribeStreamConsumerStub        func(*kinesis.DescribeStreamConsumerInput) (*kinesis.DescribeStreamConsumerOutput, error)
	describeStreamConsumerMutex       sync.RWMutex
	describeStreamConsumerArgsForCall []struct {
		arg1 *kinesis.DescribeStreamConsumerInput
	}
	describeStreamConsumerReturns struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}
	describeStreamConsumerReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}
	DescribeStreamConsumerRequestStub        func(*kinesis.DescribeStreamConsumerInput) (*request.Request, *kinesis.DescribeStreamConsumerOutput)
	describeStreamConsumerRequestMutex       sync.RWMutex
	describeStreamConsumerRequestArgsForCall []struct {
		arg1 *kinesis.DescribeStreamConsumerInput
	}
	describeStreamConsumerRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamConsumerOutput
	}
	describeStreamConsumerRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamConsumerOutput
	}
	DescribeStreamConsumerWithContextStub        func(context.Context, *kinesis.DescribeStreamConsumerInput, ...request.Option) (*kinesis.DescribeStreamConsumerOutput, error)
	describeStreamConsumerWithContextMutex       sync.RWMutex
	describeStreamConsumerWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamConsumerInput
		arg3 []request.Option
	}
	describeStreamConsumerWithContextReturns struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}
	describeStreamConsumerWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}
	DescribeStreamPagesStub        func(*kinesis.DescribeStreamInput, func(*kinesis.DescribeStreamOutput, bool) bool) error
	describeStreamPagesMutex       sync.RWMutex
	describeStreamPagesArgsForCall []struct {
		arg1 *kinesis.DescribeStreamInput
		arg2 func(*kinesis.DescribeStreamOutput, bool) bool
	}
	describeStreamPagesReturns struct {
		result1 error
	}
	describeStreamPagesReturnsOnCall map[int]struct {
		result1 error
	}
	DescribeStreamPagesWithContextStub        func(context.Context, *kinesis.DescribeStreamInput, func(*kinesis.DescribeStreamOutput, bool) bool, ...request.Option) error
	describeStreamPagesWithContextMutex       sync.RWMutex
	describeStreamPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 func(*kinesis.DescribeStreamOutput, bool) bool
		arg4 []request.Option
	}
	describeStreamPagesWithContextReturns struct {
		result1 error
	}
	describeStreamPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	DescribeStreamRequestStub        func(*kinesis.DescribeStreamInput) (*request.Request, *kinesis.DescribeStreamOutput)
	describeStreamRequestMutex       sync.RWMutex
	describeStreamRequestArgsForCall []struct {
		arg1 *kinesis.DescribeStreamInput
	}
	describeStreamRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamOutput
	}
	describeStreamRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamOutput
	}
	DescribeStreamSummaryStub        func(*kinesis.DescribeStreamSummaryInput) (*kinesis.DescribeStreamSummaryOutput, error)
	describeStreamSummaryMutex       sync.RWMutex
	describeStreamSummaryArgsForCall []struct {
		arg1 *kinesis.DescribeStreamSummaryInput
	}
	describeStreamSummaryReturns struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}
	describeStreamSummaryReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}
	DescribeStreamSummaryRequestStub        func(*kinesis.DescribeStreamSummaryInput) (*request.Request, *kinesis.DescribeStreamSummaryOutput)
	describeStreamSummaryRequestMutex       sync.RWMutex
	describeStreamSummaryRequestArgsForCall []struct {
		arg1 *kinesis.DescribeStreamSummaryInput
	}
	describeStreamSummaryRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamSummaryOutput
	}
	describeStreamSummaryRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamSummaryOutput
	}
	DescribeStreamSummaryWithContextStub        func(context.Context, *kinesis.DescribeStreamSummaryInput, ...request.Option) (*kinesis.DescribeStreamSummaryOutput, error)
	describeStreamSummaryWithContextMutex       sync.RWMutex
	describeStreamSummaryWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamSummaryInput
		arg3 []request.Option
	}
	describeStreamSummaryWithContextReturns struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}
	describeStreamSummaryWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}
	DescribeStreamWithContextStub        func(context.Context, *kinesis.DescribeStreamInput, ...request.Option) (*kinesis.DescribeStreamOutput, error)
	describeStreamWithContextMutex       sync.RWMutex
	describeStreamWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 []request.Option
	}
	describeStreamWithContextReturns struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}
	describeStreamWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}
	DisableEnhancedMonitoringStub        func(*kinesis.DisableEnhancedMonitoringInput) (*kinesis.EnhancedMonitoringOutput, error)
	disableEnhancedMonitoringMutex       sync.RWMutex
	disableEnhancedMonitoringArgsForCall []struct {
		arg1 *kinesis.DisableEnhancedMonitoringInput
	}
	disableEnhancedMonitoringReturns struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	disableEnhancedMonitoringReturnsOnCall map[int]struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	DisableEnhancedMonitoringRequestStub        func(*kinesis.DisableEnhancedMonitoringInput) (*request.Request, *kinesis.EnhancedMonitoringOutput)
	disableEnhancedMonitoringRequestMutex       sync.RWMutex
	disableEnhancedMonitoringRequestArgsForCall []struct {
		arg1 *kinesis.DisableEnhancedMonitoringInput
	}
	disableEnhancedMonitoringRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}
	disableEnhancedMonitoringRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}
	DisableEnhancedMonitoringWithContextStub        func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...request.Option) (*kinesis.EnhancedMonitoringOutput, error)
	disableEnhancedMonitoringWithContextMutex       sync.RWMutex
	disableEnhancedMonitoringWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DisableEnhancedMonitoringInput
		arg3 []request.Option
	}
	disableEnhancedMonitoringWithContextReturns struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	disableEnhancedMonitoringWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	EnableEnhancedMonitoringStub        func(*kinesis.EnableEnhancedMonitoringInput) (*kinesis.EnhancedMonitoringOutput, error)
	enableEnhancedMonitoringMutex       sync.RWMutex
	enableEnhancedMonitoringArgsForCall []struct {
		arg1 *kinesis.EnableEnhancedMonitoringInput
	}
	enableEnhancedMonitoringReturns struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	enableEnhancedMonitoringReturnsOnCall map[int]struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	EnableEnhancedMonitoringRequestStub        func(*kinesis.EnableEnhancedMonitoringInput) (*request.Request, *kinesis.EnhancedMonitoringOutput)
	enableEnhancedMonitoringRequestMutex       sync.RWMutex
	enableEnhancedMonitoringRequestArgsForCall []struct {
		arg1 *kinesis.EnableEnhancedMonitoringInput
	}
	enableEnhancedMonitoringRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}
	enableEnhancedMonitoringRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}
	EnableEnhancedMonitoringWithContextStub        func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...request.Option) (*kinesis.EnhancedMonitoringOutput, error)
	enableEnhancedMonitoringWithContextMutex       sync.RWMutex
	enableEnhancedMonitoringWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.EnableEnhancedMonitoringInput
		arg3 []request.Option
	}
	enableEnhancedMonitoringWithContextReturns struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	enableEnhancedMonitoringWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}
	GetRecordsStub        func(*kinesis.GetRecordsInput) (*kinesis.GetRecordsOutput, error)
	getRecordsMutex       sync.RWMutex
	getRecordsArgsForCall []struct {
		arg1 *kinesis.GetRecordsInput
	}
	getRecordsReturns struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}
	getRecordsReturnsOnCall map[int]struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}
	GetRecordsRequestStub        func(*kinesis.GetRecordsInput) (*request.Request, *kinesis.GetRecordsOutput)
	getRecordsRequestMutex       sync.RWMutex
	getRecordsRequestArgsForCall []struct {
		arg1 *kinesis.GetRecordsInput
	}
	getRecordsRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.GetRecordsOutput
	}
	getRecordsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.GetRecordsOutput
	}
	GetRecordsWithContextStub        func(context.Context, *kinesis.GetRecordsInput, ...request.Option) (*kinesis.GetRecordsOutput, error)
	getRecordsWithContextMutex       sync.RWMutex
	getRecordsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.GetRecordsInput
		arg3 []request.Option
	}
	getRecordsWithContextReturns struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}
	getRecordsWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}
	GetShardIteratorStub        func(*kinesis.GetShardIteratorInput) (*kinesis.GetShardIteratorOutput, error)
	getShardIteratorMutex       sync.RWMutex
	getShardIteratorArgsForCall []struct {
		arg1 *kinesis.GetShardIteratorInput
	}
	getShardIteratorReturns struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}
	getShardIteratorReturnsOnCall map[int]struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}
	GetShardIteratorRequestStub        func(*kinesis.GetShardIteratorInput) (*request.Request, *kinesis.GetShardIteratorOutput)
	getShardIteratorRequestMutex       sync.RWMutex
	getShardIteratorRequestArgsForCall []struct {
		arg1 *kinesis.GetShardIteratorInput
	}
	getShardIteratorRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.GetShardIteratorOutput
	}
	getShardIteratorRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.GetShardIteratorOutput
	}
	GetShardIteratorWithContextStub        func(context.Context, *kinesis.GetShardIteratorInput, ...request.Option) (*kinesis.GetShardIteratorOutput, error)
	getShardIteratorWithContextMutex       sync.RWMutex
	getShardIteratorWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.GetShardIteratorInput
		arg3 []request.Option
	}
	getShardIteratorWithContextReturns struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}
	getShardIteratorWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}
	IncreaseStreamRetentionPeriodStub        func(*kinesis.IncreaseStreamRetentionPeriodInput) (*kinesis.IncreaseStreamRetentionPeriodOutput, error)
	increaseStreamRetentionPeriodMutex       sync.RWMutex
	increaseStreamRetentionPeriodArgsForCall []struct {
		arg1 *kinesis.IncreaseStreamRetentionPeriodInput
	}
	increaseStreamRetentionPeriodReturns struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}
	increaseStreamRetentionPeriodReturnsOnCall map[int]struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}
	IncreaseStreamRetentionPeriodRequestStub        func(*kinesis.IncreaseStreamRetentionPeriodInput) (*request.Request, *kinesis.IncreaseStreamRetentionPeriodOutput)
	increaseStreamRetentionPeriodRequestMutex       sync.RWMutex
	increaseStreamRetentionPeriodRequestArgsForCall []struct {
		arg1 *kinesis.IncreaseStreamRetentionPeriodInput
	}
	increaseStreamRetentionPeriodRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.IncreaseStreamRetentionPeriodOutput
	}
	increaseStreamRetentionPeriodRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.IncreaseStreamRetentionPeriodOutput
	}
	IncreaseStreamRetentionPeriodWithContextStub        func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...request.Option) (*kinesis.IncreaseStreamRetentionPeriodOutput, error)
	increaseStreamRetentionPeriodWithContextMutex       sync.RWMutex
	increaseStreamRetentionPeriodWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.IncreaseStreamRetentionPeriodInput
		arg3 []request.Option
	}
	increaseStreamRetentionPeriodWithContextReturns struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}
	increaseStreamRetentionPeriodWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}
	ListShardsStub        func(*kinesis.ListShardsInput) (*kinesis.ListShardsOutput, error)
	listShardsMutex       sync.RWMutex
	listShardsArgsForCall []struct {
		arg1 *kinesis.ListShardsInput
	}
	listShardsReturns struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}
	listShardsReturnsOnCall map[int]struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}
	ListShardsRequestStub        func(*kinesis.ListShardsInput) (*request.Request, *kinesis.ListShardsOutput)
	listShardsRequestMutex       sync.RWMutex
	listShardsRequestArgsForCall []struct {
		arg1 *kinesis.ListShardsInput
	}
	listShardsRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.ListShardsOutput
	}
	listShardsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.ListShardsOutput
	}
	ListShardsWithContextStub        func(context.Context, *kinesis.ListShardsInput, ...request.Option) (*kinesis.ListShardsOutput, error)
	listShardsWithContextMutex       sync.RWMutex
	listShardsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.ListShardsInput
		arg3 []request.Option
	}
	listShardsWithContextReturns struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}
	listShardsWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}
	ListStreamConsumersStub        func(*kinesis.ListStreamConsumersInput) (*kinesis.ListStreamConsumersOutput, error)
	listStreamConsumersMutex       sync.RWMutex
	listStreamConsumersArgsForCall []struct {
		arg1 *kinesis.ListStreamConsumersInput
	}
	listStreamConsumersReturns struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}
	listStreamConsumersReturnsOnCall map[int]struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}
	ListStreamConsumersPagesStub        func(*kinesis.ListStreamConsumersInput, func(*kinesis.ListStreamConsumersOutput, bool) bool) error
	listStreamConsumersPagesMutex       sync.RWMutex
	listStreamConsumersPagesArgsForCall []struct {
		arg1 *kinesis.ListStreamConsumersInput
		arg2 func(*kinesis.ListStreamConsumersOutput, bool) bool
	}
	listStreamConsumersPagesReturns struct {
		result1 error
	}
	listStreamConsumersPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListStreamConsumersPagesWithContextStub        func(context.Context, *kinesis.ListStreamConsumersInput, func(*kinesis.ListStreamConsumersOutput, bool) bool, ...request.Option) error
	listStreamConsumersPagesWithContextMutex       sync.RWMutex
	listStreamConsumersPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamConsumersInput
		arg3 func(*kinesis.ListStreamConsumersOutput, bool) bool
		arg4 []request.Option
	}
	listStreamConsumersPagesWithContextReturns struct {
		result1 error
	}
	listStreamConsumersPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListStreamConsumersRequestStub        func(*kinesis.ListStreamConsumersInput) (*request.Request, *kinesis.ListStreamConsumersOutput)
	listStreamConsumersRequestMutex       sync.RWMutex
	listStreamConsumersRequestArgsForCall []struct {
		arg1 *kinesis.ListStreamConsumersInput
	}
	listStreamConsumersRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.ListStreamConsumersOutput
	}
	listStreamConsumersRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.ListStreamConsumersOutput
	}
	ListStreamConsumersWithContextStub        func(context.Context, *kinesis.ListStreamConsumersInput, ...request.Option) (*kinesis.ListStreamConsumersOutput, error)
	listStreamConsumersWithContextMutex       sync.RWMutex
	listStreamConsumersWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamConsumersInput
		arg3 []request.Option
	}
	listStreamConsumersWithContextReturns struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}
	listStreamConsumersWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}
	ListStreamsStub        func(*kinesis.ListStreamsInput) (*kinesis.ListStreamsOutput, error)
	listStreamsMutex       sync.RWMutex
	listStreamsArgsForCall []struct {
		arg1 *kinesis.ListStreamsInput
	}
	listStreamsReturns struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}
	listStreamsReturnsOnCall map[int]struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}
	ListStreamsPagesStub        func(*kinesis.ListStreamsInput, func(*kinesis.ListStreamsOutput, bool) bool) error
	listStreamsPagesMutex       sync.RWMutex
	listStreamsPagesArgsForCall []struct {
		arg1 *kinesis.ListStreamsInput
		arg2 func(*kinesis.ListStreamsOutput, bool) bool
	}
	listStreamsPagesReturns struct {
		result1 error
	}
	listStreamsPagesReturnsOnCall map[int]struct {
		result1 error
	}
	ListStreamsPagesWithContextStub        func(context.Context, *kinesis.ListStreamsInput, func(*kinesis.ListStreamsOutput, bool) bool, ...request.Option) error
	listStreamsPagesWithContextMutex       sync.RWMutex
	listStreamsPagesWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamsInput
		arg3 func(*kinesis.ListStreamsOutput, bool) bool
		arg4 []request.Option
	}
	listStreamsPagesWithContextReturns struct {
		result1 error
	}
	listStreamsPagesWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	ListStreamsRequestStub        func(*kinesis.ListStreamsInput) (*request.Request, *kinesis.ListStreamsOutput)
	listStreamsRequestMutex       sync.RWMutex
	listStreamsRequestArgsForCall []struct {
		arg1 *kinesis.ListStreamsInput
	}
	listStreamsRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.ListStreamsOutput
	}
	listStreamsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.ListStreamsOutput
	}
	ListStreamsWithContextStub        func(context.Context, *kinesis.ListStreamsInput, ...request.Option) (*kinesis.ListStreamsOutput, error)
	listStreamsWithContextMutex       sync.RWMutex
	listStreamsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamsInput
		arg3 []request.Option
	}
	listStreamsWithContextReturns struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}
	listStreamsWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}
	ListTagsForStreamStub        func(*kinesis.ListTagsForStreamInput) (*kinesis.ListTagsForStreamOutput, error)
	listTagsForStreamMutex       sync.RWMutex
	listTagsForStreamArgsForCall []struct {
		arg1 *kinesis.ListTagsForStreamInput
	}
	listTagsForStreamReturns struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}
	listTagsForStreamReturnsOnCall map[int]struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}
	ListTagsForStreamRequestStub        func(*kinesis.ListTagsForStreamInput) (*request.Request, *kinesis.ListTagsForStreamOutput)
	listTagsForStreamRequestMutex       sync.RWMutex
	listTagsForStreamRequestArgsForCall []struct {
		arg1 *kinesis.ListTagsForStreamInput
	}
	listTagsForStreamRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.ListTagsForStreamOutput
	}
	listTagsForStreamRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.ListTagsForStreamOutput
	}
	ListTagsForStreamWithContextStub        func(context.Context, *kinesis.ListTagsForStreamInput, ...request.Option) (*kinesis.ListTagsForStreamOutput, error)
	listTagsForStreamWithContextMutex       sync.RWMutex
	listTagsForStreamWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.ListTagsForStreamInput
		arg3 []request.Option
	}
	listTagsForStreamWithContextReturns struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}
	listTagsForStreamWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}
	MergeShardsStub        func(*kinesis.MergeShardsInput) (*kinesis.MergeShardsOutput, error)
	mergeShardsMutex       sync.RWMutex
	mergeShardsArgsForCall []struct {
		arg1 *kinesis.MergeShardsInput
	}
	mergeShardsReturns struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}
	mergeShardsReturnsOnCall map[int]struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}
	MergeShardsRequestStub        func(*kinesis.MergeShardsInput) (*request.Request, *kinesis.MergeShardsOutput)
	mergeShardsRequestMutex       sync.RWMutex
	mergeShardsRequestArgsForCall []struct {
		arg1 *kinesis.MergeShardsInput
	}
	mergeShardsRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.MergeShardsOutput
	}
	mergeShardsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.MergeShardsOutput
	}
	MergeShardsWithContextStub        func(context.Context, *kinesis.MergeShardsInput, ...request.Option) (*kinesis.MergeShardsOutput, error)
	mergeShardsWithContextMutex       sync.RWMutex
	mergeShardsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.MergeShardsInput
		arg3 []request.Option
	}
	mergeShardsWithContextReturns struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}
	mergeShardsWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}
	PutRecordStub        func(*kinesis.PutRecordInput) (*kinesis.PutRecordOutput, error)
	putRecordMutex       sync.RWMutex
	putRecordArgsForCall []struct {
		arg1 *kinesis.PutRecordInput
	}
	putRecordReturns struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}
	putRecordReturnsOnCall map[int]struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}
	PutRecordRequestStub        func(*kinesis.PutRecordInput) (*request.Request, *kinesis.PutRecordOutput)
	putRecordRequestMutex       sync.RWMutex
	putRecordRequestArgsForCall []struct {
		arg1 *kinesis.PutRecordInput
	}
	putRecordRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.PutRecordOutput
	}
	putRecordRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.PutRecordOutput
	}
	PutRecordWithContextStub        func(context.Context, *kinesis.PutRecordInput, ...request.Option) (*kinesis.PutRecordOutput, error)
	putRecordWithContextMutex       sync.RWMutex
	putRecordWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.PutRecordInput
		arg3 []request.Option
	}
	putRecordWithContextReturns struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}
	putRecordWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}
	PutRecordsStub        func(*kinesis.PutRecordsInput) (*kinesis.PutRecordsOutput, error)
	putRecordsMutex       sync.RWMutex
	putRecordsArgsForCall []struct {
		arg1 *kinesis.PutRecordsInput
	}
	putRecordsReturns struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}
	putRecordsReturnsOnCall map[int]struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}
	PutRecordsRequestStub        func(*kinesis.PutRecordsInput) (*request.Request, *kinesis.PutRecordsOutput)
	putRecordsRequestMutex       sync.RWMutex
	putRecordsRequestArgsForCall []struct {
		arg1 *kinesis.PutRecordsInput
	}
	putRecordsRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.PutRecordsOutput
	}
	putRecordsRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.PutRecordsOutput
	}
	PutRecordsWithContextStub        func(context.Context, *kinesis.PutRecordsInput, ...request.Option) (*kinesis.PutRecordsOutput, error)
	putRecordsWithContextMutex       sync.RWMutex
	putRecordsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.PutRecordsInput
		arg3 []request.Option
	}
	putRecordsWithContextReturns struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}
	putRecordsWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}
	RegisterStreamConsumerStub        func(*kinesis.RegisterStreamConsumerInput) (*kinesis.RegisterStreamConsumerOutput, error)
	registerStreamConsumerMutex       sync.RWMutex
	registerStreamConsumerArgsForCall []struct {
		arg1 *kinesis.RegisterStreamConsumerInput
	}
	registerStreamConsumerReturns struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}
	registerStreamConsumerReturnsOnCall map[int]struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}
	RegisterStreamConsumerRequestStub        func(*kinesis.RegisterStreamConsumerInput) (*request.Request, *kinesis.RegisterStreamConsumerOutput)
	registerStreamConsumerRequestMutex       sync.RWMutex
	registerStreamConsumerRequestArgsForCall []struct {
		arg1 *kinesis.RegisterStreamConsumerInput
	}
	registerStreamConsumerRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.RegisterStreamConsumerOutput
	}
	registerStreamConsumerRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.RegisterStreamConsumerOutput
	}
	RegisterStreamConsumerWithContextStub        func(context.Context, *kinesis.RegisterStreamConsumerInput, ...request.Option) (*kinesis.RegisterStreamConsumerOutput, error)
	registerStreamConsumerWithContextMutex       sync.RWMutex
	registerStreamConsumerWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.RegisterStreamConsumerInput
		arg3 []request.Option
	}
	registerStreamConsumerWithContextReturns struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}
	registerStreamConsumerWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}
	RemoveTagsFromStreamStub        func(*kinesis.RemoveTagsFromStreamInput) (*kinesis.RemoveTagsFromStreamOutput, error)
	removeTagsFromStreamMutex       sync.RWMutex
	removeTagsFromStreamArgsForCall []struct {
		arg1 *kinesis.RemoveTagsFromStreamInput
	}
	removeTagsFromStreamReturns struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}
	removeTagsFromStreamReturnsOnCall map[int]struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}
	RemoveTagsFromStreamRequestStub        func(*kinesis.RemoveTagsFromStreamInput) (*request.Request, *kinesis.RemoveTagsFromStreamOutput)
	removeTagsFromStreamRequestMutex       sync.RWMutex
	removeTagsFromStreamRequestArgsForCall []struct {
		arg1 *kinesis.RemoveTagsFromStreamInput
	}
	removeTagsFromStreamRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.RemoveTagsFromStreamOutput
	}
	removeTagsFromStreamRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.RemoveTagsFromStreamOutput
	}
	RemoveTagsFromStreamWithContextStub        func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...request.Option) (*kinesis.RemoveTagsFromStreamOutput, error)
	removeTagsFromStreamWithContextMutex       sync.RWMutex
	removeTagsFromStreamWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.RemoveTagsFromStreamInput
		arg3 []request.Option
	}
	removeTagsFromStreamWithContextReturns struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}
	removeTagsFromStreamWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}
	SplitShardStub        func(*kinesis.SplitShardInput) (*kinesis.SplitShardOutput, error)
	splitShardMutex       sync.RWMutex
	splitShardArgsForCall []struct {
		arg1 *kinesis.SplitShardInput
	}
	splitShardReturns struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}
	splitShardReturnsOnCall map[int]struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}
	SplitShardRequestStub        func(*kinesis.SplitShardInput) (*request.Request, *kinesis.SplitShardOutput)
	splitShardRequestMutex       sync.RWMutex
	splitShardRequestArgsForCall []struct {
		arg1 *kinesis.SplitShardInput
	}
	splitShardRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.SplitShardOutput
	}
	splitShardRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.SplitShardOutput
	}
	SplitShardWithContextStub        func(context.Context, *kinesis.SplitShardInput, ...request.Option) (*kinesis.SplitShardOutput, error)
	splitShardWithContextMutex       sync.RWMutex
	splitShardWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.SplitShardInput
		arg3 []request.Option
	}
	splitShardWithContextReturns struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}
	splitShardWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}
	StartStreamEncryptionStub        func(*kinesis.StartStreamEncryptionInput) (*kinesis.StartStreamEncryptionOutput, error)
	startStreamEncryptionMutex       sync.RWMutex
	startStreamEncryptionArgsForCall []struct {
		arg1 *kinesis.StartStreamEncryptionInput
	}
	startStreamEncryptionReturns struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}
	startStreamEncryptionReturnsOnCall map[int]struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}
	StartStreamEncryptionRequestStub        func(*kinesis.StartStreamEncryptionInput) (*request.Request, *kinesis.StartStreamEncryptionOutput)
	startStreamEncryptionRequestMutex       sync.RWMutex
	startStreamEncryptionRequestArgsForCall []struct {
		arg1 *kinesis.StartStreamEncryptionInput
	}
	startStreamEncryptionRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.StartStreamEncryptionOutput
	}
	startStreamEncryptionRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.StartStreamEncryptionOutput
	}
	StartStreamEncryptionWithContextStub        func(context.Context, *kinesis.StartStreamEncryptionInput, ...request.Option) (*kinesis.StartStreamEncryptionOutput, error)
	startStreamEncryptionWithContextMutex       sync.RWMutex
	startStreamEncryptionWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.StartStreamEncryptionInput
		arg3 []request.Option
	}
	startStreamEncryptionWithContextReturns struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}
	startStreamEncryptionWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}
	StopStreamEncryptionStub        func(*kinesis.StopStreamEncryptionInput) (*kinesis.StopStreamEncryptionOutput, error)
	stopStreamEncryptionMutex       sync.RWMutex
	stopStreamEncryptionArgsForCall []struct {
		arg1 *kinesis.StopStreamEncryptionInput
	}
	stopStreamEncryptionReturns struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}
	stopStreamEncryptionReturnsOnCall map[int]struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}
	StopStreamEncryptionRequestStub        func(*kinesis.StopStreamEncryptionInput) (*request.Request, *kinesis.StopStreamEncryptionOutput)
	stopStreamEncryptionRequestMutex       sync.RWMutex
	stopStreamEncryptionRequestArgsForCall []struct {
		arg1 *kinesis.StopStreamEncryptionInput
	}
	stopStreamEncryptionRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.StopStreamEncryptionOutput
	}
	stopStreamEncryptionRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.StopStreamEncryptionOutput
	}
	StopStreamEncryptionWithContextStub        func(context.Context, *kinesis.StopStreamEncryptionInput, ...request.Option) (*kinesis.StopStreamEncryptionOutput, error)
	stopStreamEncryptionWithContextMutex       sync.RWMutex
	stopStreamEncryptionWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.StopStreamEncryptionInput
		arg3 []request.Option
	}
	stopStreamEncryptionWithContextReturns struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}
	stopStreamEncryptionWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}
	SubscribeToShardStub        func(*kinesis.SubscribeToShardInput) (*kinesis.SubscribeToShardOutput, error)
	subscribeToShardMutex       sync.RWMutex
	subscribeToShardArgsForCall []struct {
		arg1 *kinesis.SubscribeToShardInput
	}
	subscribeToShardReturns struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}
	subscribeToShardReturnsOnCall map[int]struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}
	SubscribeToShardRequestStub        func(*kinesis.SubscribeToShardInput) (*request.Request, *kinesis.SubscribeToShardOutput)
	subscribeToShardRequestMutex       sync.RWMutex
	subscribeToShardRequestArgsForCall []struct {
		arg1 *kinesis.SubscribeToShardInput
	}
	subscribeToShardRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.SubscribeToShardOutput
	}
	subscribeToShardRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.SubscribeToShardOutput
	}
	SubscribeToShardWithContextStub        func(context.Context, *kinesis.SubscribeToShardInput, ...request.Option) (*kinesis.SubscribeToShardOutput, error)
	subscribeToShardWithContextMutex       sync.RWMutex
	subscribeToShardWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.SubscribeToShardInput
		arg3 []request.Option
	}
	subscribeToShardWithContextReturns struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}
	subscribeToShardWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}
	UpdateShardCountStub        func(*kinesis.UpdateShardCountInput) (*kinesis.UpdateShardCountOutput, error)
	updateShardCountMutex       sync.RWMutex
	updateShardCountArgsForCall []struct {
		arg1 *kinesis.UpdateShardCountInput
	}
	updateShardCountReturns struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}
	updateShardCountReturnsOnCall map[int]struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}
	UpdateShardCountRequestStub        func(*kinesis.UpdateShardCountInput) (*request.Request, *kinesis.UpdateShardCountOutput)
	updateShardCountRequestMutex       sync.RWMutex
	updateShardCountRequestArgsForCall []struct {
		arg1 *kinesis.UpdateShardCountInput
	}
	updateShardCountRequestReturns struct {
		result1 *request.Request
		result2 *kinesis.UpdateShardCountOutput
	}
	updateShardCountRequestReturnsOnCall map[int]struct {
		result1 *request.Request
		result2 *kinesis.UpdateShardCountOutput
	}
	UpdateShardCountWithContextStub        func(context.Context, *kinesis.UpdateShardCountInput, ...request.Option) (*kinesis.UpdateShardCountOutput, error)
	updateShardCountWithContextMutex       sync.RWMutex
	updateShardCountWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.UpdateShardCountInput
		arg3 []request.Option
	}
	updateShardCountWithContextReturns struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}
	updateShardCountWithContextReturnsOnCall map[int]struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}
	WaitUntilStreamExistsStub        func(*kinesis.DescribeStreamInput) error
	waitUntilStreamExistsMutex       sync.RWMutex
	waitUntilStreamExistsArgsForCall []struct {
		arg1 *kinesis.DescribeStreamInput
	}
	waitUntilStreamExistsReturns struct {
		result1 error
	}
	waitUntilStreamExistsReturnsOnCall map[int]struct {
		result1 error
	}
	WaitUntilStreamExistsWithContextStub        func(context.Context, *kinesis.DescribeStreamInput, ...request.WaiterOption) error
	waitUntilStreamExistsWithContextMutex       sync.RWMutex
	waitUntilStreamExistsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 []request.WaiterOption
	}
	waitUntilStreamExistsWithContextReturns struct {
		result1 error
	}
	waitUntilStreamExistsWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	WaitUntilStreamNotExistsStub        func(*kinesis.DescribeStreamInput) error
	waitUntilStreamNotExistsMutex       sync.RWMutex
	waitUntilStreamNotExistsArgsForCall []struct {
		arg1 *kinesis.DescribeStreamInput
	}
	waitUntilStreamNotExistsReturns struct {
		result1 error
	}
	waitUntilStreamNotExistsReturnsOnCall map[int]struct {
		result1 error
	}
	WaitUntilStreamNotExistsWithContextStub        func(context.Context, *kinesis.DescribeStreamInput, ...request.WaiterOption) error
	waitUntilStreamNotExistsWithContextMutex       sync.RWMutex
	waitUntilStreamNotExistsWithContextArgsForCall []struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 []request.WaiterOption
	}
	waitUntilStreamNotExistsWithContextReturns struct {
		result1 error
	}
	waitUntilStreamNotExistsWithContextReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKinesisAPI) AddTagsToStream(arg1 *kinesis.AddTagsToStreamInput) (*kinesis.AddTagsToStreamOutput, error) {
	fake.addTagsToStreamMutex.Lock()
	ret, specificReturn := fake.addTagsToStreamReturnsOnCall[len(fake.addTagsToStreamArgsForCall)]
	fake.addTagsToStreamArgsForCall = append(fake.addTagsToStreamArgsForCall, struct {
		arg1 *kinesis.AddTagsToStreamInput
	}{arg1})
	stub := fake.AddTagsToStreamStub
	fakeReturns := fake.addTagsToStreamReturns
	fake.recordInvocation("AddTagsToStream", []interface{}{arg1})
	fake.addTagsToStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) AddTagsToStreamCallCount() int {
	fake.addTagsToStreamMutex.RLock()
	defer fake.addTagsToStreamMutex.RUnlock()
	return len(fake.addTagsToStreamArgsForCall)
}

func (fake *FakeKinesisAPI) AddTagsToStreamCalls(stub func(*kinesis.AddTagsToStreamInput) (*kinesis.AddTagsToStreamOutput, error)) {
	fake.addTagsToStreamMutex.Lock()
	defer fake.addTagsToStreamMutex.Unlock()
	fake.AddTagsToStreamStub = stub
}

func (fake *FakeKinesisAPI) AddTagsToStreamArgsForCall(i int) *kinesis.AddTagsToStreamInput {
	fake.addTagsToStreamMutex.RLock()
	defer fake.addTagsToStreamMutex.RUnlock()
	argsForCall := fake.addTagsToStreamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) AddTagsToStreamReturns(result1 *kinesis.AddTagsToStreamOutput, result2 error) {
	fake.addTagsToStreamMutex.Lock()
	defer fake.addTagsToStreamMutex.Unlock()
	fake.AddTagsToStreamStub = nil
	fake.addTagsToStreamReturns = struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) AddTagsToStreamReturnsOnCall(i int, result1 *kinesis.AddTagsToStreamOutput, result2 error) {
	fake.addTagsToStreamMutex.Lock()
	defer fake.addTagsToStreamMutex.Unlock()
	fake.AddTagsToStreamStub = nil
	if fake.addTagsToStreamReturnsOnCall == nil {
		fake.addTagsToStreamReturnsOnCall = make(map[int]struct {
			result1 *kinesis.AddTagsToStreamOutput
			result2 error
		})
	}
	fake.addTagsToStreamReturnsOnCall[i] = struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) AddTagsToStreamRequest(arg1 *kinesis.AddTagsToStreamInput) (*request.Request, *kinesis.AddTagsToStreamOutput) {
	fake.addTagsToStreamRequestMutex.Lock()
	ret, specificReturn := fake.addTagsToStreamRequestReturnsOnCall[len(fake.addTagsToStreamRequestArgsForCall)]
	fake.addTagsToStreamRequestArgsForCall = append(fake.addTagsToStreamRequestArgsForCall, struct {
		arg1 *kinesis.AddTagsToStreamInput
	}{arg1})
	stub := fake.AddTagsToStreamRequestStub
	fakeReturns := fake.addTagsToStreamRequestReturns
	fake.recordInvocation("AddTagsToStreamRequest", []interface{}{arg1})
	fake.addTagsToStreamRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) AddTagsToStreamRequestCallCount() int {
	fake.addTagsToStreamRequestMutex.RLock()
	defer fake.addTagsToStreamRequestMutex.RUnlock()
	return len(fake.addTagsToStreamRequestArgsForCall)
}

func (fake *FakeKinesisAPI) AddTagsToStreamRequestCalls(stub func(*kinesis.AddTagsToStreamInput) (*request.Request, *kinesis.AddTagsToStreamOutput)) {
	fake.addTagsToStreamRequestMutex.Lock()
	defer fake.addTagsToStreamRequestMutex.Unlock()
	fake.AddTagsToStreamRequestStub = stub
}

func (fake *FakeKinesisAPI) AddTagsToStreamRequestArgsForCall(i int) *kinesis.AddTagsToStreamInput {
	fake.addTagsToStreamRequestMutex.RLock()
	defer fake.addTagsToStreamRequestMutex.RUnlock()
	argsForCall := fake.addTagsToStreamRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) AddTagsToStreamRequestReturns(result1 *request.Request, result2 *kinesis.AddTagsToStreamOutput) {
	fake.addTagsToStreamRequestMutex.Lock()
	defer fake.addTagsToStreamRequestMutex.Unlock()
	fake.AddTagsToStreamRequestStub = nil
	fake.addTagsToStreamRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.AddTagsToStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) AddTagsToStreamRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.AddTagsToStreamOutput) {
	fake.addTagsToStreamRequestMutex.Lock()
	defer fake.addTagsToStreamRequestMutex.Unlock()
	fake.AddTagsToStreamRequestStub = nil
	if fake.addTagsToStreamRequestReturnsOnCall == nil {
		fake.addTagsToStreamRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.AddTagsToStreamOutput
		})
	}
	fake.addTagsToStreamRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.AddTagsToStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) AddTagsToStreamWithContext(arg1 context.Context, arg2 *kinesis.AddTagsToStreamInput, arg3 ...request.Option) (*kinesis.AddTagsToStreamOutput, error) {
	fake.addTagsToStreamWithContextMutex.Lock()
	ret, specificReturn := fake.addTagsToStreamWithContextReturnsOnCall[len(fake.addTagsToStreamWithContextArgsForCall)]
	fake.addTagsToStreamWithContextArgsForCall = append(fake.addTagsToStreamWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.AddTagsToStreamInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.AddTagsToStreamWithContextStub
	fakeReturns := fake.addTagsToStreamWithContextReturns
	fake.recordInvocation("AddTagsToStreamWithContext", []interface{}{arg1, arg2, arg3})
	fake.addTagsToStreamWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) AddTagsToStreamWithContextCallCount() int {
	fake.addTagsToStreamWithContextMutex.RLock()
	defer fake.addTagsToStreamWithContextMutex.RUnlock()
	return len(fake.addTagsToStreamWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) AddTagsToStreamWithContextCalls(stub func(context.Context, *kinesis.AddTagsToStreamInput, ...request.Option) (*kinesis.AddTagsToStreamOutput, error)) {
	fake.addTagsToStreamWithContextMutex.Lock()
	defer fake.addTagsToStreamWithContextMutex.Unlock()
	fake.AddTagsToStreamWithContextStub = stub
}

func (fake *FakeKinesisAPI) AddTagsToStreamWithContextArgsForCall(i int) (context.Context, *kinesis.AddTagsToStreamInput, []request.Option) {
	fake.addTagsToStreamWithContextMutex.RLock()
	defer fake.addTagsToStreamWithContextMutex.RUnlock()
	argsForCall := fake.addTagsToStreamWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) AddTagsToStreamWithContextReturns(result1 *kinesis.AddTagsToStreamOutput, result2 error) {
	fake.addTagsToStreamWithContextMutex.Lock()
	defer fake.addTagsToStreamWithContextMutex.Unlock()
	fake.AddTagsToStreamWithContextStub = nil
	fake.addTagsToStreamWithContextReturns = struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) AddTagsToStreamWithContextReturnsOnCall(i int, result1 *kinesis.AddTagsToStreamOutput, result2 error) {
	fake.addTagsToStreamWithContextMutex.Lock()
	defer fake.addTagsToStreamWithContextMutex.Unlock()
	fake.AddTagsToStreamWithContextStub = nil
	if fake.addTagsToStreamWithContextReturnsOnCall == nil {
		fake.addTagsToStreamWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.AddTagsToStreamOutput
			result2 error
		})
	}
	fake.addTagsToStreamWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.AddTagsToStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) CreateStream(arg1 *kinesis.CreateStreamInput) (*kinesis.CreateStreamOutput, error) {
	fake.createStreamMutex.Lock()
	ret, specificReturn := fake.createStreamReturnsOnCall[len(fake.createStreamArgsForCall)]
	fake.createStreamArgsForCall = append(fake.createStreamArgsForCall, struct {
		arg1 *kinesis.CreateStreamInput
	}{arg1})
	stub := fake.CreateStreamStub
	fakeReturns := fake.createStreamReturns
	fake.recordInvocation("CreateStream", []interface{}{arg1})
	fake.createStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) CreateStreamCallCount() int {
	fake.createStreamMutex.RLock()
	defer fake.createStreamMutex.RUnlock()
	return len(fake.createStreamArgsForCall)
}

func (fake *FakeKinesisAPI) CreateStreamCalls(stub func(*kinesis.CreateStreamInput) (*kinesis.CreateStreamOutput, error)) {
	fake.createStreamMutex.Lock()
	defer fake.createStreamMutex.Unlock()
	fake.CreateStreamStub = stub
}

func (fake *FakeKinesisAPI) CreateStreamArgsForCall(i int) *kinesis.CreateStreamInput {
	fake.createStreamMutex.RLock()
	defer fake.createStreamMutex.RUnlock()
	argsForCall := fake.createStreamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) CreateStreamReturns(result1 *kinesis.CreateStreamOutput, result2 error) {
	fake.createStreamMutex.Lock()
	defer fake.createStreamMutex.Unlock()
	fake.CreateStreamStub = nil
	fake.createStreamReturns = struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) CreateStreamReturnsOnCall(i int, result1 *kinesis.CreateStreamOutput, result2 error) {
	fake.createStreamMutex.Lock()
	defer fake.createStreamMutex.Unlock()
	fake.CreateStreamStub = nil
	if fake.createStreamReturnsOnCall == nil {
		fake.createStreamReturnsOnCall = make(map[int]struct {
			result1 *kinesis.CreateStreamOutput
			result2 error
		})
	}
	fake.createStreamReturnsOnCall[i] = struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) CreateStreamRequest(arg1 *kinesis.CreateStreamInput) (*request.Request, *kinesis.CreateStreamOutput) {
	fake.createStreamRequestMutex.Lock()
	ret, specificReturn := fake.createStreamRequestReturnsOnCall[len(fake.createStreamRequestArgsForCall)]
	fake.createStreamRequestArgsForCall = append(fake.createStreamRequestArgsForCall, struct {
		arg1 *kinesis.CreateStreamInput
	}{arg1})
	stub := fake.CreateStreamRequestStub
	fakeReturns := fake.createStreamRequestReturns
	fake.recordInvocation("CreateStreamRequest", []interface{}{arg1})
	fake.createStreamRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) CreateStreamRequestCallCount() int {
	fake.createStreamRequestMutex.RLock()
	defer fake.createStreamRequestMutex.RUnlock()
	return len(fake.createStreamRequestArgsForCall)
}

func (fake *FakeKinesisAPI) CreateStreamRequestCalls(stub func(*kinesis.CreateStreamInput) (*request.Request, *kinesis.CreateStreamOutput)) {
	fake.createStreamRequestMutex.Lock()
	defer fake.createStreamRequestMutex.Unlock()
	fake.CreateStreamRequestStub = stub
}

func (fake *FakeKinesisAPI) CreateStreamRequestArgsForCall(i int) *kinesis.CreateStreamInput {
	fake.createStreamRequestMutex.RLock()
	defer fake.createStreamRequestMutex.RUnlock()
	argsForCall := fake.createStreamRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) CreateStreamRequestReturns(result1 *request.Request, result2 *kinesis.CreateStreamOutput) {
	fake.createStreamRequestMutex.Lock()
	defer fake.createStreamRequestMutex.Unlock()
	fake.CreateStreamRequestStub = nil
	fake.createStreamRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.CreateStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) CreateStreamRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.CreateStreamOutput) {
	fake.createStreamRequestMutex.Lock()
	defer fake.createStreamRequestMutex.Unlock()
	fake.CreateStreamRequestStub = nil
	if fake.createStreamRequestReturnsOnCall == nil {
		fake.createStreamRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.CreateStreamOutput
		})
	}
	fake.createStreamRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.CreateStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) CreateStreamWithContext(arg1 context.Context, arg2 *kinesis.CreateStreamInput, arg3 ...request.Option) (*kinesis.CreateStreamOutput, error) {
	fake.createStreamWithContextMutex.Lock()
	ret, specificReturn := fake.createStreamWithContextReturnsOnCall[len(fake.createStreamWithContextArgsForCall)]
	fake.createStreamWithContextArgsForCall = append(fake.createStreamWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.CreateStreamInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.CreateStreamWithContextStub
	fakeReturns := fake.createStreamWithContextReturns
	fake.recordInvocation("CreateStreamWithContext", []interface{}{arg1, arg2, arg3})
	fake.createStreamWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) CreateStreamWithContextCallCount() int {
	fake.createStreamWithContextMutex.RLock()
	defer fake.createStreamWithContextMutex.RUnlock()
	return len(fake.createStreamWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) CreateStreamWithContextCalls(stub func(context.Context, *kinesis.CreateStreamInput, ...request.Option) (*kinesis.CreateStreamOutput, error)) {
	fake.createStreamWithContextMutex.Lock()
	defer fake.createStreamWithContextMutex.Unlock()
	fake.CreateStreamWithContextStub = stub
}

func (fake *FakeKinesisAPI) CreateStreamWithContextArgsForCall(i int) (context.Context, *kinesis.CreateStreamInput, []request.Option) {
	fake.createStreamWithContextMutex.RLock()
	defer fake.createStreamWithContextMutex.RUnlock()
	argsForCall := fake.createStreamWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) CreateStreamWithContextReturns(result1 *kinesis.CreateStreamOutput, result2 error) {
	fake.createStreamWithContextMutex.Lock()
	defer fake.createStreamWithContextMutex.Unlock()
	fake.CreateStreamWithContextStub = nil
	fake.createStreamWithContextReturns = struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) CreateStreamWithContextReturnsOnCall(i int, result1 *kinesis.CreateStreamOutput, result2 error) {
	fake.createStreamWithContextMutex.Lock()
	defer fake.createStreamWithContextMutex.Unlock()
	fake.CreateStreamWithContextStub = nil
	if fake.createStreamWithContextReturnsOnCall == nil {
		fake.createStreamWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.CreateStreamOutput
			result2 error
		})
	}
	fake.createStreamWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.CreateStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriod(arg1 *kinesis.DecreaseStreamRetentionPeriodInput) (*kinesis.DecreaseStreamRetentionPeriodOutput, error) {
	fake.decreaseStreamRetentionPeriodMutex.Lock()
	ret, specificReturn := fake.decreaseStreamRetentionPeriodReturnsOnCall[len(fake.decreaseStreamRetentionPeriodArgsForCall)]
	fake.decreaseStreamRetentionPeriodArgsForCall = append(fake.decreaseStreamRetentionPeriodArgsForCall, struct {
		arg1 *kinesis.DecreaseStreamRetentionPeriodInput
	}{arg1})
	stub := fake.DecreaseStreamRetentionPeriodStub
	fakeReturns := fake.decreaseStreamRetentionPeriodReturns
	fake.recordInvocation("DecreaseStreamRetentionPeriod", []interface{}{arg1})
	fake.decreaseStreamRetentionPeriodMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodCallCount() int {
	fake.decreaseStreamRetentionPeriodMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodMutex.RUnlock()
	return len(fake.decreaseStreamRetentionPeriodArgsForCall)
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodCalls(stub func(*kinesis.DecreaseStreamRetentionPeriodInput) (*kinesis.DecreaseStreamRetentionPeriodOutput, error)) {
	fake.decreaseStreamRetentionPeriodMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodStub = stub
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodArgsForCall(i int) *kinesis.DecreaseStreamRetentionPeriodInput {
	fake.decreaseStreamRetentionPeriodMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodMutex.RUnlock()
	argsForCall := fake.decreaseStreamRetentionPeriodArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodReturns(result1 *kinesis.DecreaseStreamRetentionPeriodOutput, result2 error) {
	fake.decreaseStreamRetentionPeriodMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodStub = nil
	fake.decreaseStreamRetentionPeriodReturns = struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodReturnsOnCall(i int, result1 *kinesis.DecreaseStreamRetentionPeriodOutput, result2 error) {
	fake.decreaseStreamRetentionPeriodMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodStub = nil
	if fake.decreaseStreamRetentionPeriodReturnsOnCall == nil {
		fake.decreaseStreamRetentionPeriodReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DecreaseStreamRetentionPeriodOutput
			result2 error
		})
	}
	fake.decreaseStreamRetentionPeriodReturnsOnCall[i] = struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodRequest(arg1 *kinesis.DecreaseStreamRetentionPeriodInput) (*request.Request, *kinesis.DecreaseStreamRetentionPeriodOutput) {
	fake.decreaseStreamRetentionPeriodRequestMutex.Lock()
	ret, specificReturn := fake.decreaseStreamRetentionPeriodRequestReturnsOnCall[len(fake.decreaseStreamRetentionPeriodRequestArgsForCall)]
	fake.decreaseStreamRetentionPeriodRequestArgsForCall = append(fake.decreaseStreamRetentionPeriodRequestArgsForCall, struct {
		arg1 *kinesis.DecreaseStreamRetentionPeriodInput
	}{arg1})
	stub := fake.DecreaseStreamRetentionPeriodRequestStub
	fakeReturns := fake.decreaseStreamRetentionPeriodRequestReturns
	fake.recordInvocation("DecreaseStreamRetentionPeriodRequest", []interface{}{arg1})
	fake.decreaseStreamRetentionPeriodRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodRequestCallCount() int {
	fake.decreaseStreamRetentionPeriodRequestMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodRequestMutex.RUnlock()
	return len(fake.decreaseStreamRetentionPeriodRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodRequestCalls(stub func(*kinesis.DecreaseStreamRetentionPeriodInput) (*request.Request, *kinesis.DecreaseStreamRetentionPeriodOutput)) {
	fake.decreaseStreamRetentionPeriodRequestMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodRequestMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodRequestStub = stub
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodRequestArgsForCall(i int) *kinesis.DecreaseStreamRetentionPeriodInput {
	fake.decreaseStreamRetentionPeriodRequestMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodRequestMutex.RUnlock()
	argsForCall := fake.decreaseStreamRetentionPeriodRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodRequestReturns(result1 *request.Request, result2 *kinesis.DecreaseStreamRetentionPeriodOutput) {
	fake.decreaseStreamRetentionPeriodRequestMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodRequestMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodRequestStub = nil
	fake.decreaseStreamRetentionPeriodRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.DecreaseStreamRetentionPeriodOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.DecreaseStreamRetentionPeriodOutput) {
	fake.decreaseStreamRetentionPeriodRequestMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodRequestMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodRequestStub = nil
	if fake.decreaseStreamRetentionPeriodRequestReturnsOnCall == nil {
		fake.decreaseStreamRetentionPeriodRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.DecreaseStreamRetentionPeriodOutput
		})
	}
	fake.decreaseStreamRetentionPeriodRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.DecreaseStreamRetentionPeriodOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodWithContext(arg1 context.Context, arg2 *kinesis.DecreaseStreamRetentionPeriodInput, arg3 ...request.Option) (*kinesis.DecreaseStreamRetentionPeriodOutput, error) {
	fake.decreaseStreamRetentionPeriodWithContextMutex.Lock()
	ret, specificReturn := fake.decreaseStreamRetentionPeriodWithContextReturnsOnCall[len(fake.decreaseStreamRetentionPeriodWithContextArgsForCall)]
	fake.decreaseStreamRetentionPeriodWithContextArgsForCall = append(fake.decreaseStreamRetentionPeriodWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DecreaseStreamRetentionPeriodInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DecreaseStreamRetentionPeriodWithContextStub
	fakeReturns := fake.decreaseStreamRetentionPeriodWithContextReturns
	fake.recordInvocation("DecreaseStreamRetentionPeriodWithContext", []interface{}{arg1, arg2, arg3})
	fake.decreaseStreamRetentionPeriodWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodWithContextCallCount() int {
	fake.decreaseStreamRetentionPeriodWithContextMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodWithContextMutex.RUnlock()
	return len(fake.decreaseStreamRetentionPeriodWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodWithContextCalls(stub func(context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, ...request.Option) (*kinesis.DecreaseStreamRetentionPeriodOutput, error)) {
	fake.decreaseStreamRetentionPeriodWithContextMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodWithContextMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodWithContextStub = stub
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodWithContextArgsForCall(i int) (context.Context, *kinesis.DecreaseStreamRetentionPeriodInput, []request.Option) {
	fake.decreaseStreamRetentionPeriodWithContextMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodWithContextMutex.RUnlock()
	argsForCall := fake.decreaseStreamRetentionPeriodWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodWithContextReturns(result1 *kinesis.DecreaseStreamRetentionPeriodOutput, result2 error) {
	fake.decreaseStreamRetentionPeriodWithContextMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodWithContextMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodWithContextStub = nil
	fake.decreaseStreamRetentionPeriodWithContextReturns = struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DecreaseStreamRetentionPeriodWithContextReturnsOnCall(i int, result1 *kinesis.DecreaseStreamRetentionPeriodOutput, result2 error) {
	fake.decreaseStreamRetentionPeriodWithContextMutex.Lock()
	defer fake.decreaseStreamRetentionPeriodWithContextMutex.Unlock()
	fake.DecreaseStreamRetentionPeriodWithContextStub = nil
	if fake.decreaseStreamRetentionPeriodWithContextReturnsOnCall == nil {
		fake.decreaseStreamRetentionPeriodWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DecreaseStreamRetentionPeriodOutput
			result2 error
		})
	}
	fake.decreaseStreamRetentionPeriodWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.DecreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeleteStream(arg1 *kinesis.DeleteStreamInput) (*kinesis.DeleteStreamOutput, error) {
	fake.deleteStreamMutex.Lock()
	ret, specificReturn := fake.deleteStreamReturnsOnCall[len(fake.deleteStreamArgsForCall)]
	fake.deleteStreamArgsForCall = append(fake.deleteStreamArgsForCall, struct {
		arg1 *kinesis.DeleteStreamInput
	}{arg1})
	stub := fake.DeleteStreamStub
	fakeReturns := fake.deleteStreamReturns
	fake.recordInvocation("DeleteStream", []interface{}{arg1})
	fake.deleteStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DeleteStreamCallCount() int {
	fake.deleteStreamMutex.RLock()
	defer fake.deleteStreamMutex.RUnlock()
	return len(fake.deleteStreamArgsForCall)
}

func (fake *FakeKinesisAPI) DeleteStreamCalls(stub func(*kinesis.DeleteStreamInput) (*kinesis.DeleteStreamOutput, error)) {
	fake.deleteStreamMutex.Lock()
	defer fake.deleteStreamMutex.Unlock()
	fake.DeleteStreamStub = stub
}

func (fake *FakeKinesisAPI) DeleteStreamArgsForCall(i int) *kinesis.DeleteStreamInput {
	fake.deleteStreamMutex.RLock()
	defer fake.deleteStreamMutex.RUnlock()
	argsForCall := fake.deleteStreamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DeleteStreamReturns(result1 *kinesis.DeleteStreamOutput, result2 error) {
	fake.deleteStreamMutex.Lock()
	defer fake.deleteStreamMutex.Unlock()
	fake.DeleteStreamStub = nil
	fake.deleteStreamReturns = struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeleteStreamReturnsOnCall(i int, result1 *kinesis.DeleteStreamOutput, result2 error) {
	fake.deleteStreamMutex.Lock()
	defer fake.deleteStreamMutex.Unlock()
	fake.DeleteStreamStub = nil
	if fake.deleteStreamReturnsOnCall == nil {
		fake.deleteStreamReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DeleteStreamOutput
			result2 error
		})
	}
	fake.deleteStreamReturnsOnCall[i] = struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeleteStreamRequest(arg1 *kinesis.DeleteStreamInput) (*request.Request, *kinesis.DeleteStreamOutput) {
	fake.deleteStreamRequestMutex.Lock()
	ret, specificReturn := fake.deleteStreamRequestReturnsOnCall[len(fake.deleteStreamRequestArgsForCall)]
	fake.deleteStreamRequestArgsForCall = append(fake.deleteStreamRequestArgsForCall, struct {
		arg1 *kinesis.DeleteStreamInput
	}{arg1})
	stub := fake.DeleteStreamRequestStub
	fakeReturns := fake.deleteStreamRequestReturns
	fake.recordInvocation("DeleteStreamRequest", []interface{}{arg1})
	fake.deleteStreamRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DeleteStreamRequestCallCount() int {
	fake.deleteStreamRequestMutex.RLock()
	defer fake.deleteStreamRequestMutex.RUnlock()
	return len(fake.deleteStreamRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DeleteStreamRequestCalls(stub func(*kinesis.DeleteStreamInput) (*request.Request, *kinesis.DeleteStreamOutput)) {
	fake.deleteStreamRequestMutex.Lock()
	defer fake.deleteStreamRequestMutex.Unlock()
	fake.DeleteStreamRequestStub = stub
}

func (fake *FakeKinesisAPI) DeleteStreamRequestArgsForCall(i int) *kinesis.DeleteStreamInput {
	fake.deleteStreamRequestMutex.RLock()
	defer fake.deleteStreamRequestMutex.RUnlock()
	argsForCall := fake.deleteStreamRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DeleteStreamRequestReturns(result1 *request.Request, result2 *kinesis.DeleteStreamOutput) {
	fake.deleteStreamRequestMutex.Lock()
	defer fake.deleteStreamRequestMutex.Unlock()
	fake.DeleteStreamRequestStub = nil
	fake.deleteStreamRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.DeleteStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeleteStreamRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.DeleteStreamOutput) {
	fake.deleteStreamRequestMutex.Lock()
	defer fake.deleteStreamRequestMutex.Unlock()
	fake.DeleteStreamRequestStub = nil
	if fake.deleteStreamRequestReturnsOnCall == nil {
		fake.deleteStreamRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.DeleteStreamOutput
		})
	}
	fake.deleteStreamRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.DeleteStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeleteStreamWithContext(arg1 context.Context, arg2 *kinesis.DeleteStreamInput, arg3 ...request.Option) (*kinesis.DeleteStreamOutput, error) {
	fake.deleteStreamWithContextMutex.Lock()
	ret, specificReturn := fake.deleteStreamWithContextReturnsOnCall[len(fake.deleteStreamWithContextArgsForCall)]
	fake.deleteStreamWithContextArgsForCall = append(fake.deleteStreamWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DeleteStreamInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DeleteStreamWithContextStub
	fakeReturns := fake.deleteStreamWithContextReturns
	fake.recordInvocation("DeleteStreamWithContext", []interface{}{arg1, arg2, arg3})
	fake.deleteStreamWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DeleteStreamWithContextCallCount() int {
	fake.deleteStreamWithContextMutex.RLock()
	defer fake.deleteStreamWithContextMutex.RUnlock()
	return len(fake.deleteStreamWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DeleteStreamWithContextCalls(stub func(context.Context, *kinesis.DeleteStreamInput, ...request.Option) (*kinesis.DeleteStreamOutput, error)) {
	fake.deleteStreamWithContextMutex.Lock()
	defer fake.deleteStreamWithContextMutex.Unlock()
	fake.DeleteStreamWithContextStub = stub
}

func (fake *FakeKinesisAPI) DeleteStreamWithContextArgsForCall(i int) (context.Context, *kinesis.DeleteStreamInput, []request.Option) {
	fake.deleteStreamWithContextMutex.RLock()
	defer fake.deleteStreamWithContextMutex.RUnlock()
	argsForCall := fake.deleteStreamWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DeleteStreamWithContextReturns(result1 *kinesis.DeleteStreamOutput, result2 error) {
	fake.deleteStreamWithContextMutex.Lock()
	defer fake.deleteStreamWithContextMutex.Unlock()
	fake.DeleteStreamWithContextStub = nil
	fake.deleteStreamWithContextReturns = struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeleteStreamWithContextReturnsOnCall(i int, result1 *kinesis.DeleteStreamOutput, result2 error) {
	fake.deleteStreamWithContextMutex.Lock()
	defer fake.deleteStreamWithContextMutex.Unlock()
	fake.DeleteStreamWithContextStub = nil
	if fake.deleteStreamWithContextReturnsOnCall == nil {
		fake.deleteStreamWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DeleteStreamOutput
			result2 error
		})
	}
	fake.deleteStreamWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.DeleteStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumer(arg1 *kinesis.DeregisterStreamConsumerInput) (*kinesis.DeregisterStreamConsumerOutput, error) {
	fake.deregisterStreamConsumerMutex.Lock()
	ret, specificReturn := fake.deregisterStreamConsumerReturnsOnCall[len(fake.deregisterStreamConsumerArgsForCall)]
	fake.deregisterStreamConsumerArgsForCall = append(fake.deregisterStreamConsumerArgsForCall, struct {
		arg1 *kinesis.DeregisterStreamConsumerInput
	}{arg1})
	stub := fake.DeregisterStreamConsumerStub
	fakeReturns := fake.deregisterStreamConsumerReturns
	fake.recordInvocation("DeregisterStreamConsumer", []interface{}{arg1})
	fake.deregisterStreamConsumerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerCallCount() int {
	fake.deregisterStreamConsumerMutex.RLock()
	defer fake.deregisterStreamConsumerMutex.RUnlock()
	return len(fake.deregisterStreamConsumerArgsForCall)
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerCalls(stub func(*kinesis.DeregisterStreamConsumerInput) (*kinesis.DeregisterStreamConsumerOutput, error)) {
	fake.deregisterStreamConsumerMutex.Lock()
	defer fake.deregisterStreamConsumerMutex.Unlock()
	fake.DeregisterStreamConsumerStub = stub
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerArgsForCall(i int) *kinesis.DeregisterStreamConsumerInput {
	fake.deregisterStreamConsumerMutex.RLock()
	defer fake.deregisterStreamConsumerMutex.RUnlock()
	argsForCall := fake.deregisterStreamConsumerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerReturns(result1 *kinesis.DeregisterStreamConsumerOutput, result2 error) {
	fake.deregisterStreamConsumerMutex.Lock()
	defer fake.deregisterStreamConsumerMutex.Unlock()
	fake.DeregisterStreamConsumerStub = nil
	fake.deregisterStreamConsumerReturns = struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerReturnsOnCall(i int, result1 *kinesis.DeregisterStreamConsumerOutput, result2 error) {
	fake.deregisterStreamConsumerMutex.Lock()
	defer fake.deregisterStreamConsumerMutex.Unlock()
	fake.DeregisterStreamConsumerStub = nil
	if fake.deregisterStreamConsumerReturnsOnCall == nil {
		fake.deregisterStreamConsumerReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DeregisterStreamConsumerOutput
			result2 error
		})
	}
	fake.deregisterStreamConsumerReturnsOnCall[i] = struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerRequest(arg1 *kinesis.DeregisterStreamConsumerInput) (*request.Request, *kinesis.DeregisterStreamConsumerOutput) {
	fake.deregisterStreamConsumerRequestMutex.Lock()
	ret, specificReturn := fake.deregisterStreamConsumerRequestReturnsOnCall[len(fake.deregisterStreamConsumerRequestArgsForCall)]
	fake.deregisterStreamConsumerRequestArgsForCall = append(fake.deregisterStreamConsumerRequestArgsForCall, struct {
		arg1 *kinesis.DeregisterStreamConsumerInput
	}{arg1})
	stub := fake.DeregisterStreamConsumerRequestStub
	fakeReturns := fake.deregisterStreamConsumerRequestReturns
	fake.recordInvocation("DeregisterStreamConsumerRequest", []interface{}{arg1})
	fake.deregisterStreamConsumerRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerRequestCallCount() int {
	fake.deregisterStreamConsumerRequestMutex.RLock()
	defer fake.deregisterStreamConsumerRequestMutex.RUnlock()
	return len(fake.deregisterStreamConsumerRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerRequestCalls(stub func(*kinesis.DeregisterStreamConsumerInput) (*request.Request, *kinesis.DeregisterStreamConsumerOutput)) {
	fake.deregisterStreamConsumerRequestMutex.Lock()
	defer fake.deregisterStreamConsumerRequestMutex.Unlock()
	fake.DeregisterStreamConsumerRequestStub = stub
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerRequestArgsForCall(i int) *kinesis.DeregisterStreamConsumerInput {
	fake.deregisterStreamConsumerRequestMutex.RLock()
	defer fake.deregisterStreamConsumerRequestMutex.RUnlock()
	argsForCall := fake.deregisterStreamConsumerRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerRequestReturns(result1 *request.Request, result2 *kinesis.DeregisterStreamConsumerOutput) {
	fake.deregisterStreamConsumerRequestMutex.Lock()
	defer fake.deregisterStreamConsumerRequestMutex.Unlock()
	fake.DeregisterStreamConsumerRequestStub = nil
	fake.deregisterStreamConsumerRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.DeregisterStreamConsumerOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.DeregisterStreamConsumerOutput) {
	fake.deregisterStreamConsumerRequestMutex.Lock()
	defer fake.deregisterStreamConsumerRequestMutex.Unlock()
	fake.DeregisterStreamConsumerRequestStub = nil
	if fake.deregisterStreamConsumerRequestReturnsOnCall == nil {
		fake.deregisterStreamConsumerRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.DeregisterStreamConsumerOutput
		})
	}
	fake.deregisterStreamConsumerRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.DeregisterStreamConsumerOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerWithContext(arg1 context.Context, arg2 *kinesis.DeregisterStreamConsumerInput, arg3 ...request.Option) (*kinesis.DeregisterStreamConsumerOutput, error) {
	fake.deregisterStreamConsumerWithContextMutex.Lock()
	ret, specificReturn := fake.deregisterStreamConsumerWithContextReturnsOnCall[len(fake.deregisterStreamConsumerWithContextArgsForCall)]
	fake.deregisterStreamConsumerWithContextArgsForCall = append(fake.deregisterStreamConsumerWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DeregisterStreamConsumerInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DeregisterStreamConsumerWithContextStub
	fakeReturns := fake.deregisterStreamConsumerWithContextReturns
	fake.recordInvocation("DeregisterStreamConsumerWithContext", []interface{}{arg1, arg2, arg3})
	fake.deregisterStreamConsumerWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerWithContextCallCount() int {
	fake.deregisterStreamConsumerWithContextMutex.RLock()
	defer fake.deregisterStreamConsumerWithContextMutex.RUnlock()
	return len(fake.deregisterStreamConsumerWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerWithContextCalls(stub func(context.Context, *kinesis.DeregisterStreamConsumerInput, ...request.Option) (*kinesis.DeregisterStreamConsumerOutput, error)) {
	fake.deregisterStreamConsumerWithContextMutex.Lock()
	defer fake.deregisterStreamConsumerWithContextMutex.Unlock()
	fake.DeregisterStreamConsumerWithContextStub = stub
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerWithContextArgsForCall(i int) (context.Context, *kinesis.DeregisterStreamConsumerInput, []request.Option) {
	fake.deregisterStreamConsumerWithContextMutex.RLock()
	defer fake.deregisterStreamConsumerWithContextMutex.RUnlock()
	argsForCall := fake.deregisterStreamConsumerWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerWithContextReturns(result1 *kinesis.DeregisterStreamConsumerOutput, result2 error) {
	fake.deregisterStreamConsumerWithContextMutex.Lock()
	defer fake.deregisterStreamConsumerWithContextMutex.Unlock()
	fake.DeregisterStreamConsumerWithContextStub = nil
	fake.deregisterStreamConsumerWithContextReturns = struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DeregisterStreamConsumerWithContextReturnsOnCall(i int, result1 *kinesis.DeregisterStreamConsumerOutput, result2 error) {
	fake.deregisterStreamConsumerWithContextMutex.Lock()
	defer fake.deregisterStreamConsumerWithContextMutex.Unlock()
	fake.DeregisterStreamConsumerWithContextStub = nil
	if fake.deregisterStreamConsumerWithContextReturnsOnCall == nil {
		fake.deregisterStreamConsumerWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DeregisterStreamConsumerOutput
			result2 error
		})
	}
	fake.deregisterStreamConsumerWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.DeregisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeLimits(arg1 *kinesis.DescribeLimitsInput) (*kinesis.DescribeLimitsOutput, error) {
	fake.describeLimitsMutex.Lock()
	ret, specificReturn := fake.describeLimitsReturnsOnCall[len(fake.describeLimitsArgsForCall)]
	fake.describeLimitsArgsForCall = append(fake.describeLimitsArgsForCall, struct {
		arg1 *kinesis.DescribeLimitsInput
	}{arg1})
	stub := fake.DescribeLimitsStub
	fakeReturns := fake.describeLimitsReturns
	fake.recordInvocation("DescribeLimits", []interface{}{arg1})
	fake.describeLimitsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeLimitsCallCount() int {
	fake.describeLimitsMutex.RLock()
	defer fake.describeLimitsMutex.RUnlock()
	return len(fake.describeLimitsArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeLimitsCalls(stub func(*kinesis.DescribeLimitsInput) (*kinesis.DescribeLimitsOutput, error)) {
	fake.describeLimitsMutex.Lock()
	defer fake.describeLimitsMutex.Unlock()
	fake.DescribeLimitsStub = stub
}

func (fake *FakeKinesisAPI) DescribeLimitsArgsForCall(i int) *kinesis.DescribeLimitsInput {
	fake.describeLimitsMutex.RLock()
	defer fake.describeLimitsMutex.RUnlock()
	argsForCall := fake.describeLimitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeLimitsReturns(result1 *kinesis.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsMutex.Lock()
	defer fake.describeLimitsMutex.Unlock()
	fake.DescribeLimitsStub = nil
	fake.describeLimitsReturns = struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeLimitsReturnsOnCall(i int, result1 *kinesis.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsMutex.Lock()
	defer fake.describeLimitsMutex.Unlock()
	fake.DescribeLimitsStub = nil
	if fake.describeLimitsReturnsOnCall == nil {
		fake.describeLimitsReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeLimitsOutput
			result2 error
		})
	}
	fake.describeLimitsReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeLimitsRequest(arg1 *kinesis.DescribeLimitsInput) (*request.Request, *kinesis.DescribeLimitsOutput) {
	fake.describeLimitsRequestMutex.Lock()
	ret, specificReturn := fake.describeLimitsRequestReturnsOnCall[len(fake.describeLimitsRequestArgsForCall)]
	fake.describeLimitsRequestArgsForCall = append(fake.describeLimitsRequestArgsForCall, struct {
		arg1 *kinesis.DescribeLimitsInput
	}{arg1})
	stub := fake.DescribeLimitsRequestStub
	fakeReturns := fake.describeLimitsRequestReturns
	fake.recordInvocation("DescribeLimitsRequest", []interface{}{arg1})
	fake.describeLimitsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeLimitsRequestCallCount() int {
	fake.describeLimitsRequestMutex.RLock()
	defer fake.describeLimitsRequestMutex.RUnlock()
	return len(fake.describeLimitsRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeLimitsRequestCalls(stub func(*kinesis.DescribeLimitsInput) (*request.Request, *kinesis.DescribeLimitsOutput)) {
	fake.describeLimitsRequestMutex.Lock()
	defer fake.describeLimitsRequestMutex.Unlock()
	fake.DescribeLimitsRequestStub = stub
}

func (fake *FakeKinesisAPI) DescribeLimitsRequestArgsForCall(i int) *kinesis.DescribeLimitsInput {
	fake.describeLimitsRequestMutex.RLock()
	defer fake.describeLimitsRequestMutex.RUnlock()
	argsForCall := fake.describeLimitsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeLimitsRequestReturns(result1 *request.Request, result2 *kinesis.DescribeLimitsOutput) {
	fake.describeLimitsRequestMutex.Lock()
	defer fake.describeLimitsRequestMutex.Unlock()
	fake.DescribeLimitsRequestStub = nil
	fake.describeLimitsRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.DescribeLimitsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeLimitsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.DescribeLimitsOutput) {
	fake.describeLimitsRequestMutex.Lock()
	defer fake.describeLimitsRequestMutex.Unlock()
	fake.DescribeLimitsRequestStub = nil
	if fake.describeLimitsRequestReturnsOnCall == nil {
		fake.describeLimitsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.DescribeLimitsOutput
		})
	}
	fake.describeLimitsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.DescribeLimitsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeLimitsWithContext(arg1 context.Context, arg2 *kinesis.DescribeLimitsInput, arg3 ...request.Option) (*kinesis.DescribeLimitsOutput, error) {
	fake.describeLimitsWithContextMutex.Lock()
	ret, specificReturn := fake.describeLimitsWithContextReturnsOnCall[len(fake.describeLimitsWithContextArgsForCall)]
	fake.describeLimitsWithContextArgsForCall = append(fake.describeLimitsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DescribeLimitsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DescribeLimitsWithContextStub
	fakeReturns := fake.describeLimitsWithContextReturns
	fake.recordInvocation("DescribeLimitsWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeLimitsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeLimitsWithContextCallCount() int {
	fake.describeLimitsWithContextMutex.RLock()
	defer fake.describeLimitsWithContextMutex.RUnlock()
	return len(fake.describeLimitsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeLimitsWithContextCalls(stub func(context.Context, *kinesis.DescribeLimitsInput, ...request.Option) (*kinesis.DescribeLimitsOutput, error)) {
	fake.describeLimitsWithContextMutex.Lock()
	defer fake.describeLimitsWithContextMutex.Unlock()
	fake.DescribeLimitsWithContextStub = stub
}

func (fake *FakeKinesisAPI) DescribeLimitsWithContextArgsForCall(i int) (context.Context, *kinesis.DescribeLimitsInput, []request.Option) {
	fake.describeLimitsWithContextMutex.RLock()
	defer fake.describeLimitsWithContextMutex.RUnlock()
	argsForCall := fake.describeLimitsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DescribeLimitsWithContextReturns(result1 *kinesis.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsWithContextMutex.Lock()
	defer fake.describeLimitsWithContextMutex.Unlock()
	fake.DescribeLimitsWithContextStub = nil
	fake.describeLimitsWithContextReturns = struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeLimitsWithContextReturnsOnCall(i int, result1 *kinesis.DescribeLimitsOutput, result2 error) {
	fake.describeLimitsWithContextMutex.Lock()
	defer fake.describeLimitsWithContextMutex.Unlock()
	fake.DescribeLimitsWithContextStub = nil
	if fake.describeLimitsWithContextReturnsOnCall == nil {
		fake.describeLimitsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeLimitsOutput
			result2 error
		})
	}
	fake.describeLimitsWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeLimitsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStream(arg1 *kinesis.DescribeStreamInput) (*kinesis.DescribeStreamOutput, error) {
	fake.describeStreamMutex.Lock()
	ret, specificReturn := fake.describeStreamReturnsOnCall[len(fake.describeStreamArgsForCall)]
	fake.describeStreamArgsForCall = append(fake.describeStreamArgsForCall, struct {
		arg1 *kinesis.DescribeStreamInput
	}{arg1})
	stub := fake.DescribeStreamStub
	fakeReturns := fake.describeStreamReturns
	fake.recordInvocation("DescribeStream", []interface{}{arg1})
	fake.describeStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamCallCount() int {
	fake.describeStreamMutex.RLock()
	defer fake.describeStreamMutex.RUnlock()
	return len(fake.describeStreamArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamCalls(stub func(*kinesis.DescribeStreamInput) (*kinesis.DescribeStreamOutput, error)) {
	fake.describeStreamMutex.Lock()
	defer fake.describeStreamMutex.Unlock()
	fake.DescribeStreamStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamArgsForCall(i int) *kinesis.DescribeStreamInput {
	fake.describeStreamMutex.RLock()
	defer fake.describeStreamMutex.RUnlock()
	argsForCall := fake.describeStreamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeStreamReturns(result1 *kinesis.DescribeStreamOutput, result2 error) {
	fake.describeStreamMutex.Lock()
	defer fake.describeStreamMutex.Unlock()
	fake.DescribeStreamStub = nil
	fake.describeStreamReturns = struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamReturnsOnCall(i int, result1 *kinesis.DescribeStreamOutput, result2 error) {
	fake.describeStreamMutex.Lock()
	defer fake.describeStreamMutex.Unlock()
	fake.DescribeStreamStub = nil
	if fake.describeStreamReturnsOnCall == nil {
		fake.describeStreamReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeStreamOutput
			result2 error
		})
	}
	fake.describeStreamReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamConsumer(arg1 *kinesis.DescribeStreamConsumerInput) (*kinesis.DescribeStreamConsumerOutput, error) {
	fake.describeStreamConsumerMutex.Lock()
	ret, specificReturn := fake.describeStreamConsumerReturnsOnCall[len(fake.describeStreamConsumerArgsForCall)]
	fake.describeStreamConsumerArgsForCall = append(fake.describeStreamConsumerArgsForCall, struct {
		arg1 *kinesis.DescribeStreamConsumerInput
	}{arg1})
	stub := fake.DescribeStreamConsumerStub
	fakeReturns := fake.describeStreamConsumerReturns
	fake.recordInvocation("DescribeStreamConsumer", []interface{}{arg1})
	fake.describeStreamConsumerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerCallCount() int {
	fake.describeStreamConsumerMutex.RLock()
	defer fake.describeStreamConsumerMutex.RUnlock()
	return len(fake.describeStreamConsumerArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerCalls(stub func(*kinesis.DescribeStreamConsumerInput) (*kinesis.DescribeStreamConsumerOutput, error)) {
	fake.describeStreamConsumerMutex.Lock()
	defer fake.describeStreamConsumerMutex.Unlock()
	fake.DescribeStreamConsumerStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerArgsForCall(i int) *kinesis.DescribeStreamConsumerInput {
	fake.describeStreamConsumerMutex.RLock()
	defer fake.describeStreamConsumerMutex.RUnlock()
	argsForCall := fake.describeStreamConsumerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerReturns(result1 *kinesis.DescribeStreamConsumerOutput, result2 error) {
	fake.describeStreamConsumerMutex.Lock()
	defer fake.describeStreamConsumerMutex.Unlock()
	fake.DescribeStreamConsumerStub = nil
	fake.describeStreamConsumerReturns = struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerReturnsOnCall(i int, result1 *kinesis.DescribeStreamConsumerOutput, result2 error) {
	fake.describeStreamConsumerMutex.Lock()
	defer fake.describeStreamConsumerMutex.Unlock()
	fake.DescribeStreamConsumerStub = nil
	if fake.describeStreamConsumerReturnsOnCall == nil {
		fake.describeStreamConsumerReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeStreamConsumerOutput
			result2 error
		})
	}
	fake.describeStreamConsumerReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerRequest(arg1 *kinesis.DescribeStreamConsumerInput) (*request.Request, *kinesis.DescribeStreamConsumerOutput) {
	fake.describeStreamConsumerRequestMutex.Lock()
	ret, specificReturn := fake.describeStreamConsumerRequestReturnsOnCall[len(fake.describeStreamConsumerRequestArgsForCall)]
	fake.describeStreamConsumerRequestArgsForCall = append(fake.describeStreamConsumerRequestArgsForCall, struct {
		arg1 *kinesis.DescribeStreamConsumerInput
	}{arg1})
	stub := fake.DescribeStreamConsumerRequestStub
	fakeReturns := fake.describeStreamConsumerRequestReturns
	fake.recordInvocation("DescribeStreamConsumerRequest", []interface{}{arg1})
	fake.describeStreamConsumerRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerRequestCallCount() int {
	fake.describeStreamConsumerRequestMutex.RLock()
	defer fake.describeStreamConsumerRequestMutex.RUnlock()
	return len(fake.describeStreamConsumerRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerRequestCalls(stub func(*kinesis.DescribeStreamConsumerInput) (*request.Request, *kinesis.DescribeStreamConsumerOutput)) {
	fake.describeStreamConsumerRequestMutex.Lock()
	defer fake.describeStreamConsumerRequestMutex.Unlock()
	fake.DescribeStreamConsumerRequestStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerRequestArgsForCall(i int) *kinesis.DescribeStreamConsumerInput {
	fake.describeStreamConsumerRequestMutex.RLock()
	defer fake.describeStreamConsumerRequestMutex.RUnlock()
	argsForCall := fake.describeStreamConsumerRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerRequestReturns(result1 *request.Request, result2 *kinesis.DescribeStreamConsumerOutput) {
	fake.describeStreamConsumerRequestMutex.Lock()
	defer fake.describeStreamConsumerRequestMutex.Unlock()
	fake.DescribeStreamConsumerRequestStub = nil
	fake.describeStreamConsumerRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamConsumerOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.DescribeStreamConsumerOutput) {
	fake.describeStreamConsumerRequestMutex.Lock()
	defer fake.describeStreamConsumerRequestMutex.Unlock()
	fake.DescribeStreamConsumerRequestStub = nil
	if fake.describeStreamConsumerRequestReturnsOnCall == nil {
		fake.describeStreamConsumerRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.DescribeStreamConsumerOutput
		})
	}
	fake.describeStreamConsumerRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamConsumerOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerWithContext(arg1 context.Context, arg2 *kinesis.DescribeStreamConsumerInput, arg3 ...request.Option) (*kinesis.DescribeStreamConsumerOutput, error) {
	fake.describeStreamConsumerWithContextMutex.Lock()
	ret, specificReturn := fake.describeStreamConsumerWithContextReturnsOnCall[len(fake.describeStreamConsumerWithContextArgsForCall)]
	fake.describeStreamConsumerWithContextArgsForCall = append(fake.describeStreamConsumerWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamConsumerInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DescribeStreamConsumerWithContextStub
	fakeReturns := fake.describeStreamConsumerWithContextReturns
	fake.recordInvocation("DescribeStreamConsumerWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeStreamConsumerWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerWithContextCallCount() int {
	fake.describeStreamConsumerWithContextMutex.RLock()
	defer fake.describeStreamConsumerWithContextMutex.RUnlock()
	return len(fake.describeStreamConsumerWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerWithContextCalls(stub func(context.Context, *kinesis.DescribeStreamConsumerInput, ...request.Option) (*kinesis.DescribeStreamConsumerOutput, error)) {
	fake.describeStreamConsumerWithContextMutex.Lock()
	defer fake.describeStreamConsumerWithContextMutex.Unlock()
	fake.DescribeStreamConsumerWithContextStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerWithContextArgsForCall(i int) (context.Context, *kinesis.DescribeStreamConsumerInput, []request.Option) {
	fake.describeStreamConsumerWithContextMutex.RLock()
	defer fake.describeStreamConsumerWithContextMutex.RUnlock()
	argsForCall := fake.describeStreamConsumerWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerWithContextReturns(result1 *kinesis.DescribeStreamConsumerOutput, result2 error) {
	fake.describeStreamConsumerWithContextMutex.Lock()
	defer fake.describeStreamConsumerWithContextMutex.Unlock()
	fake.DescribeStreamConsumerWithContextStub = nil
	fake.describeStreamConsumerWithContextReturns = struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamConsumerWithContextReturnsOnCall(i int, result1 *kinesis.DescribeStreamConsumerOutput, result2 error) {
	fake.describeStreamConsumerWithContextMutex.Lock()
	defer fake.describeStreamConsumerWithContextMutex.Unlock()
	fake.DescribeStreamConsumerWithContextStub = nil
	if fake.describeStreamConsumerWithContextReturnsOnCall == nil {
		fake.describeStreamConsumerWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeStreamConsumerOutput
			result2 error
		})
	}
	fake.describeStreamConsumerWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamPages(arg1 *kinesis.DescribeStreamInput, arg2 func(*kinesis.DescribeStreamOutput, bool) bool) error {
	fake.describeStreamPagesMutex.Lock()
	ret, specificReturn := fake.describeStreamPagesReturnsOnCall[len(fake.describeStreamPagesArgsForCall)]
	fake.describeStreamPagesArgsForCall = append(fake.describeStreamPagesArgsForCall, struct {
		arg1 *kinesis.DescribeStreamInput
		arg2 func(*kinesis.DescribeStreamOutput, bool) bool
	}{arg1, arg2})
	stub := fake.DescribeStreamPagesStub
	fakeReturns := fake.describeStreamPagesReturns
	fake.recordInvocation("DescribeStreamPages", []interface{}{arg1, arg2})
	fake.describeStreamPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) DescribeStreamPagesCallCount() int {
	fake.describeStreamPagesMutex.RLock()
	defer fake.describeStreamPagesMutex.RUnlock()
	return len(fake.describeStreamPagesArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamPagesCalls(stub func(*kinesis.DescribeStreamInput, func(*kinesis.DescribeStreamOutput, bool) bool) error) {
	fake.describeStreamPagesMutex.Lock()
	defer fake.describeStreamPagesMutex.Unlock()
	fake.DescribeStreamPagesStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamPagesArgsForCall(i int) (*kinesis.DescribeStreamInput, func(*kinesis.DescribeStreamOutput, bool) bool) {
	fake.describeStreamPagesMutex.RLock()
	defer fake.describeStreamPagesMutex.RUnlock()
	argsForCall := fake.describeStreamPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKinesisAPI) DescribeStreamPagesReturns(result1 error) {
	fake.describeStreamPagesMutex.Lock()
	defer fake.describeStreamPagesMutex.Unlock()
	fake.DescribeStreamPagesStub = nil
	fake.describeStreamPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) DescribeStreamPagesReturnsOnCall(i int, result1 error) {
	fake.describeStreamPagesMutex.Lock()
	defer fake.describeStreamPagesMutex.Unlock()
	fake.DescribeStreamPagesStub = nil
	if fake.describeStreamPagesReturnsOnCall == nil {
		fake.describeStreamPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.describeStreamPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) DescribeStreamPagesWithContext(arg1 context.Context, arg2 *kinesis.DescribeStreamInput, arg3 func(*kinesis.DescribeStreamOutput, bool) bool, arg4 ...request.Option) error {
	fake.describeStreamPagesWithContextMutex.Lock()
	ret, specificReturn := fake.describeStreamPagesWithContextReturnsOnCall[len(fake.describeStreamPagesWithContextArgsForCall)]
	fake.describeStreamPagesWithContextArgsForCall = append(fake.describeStreamPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 func(*kinesis.DescribeStreamOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	stub := fake.DescribeStreamPagesWithContextStub
	fakeReturns := fake.describeStreamPagesWithContextReturns
	fake.recordInvocation("DescribeStreamPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.describeStreamPagesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) DescribeStreamPagesWithContextCallCount() int {
	fake.describeStreamPagesWithContextMutex.RLock()
	defer fake.describeStreamPagesWithContextMutex.RUnlock()
	return len(fake.describeStreamPagesWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamPagesWithContextCalls(stub func(context.Context, *kinesis.DescribeStreamInput, func(*kinesis.DescribeStreamOutput, bool) bool, ...request.Option) error) {
	fake.describeStreamPagesWithContextMutex.Lock()
	defer fake.describeStreamPagesWithContextMutex.Unlock()
	fake.DescribeStreamPagesWithContextStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamPagesWithContextArgsForCall(i int) (context.Context, *kinesis.DescribeStreamInput, func(*kinesis.DescribeStreamOutput, bool) bool, []request.Option) {
	fake.describeStreamPagesWithContextMutex.RLock()
	defer fake.describeStreamPagesWithContextMutex.RUnlock()
	argsForCall := fake.describeStreamPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeKinesisAPI) DescribeStreamPagesWithContextReturns(result1 error) {
	fake.describeStreamPagesWithContextMutex.Lock()
	defer fake.describeStreamPagesWithContextMutex.Unlock()
	fake.DescribeStreamPagesWithContextStub = nil
	fake.describeStreamPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) DescribeStreamPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.describeStreamPagesWithContextMutex.Lock()
	defer fake.describeStreamPagesWithContextMutex.Unlock()
	fake.DescribeStreamPagesWithContextStub = nil
	if fake.describeStreamPagesWithContextReturnsOnCall == nil {
		fake.describeStreamPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.describeStreamPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) DescribeStreamRequest(arg1 *kinesis.DescribeStreamInput) (*request.Request, *kinesis.DescribeStreamOutput) {
	fake.describeStreamRequestMutex.Lock()
	ret, specificReturn := fake.describeStreamRequestReturnsOnCall[len(fake.describeStreamRequestArgsForCall)]
	fake.describeStreamRequestArgsForCall = append(fake.describeStreamRequestArgsForCall, struct {
		arg1 *kinesis.DescribeStreamInput
	}{arg1})
	stub := fake.DescribeStreamRequestStub
	fakeReturns := fake.describeStreamRequestReturns
	fake.recordInvocation("DescribeStreamRequest", []interface{}{arg1})
	fake.describeStreamRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamRequestCallCount() int {
	fake.describeStreamRequestMutex.RLock()
	defer fake.describeStreamRequestMutex.RUnlock()
	return len(fake.describeStreamRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamRequestCalls(stub func(*kinesis.DescribeStreamInput) (*request.Request, *kinesis.DescribeStreamOutput)) {
	fake.describeStreamRequestMutex.Lock()
	defer fake.describeStreamRequestMutex.Unlock()
	fake.DescribeStreamRequestStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamRequestArgsForCall(i int) *kinesis.DescribeStreamInput {
	fake.describeStreamRequestMutex.RLock()
	defer fake.describeStreamRequestMutex.RUnlock()
	argsForCall := fake.describeStreamRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeStreamRequestReturns(result1 *request.Request, result2 *kinesis.DescribeStreamOutput) {
	fake.describeStreamRequestMutex.Lock()
	defer fake.describeStreamRequestMutex.Unlock()
	fake.DescribeStreamRequestStub = nil
	fake.describeStreamRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.DescribeStreamOutput) {
	fake.describeStreamRequestMutex.Lock()
	defer fake.describeStreamRequestMutex.Unlock()
	fake.DescribeStreamRequestStub = nil
	if fake.describeStreamRequestReturnsOnCall == nil {
		fake.describeStreamRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.DescribeStreamOutput
		})
	}
	fake.describeStreamRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamSummary(arg1 *kinesis.DescribeStreamSummaryInput) (*kinesis.DescribeStreamSummaryOutput, error) {
	fake.describeStreamSummaryMutex.Lock()
	ret, specificReturn := fake.describeStreamSummaryReturnsOnCall[len(fake.describeStreamSummaryArgsForCall)]
	fake.describeStreamSummaryArgsForCall = append(fake.describeStreamSummaryArgsForCall, struct {
		arg1 *kinesis.DescribeStreamSummaryInput
	}{arg1})
	stub := fake.DescribeStreamSummaryStub
	fakeReturns := fake.describeStreamSummaryReturns
	fake.recordInvocation("DescribeStreamSummary", []interface{}{arg1})
	fake.describeStreamSummaryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryCallCount() int {
	fake.describeStreamSummaryMutex.RLock()
	defer fake.describeStreamSummaryMutex.RUnlock()
	return len(fake.describeStreamSummaryArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryCalls(stub func(*kinesis.DescribeStreamSummaryInput) (*kinesis.DescribeStreamSummaryOutput, error)) {
	fake.describeStreamSummaryMutex.Lock()
	defer fake.describeStreamSummaryMutex.Unlock()
	fake.DescribeStreamSummaryStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryArgsForCall(i int) *kinesis.DescribeStreamSummaryInput {
	fake.describeStreamSummaryMutex.RLock()
	defer fake.describeStreamSummaryMutex.RUnlock()
	argsForCall := fake.describeStreamSummaryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryReturns(result1 *kinesis.DescribeStreamSummaryOutput, result2 error) {
	fake.describeStreamSummaryMutex.Lock()
	defer fake.describeStreamSummaryMutex.Unlock()
	fake.DescribeStreamSummaryStub = nil
	fake.describeStreamSummaryReturns = struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryReturnsOnCall(i int, result1 *kinesis.DescribeStreamSummaryOutput, result2 error) {
	fake.describeStreamSummaryMutex.Lock()
	defer fake.describeStreamSummaryMutex.Unlock()
	fake.DescribeStreamSummaryStub = nil
	if fake.describeStreamSummaryReturnsOnCall == nil {
		fake.describeStreamSummaryReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeStreamSummaryOutput
			result2 error
		})
	}
	fake.describeStreamSummaryReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryRequest(arg1 *kinesis.DescribeStreamSummaryInput) (*request.Request, *kinesis.DescribeStreamSummaryOutput) {
	fake.describeStreamSummaryRequestMutex.Lock()
	ret, specificReturn := fake.describeStreamSummaryRequestReturnsOnCall[len(fake.describeStreamSummaryRequestArgsForCall)]
	fake.describeStreamSummaryRequestArgsForCall = append(fake.describeStreamSummaryRequestArgsForCall, struct {
		arg1 *kinesis.DescribeStreamSummaryInput
	}{arg1})
	stub := fake.DescribeStreamSummaryRequestStub
	fakeReturns := fake.describeStreamSummaryRequestReturns
	fake.recordInvocation("DescribeStreamSummaryRequest", []interface{}{arg1})
	fake.describeStreamSummaryRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryRequestCallCount() int {
	fake.describeStreamSummaryRequestMutex.RLock()
	defer fake.describeStreamSummaryRequestMutex.RUnlock()
	return len(fake.describeStreamSummaryRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryRequestCalls(stub func(*kinesis.DescribeStreamSummaryInput) (*request.Request, *kinesis.DescribeStreamSummaryOutput)) {
	fake.describeStreamSummaryRequestMutex.Lock()
	defer fake.describeStreamSummaryRequestMutex.Unlock()
	fake.DescribeStreamSummaryRequestStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryRequestArgsForCall(i int) *kinesis.DescribeStreamSummaryInput {
	fake.describeStreamSummaryRequestMutex.RLock()
	defer fake.describeStreamSummaryRequestMutex.RUnlock()
	argsForCall := fake.describeStreamSummaryRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryRequestReturns(result1 *request.Request, result2 *kinesis.DescribeStreamSummaryOutput) {
	fake.describeStreamSummaryRequestMutex.Lock()
	defer fake.describeStreamSummaryRequestMutex.Unlock()
	fake.DescribeStreamSummaryRequestStub = nil
	fake.describeStreamSummaryRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamSummaryOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.DescribeStreamSummaryOutput) {
	fake.describeStreamSummaryRequestMutex.Lock()
	defer fake.describeStreamSummaryRequestMutex.Unlock()
	fake.DescribeStreamSummaryRequestStub = nil
	if fake.describeStreamSummaryRequestReturnsOnCall == nil {
		fake.describeStreamSummaryRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.DescribeStreamSummaryOutput
		})
	}
	fake.describeStreamSummaryRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.DescribeStreamSummaryOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryWithContext(arg1 context.Context, arg2 *kinesis.DescribeStreamSummaryInput, arg3 ...request.Option) (*kinesis.DescribeStreamSummaryOutput, error) {
	fake.describeStreamSummaryWithContextMutex.Lock()
	ret, specificReturn := fake.describeStreamSummaryWithContextReturnsOnCall[len(fake.describeStreamSummaryWithContextArgsForCall)]
	fake.describeStreamSummaryWithContextArgsForCall = append(fake.describeStreamSummaryWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamSummaryInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DescribeStreamSummaryWithContextStub
	fakeReturns := fake.describeStreamSummaryWithContextReturns
	fake.recordInvocation("DescribeStreamSummaryWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeStreamSummaryWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryWithContextCallCount() int {
	fake.describeStreamSummaryWithContextMutex.RLock()
	defer fake.describeStreamSummaryWithContextMutex.RUnlock()
	return len(fake.describeStreamSummaryWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryWithContextCalls(stub func(context.Context, *kinesis.DescribeStreamSummaryInput, ...request.Option) (*kinesis.DescribeStreamSummaryOutput, error)) {
	fake.describeStreamSummaryWithContextMutex.Lock()
	defer fake.describeStreamSummaryWithContextMutex.Unlock()
	fake.DescribeStreamSummaryWithContextStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryWithContextArgsForCall(i int) (context.Context, *kinesis.DescribeStreamSummaryInput, []request.Option) {
	fake.describeStreamSummaryWithContextMutex.RLock()
	defer fake.describeStreamSummaryWithContextMutex.RUnlock()
	argsForCall := fake.describeStreamSummaryWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryWithContextReturns(result1 *kinesis.DescribeStreamSummaryOutput, result2 error) {
	fake.describeStreamSummaryWithContextMutex.Lock()
	defer fake.describeStreamSummaryWithContextMutex.Unlock()
	fake.DescribeStreamSummaryWithContextStub = nil
	fake.describeStreamSummaryWithContextReturns = struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamSummaryWithContextReturnsOnCall(i int, result1 *kinesis.DescribeStreamSummaryOutput, result2 error) {
	fake.describeStreamSummaryWithContextMutex.Lock()
	defer fake.describeStreamSummaryWithContextMutex.Unlock()
	fake.DescribeStreamSummaryWithContextStub = nil
	if fake.describeStreamSummaryWithContextReturnsOnCall == nil {
		fake.describeStreamSummaryWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeStreamSummaryOutput
			result2 error
		})
	}
	fake.describeStreamSummaryWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeStreamSummaryOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamWithContext(arg1 context.Context, arg2 *kinesis.DescribeStreamInput, arg3 ...request.Option) (*kinesis.DescribeStreamOutput, error) {
	fake.describeStreamWithContextMutex.Lock()
	ret, specificReturn := fake.describeStreamWithContextReturnsOnCall[len(fake.describeStreamWithContextArgsForCall)]
	fake.describeStreamWithContextArgsForCall = append(fake.describeStreamWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DescribeStreamWithContextStub
	fakeReturns := fake.describeStreamWithContextReturns
	fake.recordInvocation("DescribeStreamWithContext", []interface{}{arg1, arg2, arg3})
	fake.describeStreamWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DescribeStreamWithContextCallCount() int {
	fake.describeStreamWithContextMutex.RLock()
	defer fake.describeStreamWithContextMutex.RUnlock()
	return len(fake.describeStreamWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DescribeStreamWithContextCalls(stub func(context.Context, *kinesis.DescribeStreamInput, ...request.Option) (*kinesis.DescribeStreamOutput, error)) {
	fake.describeStreamWithContextMutex.Lock()
	defer fake.describeStreamWithContextMutex.Unlock()
	fake.DescribeStreamWithContextStub = stub
}

func (fake *FakeKinesisAPI) DescribeStreamWithContextArgsForCall(i int) (context.Context, *kinesis.DescribeStreamInput, []request.Option) {
	fake.describeStreamWithContextMutex.RLock()
	defer fake.describeStreamWithContextMutex.RUnlock()
	argsForCall := fake.describeStreamWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DescribeStreamWithContextReturns(result1 *kinesis.DescribeStreamOutput, result2 error) {
	fake.describeStreamWithContextMutex.Lock()
	defer fake.describeStreamWithContextMutex.Unlock()
	fake.DescribeStreamWithContextStub = nil
	fake.describeStreamWithContextReturns = struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DescribeStreamWithContextReturnsOnCall(i int, result1 *kinesis.DescribeStreamOutput, result2 error) {
	fake.describeStreamWithContextMutex.Lock()
	defer fake.describeStreamWithContextMutex.Unlock()
	fake.DescribeStreamWithContextStub = nil
	if fake.describeStreamWithContextReturnsOnCall == nil {
		fake.describeStreamWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.DescribeStreamOutput
			result2 error
		})
	}
	fake.describeStreamWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.DescribeStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoring(arg1 *kinesis.DisableEnhancedMonitoringInput) (*kinesis.EnhancedMonitoringOutput, error) {
	fake.disableEnhancedMonitoringMutex.Lock()
	ret, specificReturn := fake.disableEnhancedMonitoringReturnsOnCall[len(fake.disableEnhancedMonitoringArgsForCall)]
	fake.disableEnhancedMonitoringArgsForCall = append(fake.disableEnhancedMonitoringArgsForCall, struct {
		arg1 *kinesis.DisableEnhancedMonitoringInput
	}{arg1})
	stub := fake.DisableEnhancedMonitoringStub
	fakeReturns := fake.disableEnhancedMonitoringReturns
	fake.recordInvocation("DisableEnhancedMonitoring", []interface{}{arg1})
	fake.disableEnhancedMonitoringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringCallCount() int {
	fake.disableEnhancedMonitoringMutex.RLock()
	defer fake.disableEnhancedMonitoringMutex.RUnlock()
	return len(fake.disableEnhancedMonitoringArgsForCall)
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringCalls(stub func(*kinesis.DisableEnhancedMonitoringInput) (*kinesis.EnhancedMonitoringOutput, error)) {
	fake.disableEnhancedMonitoringMutex.Lock()
	defer fake.disableEnhancedMonitoringMutex.Unlock()
	fake.DisableEnhancedMonitoringStub = stub
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringArgsForCall(i int) *kinesis.DisableEnhancedMonitoringInput {
	fake.disableEnhancedMonitoringMutex.RLock()
	defer fake.disableEnhancedMonitoringMutex.RUnlock()
	argsForCall := fake.disableEnhancedMonitoringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringReturns(result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.disableEnhancedMonitoringMutex.Lock()
	defer fake.disableEnhancedMonitoringMutex.Unlock()
	fake.DisableEnhancedMonitoringStub = nil
	fake.disableEnhancedMonitoringReturns = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringReturnsOnCall(i int, result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.disableEnhancedMonitoringMutex.Lock()
	defer fake.disableEnhancedMonitoringMutex.Unlock()
	fake.DisableEnhancedMonitoringStub = nil
	if fake.disableEnhancedMonitoringReturnsOnCall == nil {
		fake.disableEnhancedMonitoringReturnsOnCall = make(map[int]struct {
			result1 *kinesis.EnhancedMonitoringOutput
			result2 error
		})
	}
	fake.disableEnhancedMonitoringReturnsOnCall[i] = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringRequest(arg1 *kinesis.DisableEnhancedMonitoringInput) (*request.Request, *kinesis.EnhancedMonitoringOutput) {
	fake.disableEnhancedMonitoringRequestMutex.Lock()
	ret, specificReturn := fake.disableEnhancedMonitoringRequestReturnsOnCall[len(fake.disableEnhancedMonitoringRequestArgsForCall)]
	fake.disableEnhancedMonitoringRequestArgsForCall = append(fake.disableEnhancedMonitoringRequestArgsForCall, struct {
		arg1 *kinesis.DisableEnhancedMonitoringInput
	}{arg1})
	stub := fake.DisableEnhancedMonitoringRequestStub
	fakeReturns := fake.disableEnhancedMonitoringRequestReturns
	fake.recordInvocation("DisableEnhancedMonitoringRequest", []interface{}{arg1})
	fake.disableEnhancedMonitoringRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringRequestCallCount() int {
	fake.disableEnhancedMonitoringRequestMutex.RLock()
	defer fake.disableEnhancedMonitoringRequestMutex.RUnlock()
	return len(fake.disableEnhancedMonitoringRequestArgsForCall)
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringRequestCalls(stub func(*kinesis.DisableEnhancedMonitoringInput) (*request.Request, *kinesis.EnhancedMonitoringOutput)) {
	fake.disableEnhancedMonitoringRequestMutex.Lock()
	defer fake.disableEnhancedMonitoringRequestMutex.Unlock()
	fake.DisableEnhancedMonitoringRequestStub = stub
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringRequestArgsForCall(i int) *kinesis.DisableEnhancedMonitoringInput {
	fake.disableEnhancedMonitoringRequestMutex.RLock()
	defer fake.disableEnhancedMonitoringRequestMutex.RUnlock()
	argsForCall := fake.disableEnhancedMonitoringRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringRequestReturns(result1 *request.Request, result2 *kinesis.EnhancedMonitoringOutput) {
	fake.disableEnhancedMonitoringRequestMutex.Lock()
	defer fake.disableEnhancedMonitoringRequestMutex.Unlock()
	fake.DisableEnhancedMonitoringRequestStub = nil
	fake.disableEnhancedMonitoringRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.EnhancedMonitoringOutput) {
	fake.disableEnhancedMonitoringRequestMutex.Lock()
	defer fake.disableEnhancedMonitoringRequestMutex.Unlock()
	fake.DisableEnhancedMonitoringRequestStub = nil
	if fake.disableEnhancedMonitoringRequestReturnsOnCall == nil {
		fake.disableEnhancedMonitoringRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.EnhancedMonitoringOutput
		})
	}
	fake.disableEnhancedMonitoringRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringWithContext(arg1 context.Context, arg2 *kinesis.DisableEnhancedMonitoringInput, arg3 ...request.Option) (*kinesis.EnhancedMonitoringOutput, error) {
	fake.disableEnhancedMonitoringWithContextMutex.Lock()
	ret, specificReturn := fake.disableEnhancedMonitoringWithContextReturnsOnCall[len(fake.disableEnhancedMonitoringWithContextArgsForCall)]
	fake.disableEnhancedMonitoringWithContextArgsForCall = append(fake.disableEnhancedMonitoringWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DisableEnhancedMonitoringInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.DisableEnhancedMonitoringWithContextStub
	fakeReturns := fake.disableEnhancedMonitoringWithContextReturns
	fake.recordInvocation("DisableEnhancedMonitoringWithContext", []interface{}{arg1, arg2, arg3})
	fake.disableEnhancedMonitoringWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringWithContextCallCount() int {
	fake.disableEnhancedMonitoringWithContextMutex.RLock()
	defer fake.disableEnhancedMonitoringWithContextMutex.RUnlock()
	return len(fake.disableEnhancedMonitoringWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringWithContextCalls(stub func(context.Context, *kinesis.DisableEnhancedMonitoringInput, ...request.Option) (*kinesis.EnhancedMonitoringOutput, error)) {
	fake.disableEnhancedMonitoringWithContextMutex.Lock()
	defer fake.disableEnhancedMonitoringWithContextMutex.Unlock()
	fake.DisableEnhancedMonitoringWithContextStub = stub
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringWithContextArgsForCall(i int) (context.Context, *kinesis.DisableEnhancedMonitoringInput, []request.Option) {
	fake.disableEnhancedMonitoringWithContextMutex.RLock()
	defer fake.disableEnhancedMonitoringWithContextMutex.RUnlock()
	argsForCall := fake.disableEnhancedMonitoringWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringWithContextReturns(result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.disableEnhancedMonitoringWithContextMutex.Lock()
	defer fake.disableEnhancedMonitoringWithContextMutex.Unlock()
	fake.DisableEnhancedMonitoringWithContextStub = nil
	fake.disableEnhancedMonitoringWithContextReturns = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) DisableEnhancedMonitoringWithContextReturnsOnCall(i int, result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.disableEnhancedMonitoringWithContextMutex.Lock()
	defer fake.disableEnhancedMonitoringWithContextMutex.Unlock()
	fake.DisableEnhancedMonitoringWithContextStub = nil
	if fake.disableEnhancedMonitoringWithContextReturnsOnCall == nil {
		fake.disableEnhancedMonitoringWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.EnhancedMonitoringOutput
			result2 error
		})
	}
	fake.disableEnhancedMonitoringWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoring(arg1 *kinesis.EnableEnhancedMonitoringInput) (*kinesis.EnhancedMonitoringOutput, error) {
	fake.enableEnhancedMonitoringMutex.Lock()
	ret, specificReturn := fake.enableEnhancedMonitoringReturnsOnCall[len(fake.enableEnhancedMonitoringArgsForCall)]
	fake.enableEnhancedMonitoringArgsForCall = append(fake.enableEnhancedMonitoringArgsForCall, struct {
		arg1 *kinesis.EnableEnhancedMonitoringInput
	}{arg1})
	stub := fake.EnableEnhancedMonitoringStub
	fakeReturns := fake.enableEnhancedMonitoringReturns
	fake.recordInvocation("EnableEnhancedMonitoring", []interface{}{arg1})
	fake.enableEnhancedMonitoringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringCallCount() int {
	fake.enableEnhancedMonitoringMutex.RLock()
	defer fake.enableEnhancedMonitoringMutex.RUnlock()
	return len(fake.enableEnhancedMonitoringArgsForCall)
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringCalls(stub func(*kinesis.EnableEnhancedMonitoringInput) (*kinesis.EnhancedMonitoringOutput, error)) {
	fake.enableEnhancedMonitoringMutex.Lock()
	defer fake.enableEnhancedMonitoringMutex.Unlock()
	fake.EnableEnhancedMonitoringStub = stub
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringArgsForCall(i int) *kinesis.EnableEnhancedMonitoringInput {
	fake.enableEnhancedMonitoringMutex.RLock()
	defer fake.enableEnhancedMonitoringMutex.RUnlock()
	argsForCall := fake.enableEnhancedMonitoringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringReturns(result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.enableEnhancedMonitoringMutex.Lock()
	defer fake.enableEnhancedMonitoringMutex.Unlock()
	fake.EnableEnhancedMonitoringStub = nil
	fake.enableEnhancedMonitoringReturns = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringReturnsOnCall(i int, result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.enableEnhancedMonitoringMutex.Lock()
	defer fake.enableEnhancedMonitoringMutex.Unlock()
	fake.EnableEnhancedMonitoringStub = nil
	if fake.enableEnhancedMonitoringReturnsOnCall == nil {
		fake.enableEnhancedMonitoringReturnsOnCall = make(map[int]struct {
			result1 *kinesis.EnhancedMonitoringOutput
			result2 error
		})
	}
	fake.enableEnhancedMonitoringReturnsOnCall[i] = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringRequest(arg1 *kinesis.EnableEnhancedMonitoringInput) (*request.Request, *kinesis.EnhancedMonitoringOutput) {
	fake.enableEnhancedMonitoringRequestMutex.Lock()
	ret, specificReturn := fake.enableEnhancedMonitoringRequestReturnsOnCall[len(fake.enableEnhancedMonitoringRequestArgsForCall)]
	fake.enableEnhancedMonitoringRequestArgsForCall = append(fake.enableEnhancedMonitoringRequestArgsForCall, struct {
		arg1 *kinesis.EnableEnhancedMonitoringInput
	}{arg1})
	stub := fake.EnableEnhancedMonitoringRequestStub
	fakeReturns := fake.enableEnhancedMonitoringRequestReturns
	fake.recordInvocation("EnableEnhancedMonitoringRequest", []interface{}{arg1})
	fake.enableEnhancedMonitoringRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringRequestCallCount() int {
	fake.enableEnhancedMonitoringRequestMutex.RLock()
	defer fake.enableEnhancedMonitoringRequestMutex.RUnlock()
	return len(fake.enableEnhancedMonitoringRequestArgsForCall)
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringRequestCalls(stub func(*kinesis.EnableEnhancedMonitoringInput) (*request.Request, *kinesis.EnhancedMonitoringOutput)) {
	fake.enableEnhancedMonitoringRequestMutex.Lock()
	defer fake.enableEnhancedMonitoringRequestMutex.Unlock()
	fake.EnableEnhancedMonitoringRequestStub = stub
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringRequestArgsForCall(i int) *kinesis.EnableEnhancedMonitoringInput {
	fake.enableEnhancedMonitoringRequestMutex.RLock()
	defer fake.enableEnhancedMonitoringRequestMutex.RUnlock()
	argsForCall := fake.enableEnhancedMonitoringRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringRequestReturns(result1 *request.Request, result2 *kinesis.EnhancedMonitoringOutput) {
	fake.enableEnhancedMonitoringRequestMutex.Lock()
	defer fake.enableEnhancedMonitoringRequestMutex.Unlock()
	fake.EnableEnhancedMonitoringRequestStub = nil
	fake.enableEnhancedMonitoringRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.EnhancedMonitoringOutput) {
	fake.enableEnhancedMonitoringRequestMutex.Lock()
	defer fake.enableEnhancedMonitoringRequestMutex.Unlock()
	fake.EnableEnhancedMonitoringRequestStub = nil
	if fake.enableEnhancedMonitoringRequestReturnsOnCall == nil {
		fake.enableEnhancedMonitoringRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.EnhancedMonitoringOutput
		})
	}
	fake.enableEnhancedMonitoringRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.EnhancedMonitoringOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringWithContext(arg1 context.Context, arg2 *kinesis.EnableEnhancedMonitoringInput, arg3 ...request.Option) (*kinesis.EnhancedMonitoringOutput, error) {
	fake.enableEnhancedMonitoringWithContextMutex.Lock()
	ret, specificReturn := fake.enableEnhancedMonitoringWithContextReturnsOnCall[len(fake.enableEnhancedMonitoringWithContextArgsForCall)]
	fake.enableEnhancedMonitoringWithContextArgsForCall = append(fake.enableEnhancedMonitoringWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.EnableEnhancedMonitoringInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.EnableEnhancedMonitoringWithContextStub
	fakeReturns := fake.enableEnhancedMonitoringWithContextReturns
	fake.recordInvocation("EnableEnhancedMonitoringWithContext", []interface{}{arg1, arg2, arg3})
	fake.enableEnhancedMonitoringWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringWithContextCallCount() int {
	fake.enableEnhancedMonitoringWithContextMutex.RLock()
	defer fake.enableEnhancedMonitoringWithContextMutex.RUnlock()
	return len(fake.enableEnhancedMonitoringWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringWithContextCalls(stub func(context.Context, *kinesis.EnableEnhancedMonitoringInput, ...request.Option) (*kinesis.EnhancedMonitoringOutput, error)) {
	fake.enableEnhancedMonitoringWithContextMutex.Lock()
	defer fake.enableEnhancedMonitoringWithContextMutex.Unlock()
	fake.EnableEnhancedMonitoringWithContextStub = stub
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringWithContextArgsForCall(i int) (context.Context, *kinesis.EnableEnhancedMonitoringInput, []request.Option) {
	fake.enableEnhancedMonitoringWithContextMutex.RLock()
	defer fake.enableEnhancedMonitoringWithContextMutex.RUnlock()
	argsForCall := fake.enableEnhancedMonitoringWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringWithContextReturns(result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.enableEnhancedMonitoringWithContextMutex.Lock()
	defer fake.enableEnhancedMonitoringWithContextMutex.Unlock()
	fake.EnableEnhancedMonitoringWithContextStub = nil
	fake.enableEnhancedMonitoringWithContextReturns = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) EnableEnhancedMonitoringWithContextReturnsOnCall(i int, result1 *kinesis.EnhancedMonitoringOutput, result2 error) {
	fake.enableEnhancedMonitoringWithContextMutex.Lock()
	defer fake.enableEnhancedMonitoringWithContextMutex.Unlock()
	fake.EnableEnhancedMonitoringWithContextStub = nil
	if fake.enableEnhancedMonitoringWithContextReturnsOnCall == nil {
		fake.enableEnhancedMonitoringWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.EnhancedMonitoringOutput
			result2 error
		})
	}
	fake.enableEnhancedMonitoringWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.EnhancedMonitoringOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetRecords(arg1 *kinesis.GetRecordsInput) (*kinesis.GetRecordsOutput, error) {
	fake.getRecordsMutex.Lock()
	ret, specificReturn := fake.getRecordsReturnsOnCall[len(fake.getRecordsArgsForCall)]
	fake.getRecordsArgsForCall = append(fake.getRecordsArgsForCall, struct {
		arg1 *kinesis.GetRecordsInput
	}{arg1})
	stub := fake.GetRecordsStub
	fakeReturns := fake.getRecordsReturns
	fake.recordInvocation("GetRecords", []interface{}{arg1})
	fake.getRecordsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) GetRecordsCallCount() int {
	fake.getRecordsMutex.RLock()
	defer fake.getRecordsMutex.RUnlock()
	return len(fake.getRecordsArgsForCall)
}

func (fake *FakeKinesisAPI) GetRecordsCalls(stub func(*kinesis.GetRecordsInput) (*kinesis.GetRecordsOutput, error)) {
	fake.getRecordsMutex.Lock()
	defer fake.getRecordsMutex.Unlock()
	fake.GetRecordsStub = stub
}

func (fake *FakeKinesisAPI) GetRecordsArgsForCall(i int) *kinesis.GetRecordsInput {
	fake.getRecordsMutex.RLock()
	defer fake.getRecordsMutex.RUnlock()
	argsForCall := fake.getRecordsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) GetRecordsReturns(result1 *kinesis.GetRecordsOutput, result2 error) {
	fake.getRecordsMutex.Lock()
	defer fake.getRecordsMutex.Unlock()
	fake.GetRecordsStub = nil
	fake.getRecordsReturns = struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetRecordsReturnsOnCall(i int, result1 *kinesis.GetRecordsOutput, result2 error) {
	fake.getRecordsMutex.Lock()
	defer fake.getRecordsMutex.Unlock()
	fake.GetRecordsStub = nil
	if fake.getRecordsReturnsOnCall == nil {
		fake.getRecordsReturnsOnCall = make(map[int]struct {
			result1 *kinesis.GetRecordsOutput
			result2 error
		})
	}
	fake.getRecordsReturnsOnCall[i] = struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetRecordsRequest(arg1 *kinesis.GetRecordsInput) (*request.Request, *kinesis.GetRecordsOutput) {
	fake.getRecordsRequestMutex.Lock()
	ret, specificReturn := fake.getRecordsRequestReturnsOnCall[len(fake.getRecordsRequestArgsForCall)]
	fake.getRecordsRequestArgsForCall = append(fake.getRecordsRequestArgsForCall, struct {
		arg1 *kinesis.GetRecordsInput
	}{arg1})
	stub := fake.GetRecordsRequestStub
	fakeReturns := fake.getRecordsRequestReturns
	fake.recordInvocation("GetRecordsRequest", []interface{}{arg1})
	fake.getRecordsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) GetRecordsRequestCallCount() int {
	fake.getRecordsRequestMutex.RLock()
	defer fake.getRecordsRequestMutex.RUnlock()
	return len(fake.getRecordsRequestArgsForCall)
}

func (fake *FakeKinesisAPI) GetRecordsRequestCalls(stub func(*kinesis.GetRecordsInput) (*request.Request, *kinesis.GetRecordsOutput)) {
	fake.getRecordsRequestMutex.Lock()
	defer fake.getRecordsRequestMutex.Unlock()
	fake.GetRecordsRequestStub = stub
}

func (fake *FakeKinesisAPI) GetRecordsRequestArgsForCall(i int) *kinesis.GetRecordsInput {
	fake.getRecordsRequestMutex.RLock()
	defer fake.getRecordsRequestMutex.RUnlock()
	argsForCall := fake.getRecordsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) GetRecordsRequestReturns(result1 *request.Request, result2 *kinesis.GetRecordsOutput) {
	fake.getRecordsRequestMutex.Lock()
	defer fake.getRecordsRequestMutex.Unlock()
	fake.GetRecordsRequestStub = nil
	fake.getRecordsRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.GetRecordsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetRecordsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.GetRecordsOutput) {
	fake.getRecordsRequestMutex.Lock()
	defer fake.getRecordsRequestMutex.Unlock()
	fake.GetRecordsRequestStub = nil
	if fake.getRecordsRequestReturnsOnCall == nil {
		fake.getRecordsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.GetRecordsOutput
		})
	}
	fake.getRecordsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.GetRecordsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetRecordsWithContext(arg1 context.Context, arg2 *kinesis.GetRecordsInput, arg3 ...request.Option) (*kinesis.GetRecordsOutput, error) {
	fake.getRecordsWithContextMutex.Lock()
	ret, specificReturn := fake.getRecordsWithContextReturnsOnCall[len(fake.getRecordsWithContextArgsForCall)]
	fake.getRecordsWithContextArgsForCall = append(fake.getRecordsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.GetRecordsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GetRecordsWithContextStub
	fakeReturns := fake.getRecordsWithContextReturns
	fake.recordInvocation("GetRecordsWithContext", []interface{}{arg1, arg2, arg3})
	fake.getRecordsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) GetRecordsWithContextCallCount() int {
	fake.getRecordsWithContextMutex.RLock()
	defer fake.getRecordsWithContextMutex.RUnlock()
	return len(fake.getRecordsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) GetRecordsWithContextCalls(stub func(context.Context, *kinesis.GetRecordsInput, ...request.Option) (*kinesis.GetRecordsOutput, error)) {
	fake.getRecordsWithContextMutex.Lock()
	defer fake.getRecordsWithContextMutex.Unlock()
	fake.GetRecordsWithContextStub = stub
}

func (fake *FakeKinesisAPI) GetRecordsWithContextArgsForCall(i int) (context.Context, *kinesis.GetRecordsInput, []request.Option) {
	fake.getRecordsWithContextMutex.RLock()
	defer fake.getRecordsWithContextMutex.RUnlock()
	argsForCall := fake.getRecordsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) GetRecordsWithContextReturns(result1 *kinesis.GetRecordsOutput, result2 error) {
	fake.getRecordsWithContextMutex.Lock()
	defer fake.getRecordsWithContextMutex.Unlock()
	fake.GetRecordsWithContextStub = nil
	fake.getRecordsWithContextReturns = struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetRecordsWithContextReturnsOnCall(i int, result1 *kinesis.GetRecordsOutput, result2 error) {
	fake.getRecordsWithContextMutex.Lock()
	defer fake.getRecordsWithContextMutex.Unlock()
	fake.GetRecordsWithContextStub = nil
	if fake.getRecordsWithContextReturnsOnCall == nil {
		fake.getRecordsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.GetRecordsOutput
			result2 error
		})
	}
	fake.getRecordsWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.GetRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetShardIterator(arg1 *kinesis.GetShardIteratorInput) (*kinesis.GetShardIteratorOutput, error) {
	fake.getShardIteratorMutex.Lock()
	ret, specificReturn := fake.getShardIteratorReturnsOnCall[len(fake.getShardIteratorArgsForCall)]
	fake.getShardIteratorArgsForCall = append(fake.getShardIteratorArgsForCall, struct {
		arg1 *kinesis.GetShardIteratorInput
	}{arg1})
	stub := fake.GetShardIteratorStub
	fakeReturns := fake.getShardIteratorReturns
	fake.recordInvocation("GetShardIterator", []interface{}{arg1})
	fake.getShardIteratorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) GetShardIteratorCallCount() int {
	fake.getShardIteratorMutex.RLock()
	defer fake.getShardIteratorMutex.RUnlock()
	return len(fake.getShardIteratorArgsForCall)
}

func (fake *FakeKinesisAPI) GetShardIteratorCalls(stub func(*kinesis.GetShardIteratorInput) (*kinesis.GetShardIteratorOutput, error)) {
	fake.getShardIteratorMutex.Lock()
	defer fake.getShardIteratorMutex.Unlock()
	fake.GetShardIteratorStub = stub
}

func (fake *FakeKinesisAPI) GetShardIteratorArgsForCall(i int) *kinesis.GetShardIteratorInput {
	fake.getShardIteratorMutex.RLock()
	defer fake.getShardIteratorMutex.RUnlock()
	argsForCall := fake.getShardIteratorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) GetShardIteratorReturns(result1 *kinesis.GetShardIteratorOutput, result2 error) {
	fake.getShardIteratorMutex.Lock()
	defer fake.getShardIteratorMutex.Unlock()
	fake.GetShardIteratorStub = nil
	fake.getShardIteratorReturns = struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetShardIteratorReturnsOnCall(i int, result1 *kinesis.GetShardIteratorOutput, result2 error) {
	fake.getShardIteratorMutex.Lock()
	defer fake.getShardIteratorMutex.Unlock()
	fake.GetShardIteratorStub = nil
	if fake.getShardIteratorReturnsOnCall == nil {
		fake.getShardIteratorReturnsOnCall = make(map[int]struct {
			result1 *kinesis.GetShardIteratorOutput
			result2 error
		})
	}
	fake.getShardIteratorReturnsOnCall[i] = struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetShardIteratorRequest(arg1 *kinesis.GetShardIteratorInput) (*request.Request, *kinesis.GetShardIteratorOutput) {
	fake.getShardIteratorRequestMutex.Lock()
	ret, specificReturn := fake.getShardIteratorRequestReturnsOnCall[len(fake.getShardIteratorRequestArgsForCall)]
	fake.getShardIteratorRequestArgsForCall = append(fake.getShardIteratorRequestArgsForCall, struct {
		arg1 *kinesis.GetShardIteratorInput
	}{arg1})
	stub := fake.GetShardIteratorRequestStub
	fakeReturns := fake.getShardIteratorRequestReturns
	fake.recordInvocation("GetShardIteratorRequest", []interface{}{arg1})
	fake.getShardIteratorRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) GetShardIteratorRequestCallCount() int {
	fake.getShardIteratorRequestMutex.RLock()
	defer fake.getShardIteratorRequestMutex.RUnlock()
	return len(fake.getShardIteratorRequestArgsForCall)
}

func (fake *FakeKinesisAPI) GetShardIteratorRequestCalls(stub func(*kinesis.GetShardIteratorInput) (*request.Request, *kinesis.GetShardIteratorOutput)) {
	fake.getShardIteratorRequestMutex.Lock()
	defer fake.getShardIteratorRequestMutex.Unlock()
	fake.GetShardIteratorRequestStub = stub
}

func (fake *FakeKinesisAPI) GetShardIteratorRequestArgsForCall(i int) *kinesis.GetShardIteratorInput {
	fake.getShardIteratorRequestMutex.RLock()
	defer fake.getShardIteratorRequestMutex.RUnlock()
	argsForCall := fake.getShardIteratorRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) GetShardIteratorRequestReturns(result1 *request.Request, result2 *kinesis.GetShardIteratorOutput) {
	fake.getShardIteratorRequestMutex.Lock()
	defer fake.getShardIteratorRequestMutex.Unlock()
	fake.GetShardIteratorRequestStub = nil
	fake.getShardIteratorRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.GetShardIteratorOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetShardIteratorRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.GetShardIteratorOutput) {
	fake.getShardIteratorRequestMutex.Lock()
	defer fake.getShardIteratorRequestMutex.Unlock()
	fake.GetShardIteratorRequestStub = nil
	if fake.getShardIteratorRequestReturnsOnCall == nil {
		fake.getShardIteratorRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.GetShardIteratorOutput
		})
	}
	fake.getShardIteratorRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.GetShardIteratorOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetShardIteratorWithContext(arg1 context.Context, arg2 *kinesis.GetShardIteratorInput, arg3 ...request.Option) (*kinesis.GetShardIteratorOutput, error) {
	fake.getShardIteratorWithContextMutex.Lock()
	ret, specificReturn := fake.getShardIteratorWithContextReturnsOnCall[len(fake.getShardIteratorWithContextArgsForCall)]
	fake.getShardIteratorWithContextArgsForCall = append(fake.getShardIteratorWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.GetShardIteratorInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.GetShardIteratorWithContextStub
	fakeReturns := fake.getShardIteratorWithContextReturns
	fake.recordInvocation("GetShardIteratorWithContext", []interface{}{arg1, arg2, arg3})
	fake.getShardIteratorWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) GetShardIteratorWithContextCallCount() int {
	fake.getShardIteratorWithContextMutex.RLock()
	defer fake.getShardIteratorWithContextMutex.RUnlock()
	return len(fake.getShardIteratorWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) GetShardIteratorWithContextCalls(stub func(context.Context, *kinesis.GetShardIteratorInput, ...request.Option) (*kinesis.GetShardIteratorOutput, error)) {
	fake.getShardIteratorWithContextMutex.Lock()
	defer fake.getShardIteratorWithContextMutex.Unlock()
	fake.GetShardIteratorWithContextStub = stub
}

func (fake *FakeKinesisAPI) GetShardIteratorWithContextArgsForCall(i int) (context.Context, *kinesis.GetShardIteratorInput, []request.Option) {
	fake.getShardIteratorWithContextMutex.RLock()
	defer fake.getShardIteratorWithContextMutex.RUnlock()
	argsForCall := fake.getShardIteratorWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) GetShardIteratorWithContextReturns(result1 *kinesis.GetShardIteratorOutput, result2 error) {
	fake.getShardIteratorWithContextMutex.Lock()
	defer fake.getShardIteratorWithContextMutex.Unlock()
	fake.GetShardIteratorWithContextStub = nil
	fake.getShardIteratorWithContextReturns = struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) GetShardIteratorWithContextReturnsOnCall(i int, result1 *kinesis.GetShardIteratorOutput, result2 error) {
	fake.getShardIteratorWithContextMutex.Lock()
	defer fake.getShardIteratorWithContextMutex.Unlock()
	fake.GetShardIteratorWithContextStub = nil
	if fake.getShardIteratorWithContextReturnsOnCall == nil {
		fake.getShardIteratorWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.GetShardIteratorOutput
			result2 error
		})
	}
	fake.getShardIteratorWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.GetShardIteratorOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriod(arg1 *kinesis.IncreaseStreamRetentionPeriodInput) (*kinesis.IncreaseStreamRetentionPeriodOutput, error) {
	fake.increaseStreamRetentionPeriodMutex.Lock()
	ret, specificReturn := fake.increaseStreamRetentionPeriodReturnsOnCall[len(fake.increaseStreamRetentionPeriodArgsForCall)]
	fake.increaseStreamRetentionPeriodArgsForCall = append(fake.increaseStreamRetentionPeriodArgsForCall, struct {
		arg1 *kinesis.IncreaseStreamRetentionPeriodInput
	}{arg1})
	stub := fake.IncreaseStreamRetentionPeriodStub
	fakeReturns := fake.increaseStreamRetentionPeriodReturns
	fake.recordInvocation("IncreaseStreamRetentionPeriod", []interface{}{arg1})
	fake.increaseStreamRetentionPeriodMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodCallCount() int {
	fake.increaseStreamRetentionPeriodMutex.RLock()
	defer fake.increaseStreamRetentionPeriodMutex.RUnlock()
	return len(fake.increaseStreamRetentionPeriodArgsForCall)
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodCalls(stub func(*kinesis.IncreaseStreamRetentionPeriodInput) (*kinesis.IncreaseStreamRetentionPeriodOutput, error)) {
	fake.increaseStreamRetentionPeriodMutex.Lock()
	defer fake.increaseStreamRetentionPeriodMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodStub = stub
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodArgsForCall(i int) *kinesis.IncreaseStreamRetentionPeriodInput {
	fake.increaseStreamRetentionPeriodMutex.RLock()
	defer fake.increaseStreamRetentionPeriodMutex.RUnlock()
	argsForCall := fake.increaseStreamRetentionPeriodArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodReturns(result1 *kinesis.IncreaseStreamRetentionPeriodOutput, result2 error) {
	fake.increaseStreamRetentionPeriodMutex.Lock()
	defer fake.increaseStreamRetentionPeriodMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodStub = nil
	fake.increaseStreamRetentionPeriodReturns = struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodReturnsOnCall(i int, result1 *kinesis.IncreaseStreamRetentionPeriodOutput, result2 error) {
	fake.increaseStreamRetentionPeriodMutex.Lock()
	defer fake.increaseStreamRetentionPeriodMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodStub = nil
	if fake.increaseStreamRetentionPeriodReturnsOnCall == nil {
		fake.increaseStreamRetentionPeriodReturnsOnCall = make(map[int]struct {
			result1 *kinesis.IncreaseStreamRetentionPeriodOutput
			result2 error
		})
	}
	fake.increaseStreamRetentionPeriodReturnsOnCall[i] = struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodRequest(arg1 *kinesis.IncreaseStreamRetentionPeriodInput) (*request.Request, *kinesis.IncreaseStreamRetentionPeriodOutput) {
	fake.increaseStreamRetentionPeriodRequestMutex.Lock()
	ret, specificReturn := fake.increaseStreamRetentionPeriodRequestReturnsOnCall[len(fake.increaseStreamRetentionPeriodRequestArgsForCall)]
	fake.increaseStreamRetentionPeriodRequestArgsForCall = append(fake.increaseStreamRetentionPeriodRequestArgsForCall, struct {
		arg1 *kinesis.IncreaseStreamRetentionPeriodInput
	}{arg1})
	stub := fake.IncreaseStreamRetentionPeriodRequestStub
	fakeReturns := fake.increaseStreamRetentionPeriodRequestReturns
	fake.recordInvocation("IncreaseStreamRetentionPeriodRequest", []interface{}{arg1})
	fake.increaseStreamRetentionPeriodRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodRequestCallCount() int {
	fake.increaseStreamRetentionPeriodRequestMutex.RLock()
	defer fake.increaseStreamRetentionPeriodRequestMutex.RUnlock()
	return len(fake.increaseStreamRetentionPeriodRequestArgsForCall)
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodRequestCalls(stub func(*kinesis.IncreaseStreamRetentionPeriodInput) (*request.Request, *kinesis.IncreaseStreamRetentionPeriodOutput)) {
	fake.increaseStreamRetentionPeriodRequestMutex.Lock()
	defer fake.increaseStreamRetentionPeriodRequestMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodRequestStub = stub
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodRequestArgsForCall(i int) *kinesis.IncreaseStreamRetentionPeriodInput {
	fake.increaseStreamRetentionPeriodRequestMutex.RLock()
	defer fake.increaseStreamRetentionPeriodRequestMutex.RUnlock()
	argsForCall := fake.increaseStreamRetentionPeriodRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodRequestReturns(result1 *request.Request, result2 *kinesis.IncreaseStreamRetentionPeriodOutput) {
	fake.increaseStreamRetentionPeriodRequestMutex.Lock()
	defer fake.increaseStreamRetentionPeriodRequestMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodRequestStub = nil
	fake.increaseStreamRetentionPeriodRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.IncreaseStreamRetentionPeriodOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.IncreaseStreamRetentionPeriodOutput) {
	fake.increaseStreamRetentionPeriodRequestMutex.Lock()
	defer fake.increaseStreamRetentionPeriodRequestMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodRequestStub = nil
	if fake.increaseStreamRetentionPeriodRequestReturnsOnCall == nil {
		fake.increaseStreamRetentionPeriodRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.IncreaseStreamRetentionPeriodOutput
		})
	}
	fake.increaseStreamRetentionPeriodRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.IncreaseStreamRetentionPeriodOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodWithContext(arg1 context.Context, arg2 *kinesis.IncreaseStreamRetentionPeriodInput, arg3 ...request.Option) (*kinesis.IncreaseStreamRetentionPeriodOutput, error) {
	fake.increaseStreamRetentionPeriodWithContextMutex.Lock()
	ret, specificReturn := fake.increaseStreamRetentionPeriodWithContextReturnsOnCall[len(fake.increaseStreamRetentionPeriodWithContextArgsForCall)]
	fake.increaseStreamRetentionPeriodWithContextArgsForCall = append(fake.increaseStreamRetentionPeriodWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.IncreaseStreamRetentionPeriodInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.IncreaseStreamRetentionPeriodWithContextStub
	fakeReturns := fake.increaseStreamRetentionPeriodWithContextReturns
	fake.recordInvocation("IncreaseStreamRetentionPeriodWithContext", []interface{}{arg1, arg2, arg3})
	fake.increaseStreamRetentionPeriodWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodWithContextCallCount() int {
	fake.increaseStreamRetentionPeriodWithContextMutex.RLock()
	defer fake.increaseStreamRetentionPeriodWithContextMutex.RUnlock()
	return len(fake.increaseStreamRetentionPeriodWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodWithContextCalls(stub func(context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, ...request.Option) (*kinesis.IncreaseStreamRetentionPeriodOutput, error)) {
	fake.increaseStreamRetentionPeriodWithContextMutex.Lock()
	defer fake.increaseStreamRetentionPeriodWithContextMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodWithContextStub = stub
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodWithContextArgsForCall(i int) (context.Context, *kinesis.IncreaseStreamRetentionPeriodInput, []request.Option) {
	fake.increaseStreamRetentionPeriodWithContextMutex.RLock()
	defer fake.increaseStreamRetentionPeriodWithContextMutex.RUnlock()
	argsForCall := fake.increaseStreamRetentionPeriodWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodWithContextReturns(result1 *kinesis.IncreaseStreamRetentionPeriodOutput, result2 error) {
	fake.increaseStreamRetentionPeriodWithContextMutex.Lock()
	defer fake.increaseStreamRetentionPeriodWithContextMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodWithContextStub = nil
	fake.increaseStreamRetentionPeriodWithContextReturns = struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) IncreaseStreamRetentionPeriodWithContextReturnsOnCall(i int, result1 *kinesis.IncreaseStreamRetentionPeriodOutput, result2 error) {
	fake.increaseStreamRetentionPeriodWithContextMutex.Lock()
	defer fake.increaseStreamRetentionPeriodWithContextMutex.Unlock()
	fake.IncreaseStreamRetentionPeriodWithContextStub = nil
	if fake.increaseStreamRetentionPeriodWithContextReturnsOnCall == nil {
		fake.increaseStreamRetentionPeriodWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.IncreaseStreamRetentionPeriodOutput
			result2 error
		})
	}
	fake.increaseStreamRetentionPeriodWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.IncreaseStreamRetentionPeriodOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListShards(arg1 *kinesis.ListShardsInput) (*kinesis.ListShardsOutput, error) {
	fake.listShardsMutex.Lock()
	ret, specificReturn := fake.listShardsReturnsOnCall[len(fake.listShardsArgsForCall)]
	fake.listShardsArgsForCall = append(fake.listShardsArgsForCall, struct {
		arg1 *kinesis.ListShardsInput
	}{arg1})
	stub := fake.ListShardsStub
	fakeReturns := fake.listShardsReturns
	fake.recordInvocation("ListShards", []interface{}{arg1})
	fake.listShardsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListShardsCallCount() int {
	fake.listShardsMutex.RLock()
	defer fake.listShardsMutex.RUnlock()
	return len(fake.listShardsArgsForCall)
}

func (fake *FakeKinesisAPI) ListShardsCalls(stub func(*kinesis.ListShardsInput) (*kinesis.ListShardsOutput, error)) {
	fake.listShardsMutex.Lock()
	defer fake.listShardsMutex.Unlock()
	fake.ListShardsStub = stub
}

func (fake *FakeKinesisAPI) ListShardsArgsForCall(i int) *kinesis.ListShardsInput {
	fake.listShardsMutex.RLock()
	defer fake.listShardsMutex.RUnlock()
	argsForCall := fake.listShardsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListShardsReturns(result1 *kinesis.ListShardsOutput, result2 error) {
	fake.listShardsMutex.Lock()
	defer fake.listShardsMutex.Unlock()
	fake.ListShardsStub = nil
	fake.listShardsReturns = struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListShardsReturnsOnCall(i int, result1 *kinesis.ListShardsOutput, result2 error) {
	fake.listShardsMutex.Lock()
	defer fake.listShardsMutex.Unlock()
	fake.ListShardsStub = nil
	if fake.listShardsReturnsOnCall == nil {
		fake.listShardsReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListShardsOutput
			result2 error
		})
	}
	fake.listShardsReturnsOnCall[i] = struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListShardsRequest(arg1 *kinesis.ListShardsInput) (*request.Request, *kinesis.ListShardsOutput) {
	fake.listShardsRequestMutex.Lock()
	ret, specificReturn := fake.listShardsRequestReturnsOnCall[len(fake.listShardsRequestArgsForCall)]
	fake.listShardsRequestArgsForCall = append(fake.listShardsRequestArgsForCall, struct {
		arg1 *kinesis.ListShardsInput
	}{arg1})
	stub := fake.ListShardsRequestStub
	fakeReturns := fake.listShardsRequestReturns
	fake.recordInvocation("ListShardsRequest", []interface{}{arg1})
	fake.listShardsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListShardsRequestCallCount() int {
	fake.listShardsRequestMutex.RLock()
	defer fake.listShardsRequestMutex.RUnlock()
	return len(fake.listShardsRequestArgsForCall)
}

func (fake *FakeKinesisAPI) ListShardsRequestCalls(stub func(*kinesis.ListShardsInput) (*request.Request, *kinesis.ListShardsOutput)) {
	fake.listShardsRequestMutex.Lock()
	defer fake.listShardsRequestMutex.Unlock()
	fake.ListShardsRequestStub = stub
}

func (fake *FakeKinesisAPI) ListShardsRequestArgsForCall(i int) *kinesis.ListShardsInput {
	fake.listShardsRequestMutex.RLock()
	defer fake.listShardsRequestMutex.RUnlock()
	argsForCall := fake.listShardsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListShardsRequestReturns(result1 *request.Request, result2 *kinesis.ListShardsOutput) {
	fake.listShardsRequestMutex.Lock()
	defer fake.listShardsRequestMutex.Unlock()
	fake.ListShardsRequestStub = nil
	fake.listShardsRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.ListShardsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListShardsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.ListShardsOutput) {
	fake.listShardsRequestMutex.Lock()
	defer fake.listShardsRequestMutex.Unlock()
	fake.ListShardsRequestStub = nil
	if fake.listShardsRequestReturnsOnCall == nil {
		fake.listShardsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.ListShardsOutput
		})
	}
	fake.listShardsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.ListShardsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListShardsWithContext(arg1 context.Context, arg2 *kinesis.ListShardsInput, arg3 ...request.Option) (*kinesis.ListShardsOutput, error) {
	fake.listShardsWithContextMutex.Lock()
	ret, specificReturn := fake.listShardsWithContextReturnsOnCall[len(fake.listShardsWithContextArgsForCall)]
	fake.listShardsWithContextArgsForCall = append(fake.listShardsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.ListShardsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListShardsWithContextStub
	fakeReturns := fake.listShardsWithContextReturns
	fake.recordInvocation("ListShardsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listShardsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListShardsWithContextCallCount() int {
	fake.listShardsWithContextMutex.RLock()
	defer fake.listShardsWithContextMutex.RUnlock()
	return len(fake.listShardsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) ListShardsWithContextCalls(stub func(context.Context, *kinesis.ListShardsInput, ...request.Option) (*kinesis.ListShardsOutput, error)) {
	fake.listShardsWithContextMutex.Lock()
	defer fake.listShardsWithContextMutex.Unlock()
	fake.ListShardsWithContextStub = stub
}

func (fake *FakeKinesisAPI) ListShardsWithContextArgsForCall(i int) (context.Context, *kinesis.ListShardsInput, []request.Option) {
	fake.listShardsWithContextMutex.RLock()
	defer fake.listShardsWithContextMutex.RUnlock()
	argsForCall := fake.listShardsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) ListShardsWithContextReturns(result1 *kinesis.ListShardsOutput, result2 error) {
	fake.listShardsWithContextMutex.Lock()
	defer fake.listShardsWithContextMutex.Unlock()
	fake.ListShardsWithContextStub = nil
	fake.listShardsWithContextReturns = struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListShardsWithContextReturnsOnCall(i int, result1 *kinesis.ListShardsOutput, result2 error) {
	fake.listShardsWithContextMutex.Lock()
	defer fake.listShardsWithContextMutex.Unlock()
	fake.ListShardsWithContextStub = nil
	if fake.listShardsWithContextReturnsOnCall == nil {
		fake.listShardsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListShardsOutput
			result2 error
		})
	}
	fake.listShardsWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.ListShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamConsumers(arg1 *kinesis.ListStreamConsumersInput) (*kinesis.ListStreamConsumersOutput, error) {
	fake.listStreamConsumersMutex.Lock()
	ret, specificReturn := fake.listStreamConsumersReturnsOnCall[len(fake.listStreamConsumersArgsForCall)]
	fake.listStreamConsumersArgsForCall = append(fake.listStreamConsumersArgsForCall, struct {
		arg1 *kinesis.ListStreamConsumersInput
	}{arg1})
	stub := fake.ListStreamConsumersStub
	fakeReturns := fake.listStreamConsumersReturns
	fake.recordInvocation("ListStreamConsumers", []interface{}{arg1})
	fake.listStreamConsumersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListStreamConsumersCallCount() int {
	fake.listStreamConsumersMutex.RLock()
	defer fake.listStreamConsumersMutex.RUnlock()
	return len(fake.listStreamConsumersArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamConsumersCalls(stub func(*kinesis.ListStreamConsumersInput) (*kinesis.ListStreamConsumersOutput, error)) {
	fake.listStreamConsumersMutex.Lock()
	defer fake.listStreamConsumersMutex.Unlock()
	fake.ListStreamConsumersStub = stub
}

func (fake *FakeKinesisAPI) ListStreamConsumersArgsForCall(i int) *kinesis.ListStreamConsumersInput {
	fake.listStreamConsumersMutex.RLock()
	defer fake.listStreamConsumersMutex.RUnlock()
	argsForCall := fake.listStreamConsumersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListStreamConsumersReturns(result1 *kinesis.ListStreamConsumersOutput, result2 error) {
	fake.listStreamConsumersMutex.Lock()
	defer fake.listStreamConsumersMutex.Unlock()
	fake.ListStreamConsumersStub = nil
	fake.listStreamConsumersReturns = struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamConsumersReturnsOnCall(i int, result1 *kinesis.ListStreamConsumersOutput, result2 error) {
	fake.listStreamConsumersMutex.Lock()
	defer fake.listStreamConsumersMutex.Unlock()
	fake.ListStreamConsumersStub = nil
	if fake.listStreamConsumersReturnsOnCall == nil {
		fake.listStreamConsumersReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListStreamConsumersOutput
			result2 error
		})
	}
	fake.listStreamConsumersReturnsOnCall[i] = struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamConsumersPages(arg1 *kinesis.ListStreamConsumersInput, arg2 func(*kinesis.ListStreamConsumersOutput, bool) bool) error {
	fake.listStreamConsumersPagesMutex.Lock()
	ret, specificReturn := fake.listStreamConsumersPagesReturnsOnCall[len(fake.listStreamConsumersPagesArgsForCall)]
	fake.listStreamConsumersPagesArgsForCall = append(fake.listStreamConsumersPagesArgsForCall, struct {
		arg1 *kinesis.ListStreamConsumersInput
		arg2 func(*kinesis.ListStreamConsumersOutput, bool) bool
	}{arg1, arg2})
	stub := fake.ListStreamConsumersPagesStub
	fakeReturns := fake.listStreamConsumersPagesReturns
	fake.recordInvocation("ListStreamConsumersPages", []interface{}{arg1, arg2})
	fake.listStreamConsumersPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesCallCount() int {
	fake.listStreamConsumersPagesMutex.RLock()
	defer fake.listStreamConsumersPagesMutex.RUnlock()
	return len(fake.listStreamConsumersPagesArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesCalls(stub func(*kinesis.ListStreamConsumersInput, func(*kinesis.ListStreamConsumersOutput, bool) bool) error) {
	fake.listStreamConsumersPagesMutex.Lock()
	defer fake.listStreamConsumersPagesMutex.Unlock()
	fake.ListStreamConsumersPagesStub = stub
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesArgsForCall(i int) (*kinesis.ListStreamConsumersInput, func(*kinesis.ListStreamConsumersOutput, bool) bool) {
	fake.listStreamConsumersPagesMutex.RLock()
	defer fake.listStreamConsumersPagesMutex.RUnlock()
	argsForCall := fake.listStreamConsumersPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesReturns(result1 error) {
	fake.listStreamConsumersPagesMutex.Lock()
	defer fake.listStreamConsumersPagesMutex.Unlock()
	fake.ListStreamConsumersPagesStub = nil
	fake.listStreamConsumersPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesReturnsOnCall(i int, result1 error) {
	fake.listStreamConsumersPagesMutex.Lock()
	defer fake.listStreamConsumersPagesMutex.Unlock()
	fake.ListStreamConsumersPagesStub = nil
	if fake.listStreamConsumersPagesReturnsOnCall == nil {
		fake.listStreamConsumersPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listStreamConsumersPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesWithContext(arg1 context.Context, arg2 *kinesis.ListStreamConsumersInput, arg3 func(*kinesis.ListStreamConsumersOutput, bool) bool, arg4 ...request.Option) error {
	fake.listStreamConsumersPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listStreamConsumersPagesWithContextReturnsOnCall[len(fake.listStreamConsumersPagesWithContextArgsForCall)]
	fake.listStreamConsumersPagesWithContextArgsForCall = append(fake.listStreamConsumersPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamConsumersInput
		arg3 func(*kinesis.ListStreamConsumersOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListStreamConsumersPagesWithContextStub
	fakeReturns := fake.listStreamConsumersPagesWithContextReturns
	fake.recordInvocation("ListStreamConsumersPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listStreamConsumersPagesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesWithContextCallCount() int {
	fake.listStreamConsumersPagesWithContextMutex.RLock()
	defer fake.listStreamConsumersPagesWithContextMutex.RUnlock()
	return len(fake.listStreamConsumersPagesWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesWithContextCalls(stub func(context.Context, *kinesis.ListStreamConsumersInput, func(*kinesis.ListStreamConsumersOutput, bool) bool, ...request.Option) error) {
	fake.listStreamConsumersPagesWithContextMutex.Lock()
	defer fake.listStreamConsumersPagesWithContextMutex.Unlock()
	fake.ListStreamConsumersPagesWithContextStub = stub
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesWithContextArgsForCall(i int) (context.Context, *kinesis.ListStreamConsumersInput, func(*kinesis.ListStreamConsumersOutput, bool) bool, []request.Option) {
	fake.listStreamConsumersPagesWithContextMutex.RLock()
	defer fake.listStreamConsumersPagesWithContextMutex.RUnlock()
	argsForCall := fake.listStreamConsumersPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesWithContextReturns(result1 error) {
	fake.listStreamConsumersPagesWithContextMutex.Lock()
	defer fake.listStreamConsumersPagesWithContextMutex.Unlock()
	fake.ListStreamConsumersPagesWithContextStub = nil
	fake.listStreamConsumersPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamConsumersPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listStreamConsumersPagesWithContextMutex.Lock()
	defer fake.listStreamConsumersPagesWithContextMutex.Unlock()
	fake.ListStreamConsumersPagesWithContextStub = nil
	if fake.listStreamConsumersPagesWithContextReturnsOnCall == nil {
		fake.listStreamConsumersPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listStreamConsumersPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamConsumersRequest(arg1 *kinesis.ListStreamConsumersInput) (*request.Request, *kinesis.ListStreamConsumersOutput) {
	fake.listStreamConsumersRequestMutex.Lock()
	ret, specificReturn := fake.listStreamConsumersRequestReturnsOnCall[len(fake.listStreamConsumersRequestArgsForCall)]
	fake.listStreamConsumersRequestArgsForCall = append(fake.listStreamConsumersRequestArgsForCall, struct {
		arg1 *kinesis.ListStreamConsumersInput
	}{arg1})
	stub := fake.ListStreamConsumersRequestStub
	fakeReturns := fake.listStreamConsumersRequestReturns
	fake.recordInvocation("ListStreamConsumersRequest", []interface{}{arg1})
	fake.listStreamConsumersRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListStreamConsumersRequestCallCount() int {
	fake.listStreamConsumersRequestMutex.RLock()
	defer fake.listStreamConsumersRequestMutex.RUnlock()
	return len(fake.listStreamConsumersRequestArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamConsumersRequestCalls(stub func(*kinesis.ListStreamConsumersInput) (*request.Request, *kinesis.ListStreamConsumersOutput)) {
	fake.listStreamConsumersRequestMutex.Lock()
	defer fake.listStreamConsumersRequestMutex.Unlock()
	fake.ListStreamConsumersRequestStub = stub
}

func (fake *FakeKinesisAPI) ListStreamConsumersRequestArgsForCall(i int) *kinesis.ListStreamConsumersInput {
	fake.listStreamConsumersRequestMutex.RLock()
	defer fake.listStreamConsumersRequestMutex.RUnlock()
	argsForCall := fake.listStreamConsumersRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListStreamConsumersRequestReturns(result1 *request.Request, result2 *kinesis.ListStreamConsumersOutput) {
	fake.listStreamConsumersRequestMutex.Lock()
	defer fake.listStreamConsumersRequestMutex.Unlock()
	fake.ListStreamConsumersRequestStub = nil
	fake.listStreamConsumersRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.ListStreamConsumersOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamConsumersRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.ListStreamConsumersOutput) {
	fake.listStreamConsumersRequestMutex.Lock()
	defer fake.listStreamConsumersRequestMutex.Unlock()
	fake.ListStreamConsumersRequestStub = nil
	if fake.listStreamConsumersRequestReturnsOnCall == nil {
		fake.listStreamConsumersRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.ListStreamConsumersOutput
		})
	}
	fake.listStreamConsumersRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.ListStreamConsumersOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamConsumersWithContext(arg1 context.Context, arg2 *kinesis.ListStreamConsumersInput, arg3 ...request.Option) (*kinesis.ListStreamConsumersOutput, error) {
	fake.listStreamConsumersWithContextMutex.Lock()
	ret, specificReturn := fake.listStreamConsumersWithContextReturnsOnCall[len(fake.listStreamConsumersWithContextArgsForCall)]
	fake.listStreamConsumersWithContextArgsForCall = append(fake.listStreamConsumersWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamConsumersInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListStreamConsumersWithContextStub
	fakeReturns := fake.listStreamConsumersWithContextReturns
	fake.recordInvocation("ListStreamConsumersWithContext", []interface{}{arg1, arg2, arg3})
	fake.listStreamConsumersWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListStreamConsumersWithContextCallCount() int {
	fake.listStreamConsumersWithContextMutex.RLock()
	defer fake.listStreamConsumersWithContextMutex.RUnlock()
	return len(fake.listStreamConsumersWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamConsumersWithContextCalls(stub func(context.Context, *kinesis.ListStreamConsumersInput, ...request.Option) (*kinesis.ListStreamConsumersOutput, error)) {
	fake.listStreamConsumersWithContextMutex.Lock()
	defer fake.listStreamConsumersWithContextMutex.Unlock()
	fake.ListStreamConsumersWithContextStub = stub
}

func (fake *FakeKinesisAPI) ListStreamConsumersWithContextArgsForCall(i int) (context.Context, *kinesis.ListStreamConsumersInput, []request.Option) {
	fake.listStreamConsumersWithContextMutex.RLock()
	defer fake.listStreamConsumersWithContextMutex.RUnlock()
	argsForCall := fake.listStreamConsumersWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) ListStreamConsumersWithContextReturns(result1 *kinesis.ListStreamConsumersOutput, result2 error) {
	fake.listStreamConsumersWithContextMutex.Lock()
	defer fake.listStreamConsumersWithContextMutex.Unlock()
	fake.ListStreamConsumersWithContextStub = nil
	fake.listStreamConsumersWithContextReturns = struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamConsumersWithContextReturnsOnCall(i int, result1 *kinesis.ListStreamConsumersOutput, result2 error) {
	fake.listStreamConsumersWithContextMutex.Lock()
	defer fake.listStreamConsumersWithContextMutex.Unlock()
	fake.ListStreamConsumersWithContextStub = nil
	if fake.listStreamConsumersWithContextReturnsOnCall == nil {
		fake.listStreamConsumersWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListStreamConsumersOutput
			result2 error
		})
	}
	fake.listStreamConsumersWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.ListStreamConsumersOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreams(arg1 *kinesis.ListStreamsInput) (*kinesis.ListStreamsOutput, error) {
	fake.listStreamsMutex.Lock()
	ret, specificReturn := fake.listStreamsReturnsOnCall[len(fake.listStreamsArgsForCall)]
	fake.listStreamsArgsForCall = append(fake.listStreamsArgsForCall, struct {
		arg1 *kinesis.ListStreamsInput
	}{arg1})
	stub := fake.ListStreamsStub
	fakeReturns := fake.listStreamsReturns
	fake.recordInvocation("ListStreams", []interface{}{arg1})
	fake.listStreamsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListStreamsCallCount() int {
	fake.listStreamsMutex.RLock()
	defer fake.listStreamsMutex.RUnlock()
	return len(fake.listStreamsArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamsCalls(stub func(*kinesis.ListStreamsInput) (*kinesis.ListStreamsOutput, error)) {
	fake.listStreamsMutex.Lock()
	defer fake.listStreamsMutex.Unlock()
	fake.ListStreamsStub = stub
}

func (fake *FakeKinesisAPI) ListStreamsArgsForCall(i int) *kinesis.ListStreamsInput {
	fake.listStreamsMutex.RLock()
	defer fake.listStreamsMutex.RUnlock()
	argsForCall := fake.listStreamsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListStreamsReturns(result1 *kinesis.ListStreamsOutput, result2 error) {
	fake.listStreamsMutex.Lock()
	defer fake.listStreamsMutex.Unlock()
	fake.ListStreamsStub = nil
	fake.listStreamsReturns = struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamsReturnsOnCall(i int, result1 *kinesis.ListStreamsOutput, result2 error) {
	fake.listStreamsMutex.Lock()
	defer fake.listStreamsMutex.Unlock()
	fake.ListStreamsStub = nil
	if fake.listStreamsReturnsOnCall == nil {
		fake.listStreamsReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListStreamsOutput
			result2 error
		})
	}
	fake.listStreamsReturnsOnCall[i] = struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamsPages(arg1 *kinesis.ListStreamsInput, arg2 func(*kinesis.ListStreamsOutput, bool) bool) error {
	fake.listStreamsPagesMutex.Lock()
	ret, specificReturn := fake.listStreamsPagesReturnsOnCall[len(fake.listStreamsPagesArgsForCall)]
	fake.listStreamsPagesArgsForCall = append(fake.listStreamsPagesArgsForCall, struct {
		arg1 *kinesis.ListStreamsInput
		arg2 func(*kinesis.ListStreamsOutput, bool) bool
	}{arg1, arg2})
	stub := fake.ListStreamsPagesStub
	fakeReturns := fake.listStreamsPagesReturns
	fake.recordInvocation("ListStreamsPages", []interface{}{arg1, arg2})
	fake.listStreamsPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) ListStreamsPagesCallCount() int {
	fake.listStreamsPagesMutex.RLock()
	defer fake.listStreamsPagesMutex.RUnlock()
	return len(fake.listStreamsPagesArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamsPagesCalls(stub func(*kinesis.ListStreamsInput, func(*kinesis.ListStreamsOutput, bool) bool) error) {
	fake.listStreamsPagesMutex.Lock()
	defer fake.listStreamsPagesMutex.Unlock()
	fake.ListStreamsPagesStub = stub
}

func (fake *FakeKinesisAPI) ListStreamsPagesArgsForCall(i int) (*kinesis.ListStreamsInput, func(*kinesis.ListStreamsOutput, bool) bool) {
	fake.listStreamsPagesMutex.RLock()
	defer fake.listStreamsPagesMutex.RUnlock()
	argsForCall := fake.listStreamsPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKinesisAPI) ListStreamsPagesReturns(result1 error) {
	fake.listStreamsPagesMutex.Lock()
	defer fake.listStreamsPagesMutex.Unlock()
	fake.ListStreamsPagesStub = nil
	fake.listStreamsPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamsPagesReturnsOnCall(i int, result1 error) {
	fake.listStreamsPagesMutex.Lock()
	defer fake.listStreamsPagesMutex.Unlock()
	fake.ListStreamsPagesStub = nil
	if fake.listStreamsPagesReturnsOnCall == nil {
		fake.listStreamsPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listStreamsPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamsPagesWithContext(arg1 context.Context, arg2 *kinesis.ListStreamsInput, arg3 func(*kinesis.ListStreamsOutput, bool) bool, arg4 ...request.Option) error {
	fake.listStreamsPagesWithContextMutex.Lock()
	ret, specificReturn := fake.listStreamsPagesWithContextReturnsOnCall[len(fake.listStreamsPagesWithContextArgsForCall)]
	fake.listStreamsPagesWithContextArgsForCall = append(fake.listStreamsPagesWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamsInput
		arg3 func(*kinesis.ListStreamsOutput, bool) bool
		arg4 []request.Option
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListStreamsPagesWithContextStub
	fakeReturns := fake.listStreamsPagesWithContextReturns
	fake.recordInvocation("ListStreamsPagesWithContext", []interface{}{arg1, arg2, arg3, arg4})
	fake.listStreamsPagesWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) ListStreamsPagesWithContextCallCount() int {
	fake.listStreamsPagesWithContextMutex.RLock()
	defer fake.listStreamsPagesWithContextMutex.RUnlock()
	return len(fake.listStreamsPagesWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamsPagesWithContextCalls(stub func(context.Context, *kinesis.ListStreamsInput, func(*kinesis.ListStreamsOutput, bool) bool, ...request.Option) error) {
	fake.listStreamsPagesWithContextMutex.Lock()
	defer fake.listStreamsPagesWithContextMutex.Unlock()
	fake.ListStreamsPagesWithContextStub = stub
}

func (fake *FakeKinesisAPI) ListStreamsPagesWithContextArgsForCall(i int) (context.Context, *kinesis.ListStreamsInput, func(*kinesis.ListStreamsOutput, bool) bool, []request.Option) {
	fake.listStreamsPagesWithContextMutex.RLock()
	defer fake.listStreamsPagesWithContextMutex.RUnlock()
	argsForCall := fake.listStreamsPagesWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeKinesisAPI) ListStreamsPagesWithContextReturns(result1 error) {
	fake.listStreamsPagesWithContextMutex.Lock()
	defer fake.listStreamsPagesWithContextMutex.Unlock()
	fake.ListStreamsPagesWithContextStub = nil
	fake.listStreamsPagesWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamsPagesWithContextReturnsOnCall(i int, result1 error) {
	fake.listStreamsPagesWithContextMutex.Lock()
	defer fake.listStreamsPagesWithContextMutex.Unlock()
	fake.ListStreamsPagesWithContextStub = nil
	if fake.listStreamsPagesWithContextReturnsOnCall == nil {
		fake.listStreamsPagesWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listStreamsPagesWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) ListStreamsRequest(arg1 *kinesis.ListStreamsInput) (*request.Request, *kinesis.ListStreamsOutput) {
	fake.listStreamsRequestMutex.Lock()
	ret, specificReturn := fake.listStreamsRequestReturnsOnCall[len(fake.listStreamsRequestArgsForCall)]
	fake.listStreamsRequestArgsForCall = append(fake.listStreamsRequestArgsForCall, struct {
		arg1 *kinesis.ListStreamsInput
	}{arg1})
	stub := fake.ListStreamsRequestStub
	fakeReturns := fake.listStreamsRequestReturns
	fake.recordInvocation("ListStreamsRequest", []interface{}{arg1})
	fake.listStreamsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListStreamsRequestCallCount() int {
	fake.listStreamsRequestMutex.RLock()
	defer fake.listStreamsRequestMutex.RUnlock()
	return len(fake.listStreamsRequestArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamsRequestCalls(stub func(*kinesis.ListStreamsInput) (*request.Request, *kinesis.ListStreamsOutput)) {
	fake.listStreamsRequestMutex.Lock()
	defer fake.listStreamsRequestMutex.Unlock()
	fake.ListStreamsRequestStub = stub
}

func (fake *FakeKinesisAPI) ListStreamsRequestArgsForCall(i int) *kinesis.ListStreamsInput {
	fake.listStreamsRequestMutex.RLock()
	defer fake.listStreamsRequestMutex.RUnlock()
	argsForCall := fake.listStreamsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListStreamsRequestReturns(result1 *request.Request, result2 *kinesis.ListStreamsOutput) {
	fake.listStreamsRequestMutex.Lock()
	defer fake.listStreamsRequestMutex.Unlock()
	fake.ListStreamsRequestStub = nil
	fake.listStreamsRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.ListStreamsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.ListStreamsOutput) {
	fake.listStreamsRequestMutex.Lock()
	defer fake.listStreamsRequestMutex.Unlock()
	fake.ListStreamsRequestStub = nil
	if fake.listStreamsRequestReturnsOnCall == nil {
		fake.listStreamsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.ListStreamsOutput
		})
	}
	fake.listStreamsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.ListStreamsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamsWithContext(arg1 context.Context, arg2 *kinesis.ListStreamsInput, arg3 ...request.Option) (*kinesis.ListStreamsOutput, error) {
	fake.listStreamsWithContextMutex.Lock()
	ret, specificReturn := fake.listStreamsWithContextReturnsOnCall[len(fake.listStreamsWithContextArgsForCall)]
	fake.listStreamsWithContextArgsForCall = append(fake.listStreamsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.ListStreamsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListStreamsWithContextStub
	fakeReturns := fake.listStreamsWithContextReturns
	fake.recordInvocation("ListStreamsWithContext", []interface{}{arg1, arg2, arg3})
	fake.listStreamsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListStreamsWithContextCallCount() int {
	fake.listStreamsWithContextMutex.RLock()
	defer fake.listStreamsWithContextMutex.RUnlock()
	return len(fake.listStreamsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) ListStreamsWithContextCalls(stub func(context.Context, *kinesis.ListStreamsInput, ...request.Option) (*kinesis.ListStreamsOutput, error)) {
	fake.listStreamsWithContextMutex.Lock()
	defer fake.listStreamsWithContextMutex.Unlock()
	fake.ListStreamsWithContextStub = stub
}

func (fake *FakeKinesisAPI) ListStreamsWithContextArgsForCall(i int) (context.Context, *kinesis.ListStreamsInput, []request.Option) {
	fake.listStreamsWithContextMutex.RLock()
	defer fake.listStreamsWithContextMutex.RUnlock()
	argsForCall := fake.listStreamsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) ListStreamsWithContextReturns(result1 *kinesis.ListStreamsOutput, result2 error) {
	fake.listStreamsWithContextMutex.Lock()
	defer fake.listStreamsWithContextMutex.Unlock()
	fake.ListStreamsWithContextStub = nil
	fake.listStreamsWithContextReturns = struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListStreamsWithContextReturnsOnCall(i int, result1 *kinesis.ListStreamsOutput, result2 error) {
	fake.listStreamsWithContextMutex.Lock()
	defer fake.listStreamsWithContextMutex.Unlock()
	fake.ListStreamsWithContextStub = nil
	if fake.listStreamsWithContextReturnsOnCall == nil {
		fake.listStreamsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListStreamsOutput
			result2 error
		})
	}
	fake.listStreamsWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.ListStreamsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListTagsForStream(arg1 *kinesis.ListTagsForStreamInput) (*kinesis.ListTagsForStreamOutput, error) {
	fake.listTagsForStreamMutex.Lock()
	ret, specificReturn := fake.listTagsForStreamReturnsOnCall[len(fake.listTagsForStreamArgsForCall)]
	fake.listTagsForStreamArgsForCall = append(fake.listTagsForStreamArgsForCall, struct {
		arg1 *kinesis.ListTagsForStreamInput
	}{arg1})
	stub := fake.ListTagsForStreamStub
	fakeReturns := fake.listTagsForStreamReturns
	fake.recordInvocation("ListTagsForStream", []interface{}{arg1})
	fake.listTagsForStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListTagsForStreamCallCount() int {
	fake.listTagsForStreamMutex.RLock()
	defer fake.listTagsForStreamMutex.RUnlock()
	return len(fake.listTagsForStreamArgsForCall)
}

func (fake *FakeKinesisAPI) ListTagsForStreamCalls(stub func(*kinesis.ListTagsForStreamInput) (*kinesis.ListTagsForStreamOutput, error)) {
	fake.listTagsForStreamMutex.Lock()
	defer fake.listTagsForStreamMutex.Unlock()
	fake.ListTagsForStreamStub = stub
}

func (fake *FakeKinesisAPI) ListTagsForStreamArgsForCall(i int) *kinesis.ListTagsForStreamInput {
	fake.listTagsForStreamMutex.RLock()
	defer fake.listTagsForStreamMutex.RUnlock()
	argsForCall := fake.listTagsForStreamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListTagsForStreamReturns(result1 *kinesis.ListTagsForStreamOutput, result2 error) {
	fake.listTagsForStreamMutex.Lock()
	defer fake.listTagsForStreamMutex.Unlock()
	fake.ListTagsForStreamStub = nil
	fake.listTagsForStreamReturns = struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListTagsForStreamReturnsOnCall(i int, result1 *kinesis.ListTagsForStreamOutput, result2 error) {
	fake.listTagsForStreamMutex.Lock()
	defer fake.listTagsForStreamMutex.Unlock()
	fake.ListTagsForStreamStub = nil
	if fake.listTagsForStreamReturnsOnCall == nil {
		fake.listTagsForStreamReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListTagsForStreamOutput
			result2 error
		})
	}
	fake.listTagsForStreamReturnsOnCall[i] = struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListTagsForStreamRequest(arg1 *kinesis.ListTagsForStreamInput) (*request.Request, *kinesis.ListTagsForStreamOutput) {
	fake.listTagsForStreamRequestMutex.Lock()
	ret, specificReturn := fake.listTagsForStreamRequestReturnsOnCall[len(fake.listTagsForStreamRequestArgsForCall)]
	fake.listTagsForStreamRequestArgsForCall = append(fake.listTagsForStreamRequestArgsForCall, struct {
		arg1 *kinesis.ListTagsForStreamInput
	}{arg1})
	stub := fake.ListTagsForStreamRequestStub
	fakeReturns := fake.listTagsForStreamRequestReturns
	fake.recordInvocation("ListTagsForStreamRequest", []interface{}{arg1})
	fake.listTagsForStreamRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListTagsForStreamRequestCallCount() int {
	fake.listTagsForStreamRequestMutex.RLock()
	defer fake.listTagsForStreamRequestMutex.RUnlock()
	return len(fake.listTagsForStreamRequestArgsForCall)
}

func (fake *FakeKinesisAPI) ListTagsForStreamRequestCalls(stub func(*kinesis.ListTagsForStreamInput) (*request.Request, *kinesis.ListTagsForStreamOutput)) {
	fake.listTagsForStreamRequestMutex.Lock()
	defer fake.listTagsForStreamRequestMutex.Unlock()
	fake.ListTagsForStreamRequestStub = stub
}

func (fake *FakeKinesisAPI) ListTagsForStreamRequestArgsForCall(i int) *kinesis.ListTagsForStreamInput {
	fake.listTagsForStreamRequestMutex.RLock()
	defer fake.listTagsForStreamRequestMutex.RUnlock()
	argsForCall := fake.listTagsForStreamRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) ListTagsForStreamRequestReturns(result1 *request.Request, result2 *kinesis.ListTagsForStreamOutput) {
	fake.listTagsForStreamRequestMutex.Lock()
	defer fake.listTagsForStreamRequestMutex.Unlock()
	fake.ListTagsForStreamRequestStub = nil
	fake.listTagsForStreamRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.ListTagsForStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListTagsForStreamRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.ListTagsForStreamOutput) {
	fake.listTagsForStreamRequestMutex.Lock()
	defer fake.listTagsForStreamRequestMutex.Unlock()
	fake.ListTagsForStreamRequestStub = nil
	if fake.listTagsForStreamRequestReturnsOnCall == nil {
		fake.listTagsForStreamRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.ListTagsForStreamOutput
		})
	}
	fake.listTagsForStreamRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.ListTagsForStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListTagsForStreamWithContext(arg1 context.Context, arg2 *kinesis.ListTagsForStreamInput, arg3 ...request.Option) (*kinesis.ListTagsForStreamOutput, error) {
	fake.listTagsForStreamWithContextMutex.Lock()
	ret, specificReturn := fake.listTagsForStreamWithContextReturnsOnCall[len(fake.listTagsForStreamWithContextArgsForCall)]
	fake.listTagsForStreamWithContextArgsForCall = append(fake.listTagsForStreamWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.ListTagsForStreamInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.ListTagsForStreamWithContextStub
	fakeReturns := fake.listTagsForStreamWithContextReturns
	fake.recordInvocation("ListTagsForStreamWithContext", []interface{}{arg1, arg2, arg3})
	fake.listTagsForStreamWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) ListTagsForStreamWithContextCallCount() int {
	fake.listTagsForStreamWithContextMutex.RLock()
	defer fake.listTagsForStreamWithContextMutex.RUnlock()
	return len(fake.listTagsForStreamWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) ListTagsForStreamWithContextCalls(stub func(context.Context, *kinesis.ListTagsForStreamInput, ...request.Option) (*kinesis.ListTagsForStreamOutput, error)) {
	fake.listTagsForStreamWithContextMutex.Lock()
	defer fake.listTagsForStreamWithContextMutex.Unlock()
	fake.ListTagsForStreamWithContextStub = stub
}

func (fake *FakeKinesisAPI) ListTagsForStreamWithContextArgsForCall(i int) (context.Context, *kinesis.ListTagsForStreamInput, []request.Option) {
	fake.listTagsForStreamWithContextMutex.RLock()
	defer fake.listTagsForStreamWithContextMutex.RUnlock()
	argsForCall := fake.listTagsForStreamWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) ListTagsForStreamWithContextReturns(result1 *kinesis.ListTagsForStreamOutput, result2 error) {
	fake.listTagsForStreamWithContextMutex.Lock()
	defer fake.listTagsForStreamWithContextMutex.Unlock()
	fake.ListTagsForStreamWithContextStub = nil
	fake.listTagsForStreamWithContextReturns = struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) ListTagsForStreamWithContextReturnsOnCall(i int, result1 *kinesis.ListTagsForStreamOutput, result2 error) {
	fake.listTagsForStreamWithContextMutex.Lock()
	defer fake.listTagsForStreamWithContextMutex.Unlock()
	fake.ListTagsForStreamWithContextStub = nil
	if fake.listTagsForStreamWithContextReturnsOnCall == nil {
		fake.listTagsForStreamWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.ListTagsForStreamOutput
			result2 error
		})
	}
	fake.listTagsForStreamWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.ListTagsForStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) MergeShards(arg1 *kinesis.MergeShardsInput) (*kinesis.MergeShardsOutput, error) {
	fake.mergeShardsMutex.Lock()
	ret, specificReturn := fake.mergeShardsReturnsOnCall[len(fake.mergeShardsArgsForCall)]
	fake.mergeShardsArgsForCall = append(fake.mergeShardsArgsForCall, struct {
		arg1 *kinesis.MergeShardsInput
	}{arg1})
	stub := fake.MergeShardsStub
	fakeReturns := fake.mergeShardsReturns
	fake.recordInvocation("MergeShards", []interface{}{arg1})
	fake.mergeShardsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) MergeShardsCallCount() int {
	fake.mergeShardsMutex.RLock()
	defer fake.mergeShardsMutex.RUnlock()
	return len(fake.mergeShardsArgsForCall)
}

func (fake *FakeKinesisAPI) MergeShardsCalls(stub func(*kinesis.MergeShardsInput) (*kinesis.MergeShardsOutput, error)) {
	fake.mergeShardsMutex.Lock()
	defer fake.mergeShardsMutex.Unlock()
	fake.MergeShardsStub = stub
}

func (fake *FakeKinesisAPI) MergeShardsArgsForCall(i int) *kinesis.MergeShardsInput {
	fake.mergeShardsMutex.RLock()
	defer fake.mergeShardsMutex.RUnlock()
	argsForCall := fake.mergeShardsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) MergeShardsReturns(result1 *kinesis.MergeShardsOutput, result2 error) {
	fake.mergeShardsMutex.Lock()
	defer fake.mergeShardsMutex.Unlock()
	fake.MergeShardsStub = nil
	fake.mergeShardsReturns = struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) MergeShardsReturnsOnCall(i int, result1 *kinesis.MergeShardsOutput, result2 error) {
	fake.mergeShardsMutex.Lock()
	defer fake.mergeShardsMutex.Unlock()
	fake.MergeShardsStub = nil
	if fake.mergeShardsReturnsOnCall == nil {
		fake.mergeShardsReturnsOnCall = make(map[int]struct {
			result1 *kinesis.MergeShardsOutput
			result2 error
		})
	}
	fake.mergeShardsReturnsOnCall[i] = struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) MergeShardsRequest(arg1 *kinesis.MergeShardsInput) (*request.Request, *kinesis.MergeShardsOutput) {
	fake.mergeShardsRequestMutex.Lock()
	ret, specificReturn := fake.mergeShardsRequestReturnsOnCall[len(fake.mergeShardsRequestArgsForCall)]
	fake.mergeShardsRequestArgsForCall = append(fake.mergeShardsRequestArgsForCall, struct {
		arg1 *kinesis.MergeShardsInput
	}{arg1})
	stub := fake.MergeShardsRequestStub
	fakeReturns := fake.mergeShardsRequestReturns
	fake.recordInvocation("MergeShardsRequest", []interface{}{arg1})
	fake.mergeShardsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) MergeShardsRequestCallCount() int {
	fake.mergeShardsRequestMutex.RLock()
	defer fake.mergeShardsRequestMutex.RUnlock()
	return len(fake.mergeShardsRequestArgsForCall)
}

func (fake *FakeKinesisAPI) MergeShardsRequestCalls(stub func(*kinesis.MergeShardsInput) (*request.Request, *kinesis.MergeShardsOutput)) {
	fake.mergeShardsRequestMutex.Lock()
	defer fake.mergeShardsRequestMutex.Unlock()
	fake.MergeShardsRequestStub = stub
}

func (fake *FakeKinesisAPI) MergeShardsRequestArgsForCall(i int) *kinesis.MergeShardsInput {
	fake.mergeShardsRequestMutex.RLock()
	defer fake.mergeShardsRequestMutex.RUnlock()
	argsForCall := fake.mergeShardsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) MergeShardsRequestReturns(result1 *request.Request, result2 *kinesis.MergeShardsOutput) {
	fake.mergeShardsRequestMutex.Lock()
	defer fake.mergeShardsRequestMutex.Unlock()
	fake.MergeShardsRequestStub = nil
	fake.mergeShardsRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.MergeShardsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) MergeShardsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.MergeShardsOutput) {
	fake.mergeShardsRequestMutex.Lock()
	defer fake.mergeShardsRequestMutex.Unlock()
	fake.MergeShardsRequestStub = nil
	if fake.mergeShardsRequestReturnsOnCall == nil {
		fake.mergeShardsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.MergeShardsOutput
		})
	}
	fake.mergeShardsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.MergeShardsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) MergeShardsWithContext(arg1 context.Context, arg2 *kinesis.MergeShardsInput, arg3 ...request.Option) (*kinesis.MergeShardsOutput, error) {
	fake.mergeShardsWithContextMutex.Lock()
	ret, specificReturn := fake.mergeShardsWithContextReturnsOnCall[len(fake.mergeShardsWithContextArgsForCall)]
	fake.mergeShardsWithContextArgsForCall = append(fake.mergeShardsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.MergeShardsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.MergeShardsWithContextStub
	fakeReturns := fake.mergeShardsWithContextReturns
	fake.recordInvocation("MergeShardsWithContext", []interface{}{arg1, arg2, arg3})
	fake.mergeShardsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) MergeShardsWithContextCallCount() int {
	fake.mergeShardsWithContextMutex.RLock()
	defer fake.mergeShardsWithContextMutex.RUnlock()
	return len(fake.mergeShardsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) MergeShardsWithContextCalls(stub func(context.Context, *kinesis.MergeShardsInput, ...request.Option) (*kinesis.MergeShardsOutput, error)) {
	fake.mergeShardsWithContextMutex.Lock()
	defer fake.mergeShardsWithContextMutex.Unlock()
	fake.MergeShardsWithContextStub = stub
}

func (fake *FakeKinesisAPI) MergeShardsWithContextArgsForCall(i int) (context.Context, *kinesis.MergeShardsInput, []request.Option) {
	fake.mergeShardsWithContextMutex.RLock()
	defer fake.mergeShardsWithContextMutex.RUnlock()
	argsForCall := fake.mergeShardsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) MergeShardsWithContextReturns(result1 *kinesis.MergeShardsOutput, result2 error) {
	fake.mergeShardsWithContextMutex.Lock()
	defer fake.mergeShardsWithContextMutex.Unlock()
	fake.MergeShardsWithContextStub = nil
	fake.mergeShardsWithContextReturns = struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) MergeShardsWithContextReturnsOnCall(i int, result1 *kinesis.MergeShardsOutput, result2 error) {
	fake.mergeShardsWithContextMutex.Lock()
	defer fake.mergeShardsWithContextMutex.Unlock()
	fake.MergeShardsWithContextStub = nil
	if fake.mergeShardsWithContextReturnsOnCall == nil {
		fake.mergeShardsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.MergeShardsOutput
			result2 error
		})
	}
	fake.mergeShardsWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.MergeShardsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecord(arg1 *kinesis.PutRecordInput) (*kinesis.PutRecordOutput, error) {
	fake.putRecordMutex.Lock()
	ret, specificReturn := fake.putRecordReturnsOnCall[len(fake.putRecordArgsForCall)]
	fake.putRecordArgsForCall = append(fake.putRecordArgsForCall, struct {
		arg1 *kinesis.PutRecordInput
	}{arg1})
	stub := fake.PutRecordStub
	fakeReturns := fake.putRecordReturns
	fake.recordInvocation("PutRecord", []interface{}{arg1})
	fake.putRecordMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) PutRecordCallCount() int {
	fake.putRecordMutex.RLock()
	defer fake.putRecordMutex.RUnlock()
	return len(fake.putRecordArgsForCall)
}

func (fake *FakeKinesisAPI) PutRecordCalls(stub func(*kinesis.PutRecordInput) (*kinesis.PutRecordOutput, error)) {
	fake.putRecordMutex.Lock()
	defer fake.putRecordMutex.Unlock()
	fake.PutRecordStub = stub
}

func (fake *FakeKinesisAPI) PutRecordArgsForCall(i int) *kinesis.PutRecordInput {
	fake.putRecordMutex.RLock()
	defer fake.putRecordMutex.RUnlock()
	argsForCall := fake.putRecordArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) PutRecordReturns(result1 *kinesis.PutRecordOutput, result2 error) {
	fake.putRecordMutex.Lock()
	defer fake.putRecordMutex.Unlock()
	fake.PutRecordStub = nil
	fake.putRecordReturns = struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordReturnsOnCall(i int, result1 *kinesis.PutRecordOutput, result2 error) {
	fake.putRecordMutex.Lock()
	defer fake.putRecordMutex.Unlock()
	fake.PutRecordStub = nil
	if fake.putRecordReturnsOnCall == nil {
		fake.putRecordReturnsOnCall = make(map[int]struct {
			result1 *kinesis.PutRecordOutput
			result2 error
		})
	}
	fake.putRecordReturnsOnCall[i] = struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordRequest(arg1 *kinesis.PutRecordInput) (*request.Request, *kinesis.PutRecordOutput) {
	fake.putRecordRequestMutex.Lock()
	ret, specificReturn := fake.putRecordRequestReturnsOnCall[len(fake.putRecordRequestArgsForCall)]
	fake.putRecordRequestArgsForCall = append(fake.putRecordRequestArgsForCall, struct {
		arg1 *kinesis.PutRecordInput
	}{arg1})
	stub := fake.PutRecordRequestStub
	fakeReturns := fake.putRecordRequestReturns
	fake.recordInvocation("PutRecordRequest", []interface{}{arg1})
	fake.putRecordRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) PutRecordRequestCallCount() int {
	fake.putRecordRequestMutex.RLock()
	defer fake.putRecordRequestMutex.RUnlock()
	return len(fake.putRecordRequestArgsForCall)
}

func (fake *FakeKinesisAPI) PutRecordRequestCalls(stub func(*kinesis.PutRecordInput) (*request.Request, *kinesis.PutRecordOutput)) {
	fake.putRecordRequestMutex.Lock()
	defer fake.putRecordRequestMutex.Unlock()
	fake.PutRecordRequestStub = stub
}

func (fake *FakeKinesisAPI) PutRecordRequestArgsForCall(i int) *kinesis.PutRecordInput {
	fake.putRecordRequestMutex.RLock()
	defer fake.putRecordRequestMutex.RUnlock()
	argsForCall := fake.putRecordRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) PutRecordRequestReturns(result1 *request.Request, result2 *kinesis.PutRecordOutput) {
	fake.putRecordRequestMutex.Lock()
	defer fake.putRecordRequestMutex.Unlock()
	fake.PutRecordRequestStub = nil
	fake.putRecordRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.PutRecordOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.PutRecordOutput) {
	fake.putRecordRequestMutex.Lock()
	defer fake.putRecordRequestMutex.Unlock()
	fake.PutRecordRequestStub = nil
	if fake.putRecordRequestReturnsOnCall == nil {
		fake.putRecordRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.PutRecordOutput
		})
	}
	fake.putRecordRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.PutRecordOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordWithContext(arg1 context.Context, arg2 *kinesis.PutRecordInput, arg3 ...request.Option) (*kinesis.PutRecordOutput, error) {
	fake.putRecordWithContextMutex.Lock()
	ret, specificReturn := fake.putRecordWithContextReturnsOnCall[len(fake.putRecordWithContextArgsForCall)]
	fake.putRecordWithContextArgsForCall = append(fake.putRecordWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.PutRecordInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.PutRecordWithContextStub
	fakeReturns := fake.putRecordWithContextReturns
	fake.recordInvocation("PutRecordWithContext", []interface{}{arg1, arg2, arg3})
	fake.putRecordWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) PutRecordWithContextCallCount() int {
	fake.putRecordWithContextMutex.RLock()
	defer fake.putRecordWithContextMutex.RUnlock()
	return len(fake.putRecordWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) PutRecordWithContextCalls(stub func(context.Context, *kinesis.PutRecordInput, ...request.Option) (*kinesis.PutRecordOutput, error)) {
	fake.putRecordWithContextMutex.Lock()
	defer fake.putRecordWithContextMutex.Unlock()
	fake.PutRecordWithContextStub = stub
}

func (fake *FakeKinesisAPI) PutRecordWithContextArgsForCall(i int) (context.Context, *kinesis.PutRecordInput, []request.Option) {
	fake.putRecordWithContextMutex.RLock()
	defer fake.putRecordWithContextMutex.RUnlock()
	argsForCall := fake.putRecordWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) PutRecordWithContextReturns(result1 *kinesis.PutRecordOutput, result2 error) {
	fake.putRecordWithContextMutex.Lock()
	defer fake.putRecordWithContextMutex.Unlock()
	fake.PutRecordWithContextStub = nil
	fake.putRecordWithContextReturns = struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordWithContextReturnsOnCall(i int, result1 *kinesis.PutRecordOutput, result2 error) {
	fake.putRecordWithContextMutex.Lock()
	defer fake.putRecordWithContextMutex.Unlock()
	fake.PutRecordWithContextStub = nil
	if fake.putRecordWithContextReturnsOnCall == nil {
		fake.putRecordWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.PutRecordOutput
			result2 error
		})
	}
	fake.putRecordWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.PutRecordOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecords(arg1 *kinesis.PutRecordsInput) (*kinesis.PutRecordsOutput, error) {
	fake.putRecordsMutex.Lock()
	ret, specificReturn := fake.putRecordsReturnsOnCall[len(fake.putRecordsArgsForCall)]
	fake.putRecordsArgsForCall = append(fake.putRecordsArgsForCall, struct {
		arg1 *kinesis.PutRecordsInput
	}{arg1})
	stub := fake.PutRecordsStub
	fakeReturns := fake.putRecordsReturns
	fake.recordInvocation("PutRecords", []interface{}{arg1})
	fake.putRecordsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) PutRecordsCallCount() int {
	fake.putRecordsMutex.RLock()
	defer fake.putRecordsMutex.RUnlock()
	return len(fake.putRecordsArgsForCall)
}

func (fake *FakeKinesisAPI) PutRecordsCalls(stub func(*kinesis.PutRecordsInput) (*kinesis.PutRecordsOutput, error)) {
	fake.putRecordsMutex.Lock()
	defer fake.putRecordsMutex.Unlock()
	fake.PutRecordsStub = stub
}

func (fake *FakeKinesisAPI) PutRecordsArgsForCall(i int) *kinesis.PutRecordsInput {
	fake.putRecordsMutex.RLock()
	defer fake.putRecordsMutex.RUnlock()
	argsForCall := fake.putRecordsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) PutRecordsReturns(result1 *kinesis.PutRecordsOutput, result2 error) {
	fake.putRecordsMutex.Lock()
	defer fake.putRecordsMutex.Unlock()
	fake.PutRecordsStub = nil
	fake.putRecordsReturns = struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordsReturnsOnCall(i int, result1 *kinesis.PutRecordsOutput, result2 error) {
	fake.putRecordsMutex.Lock()
	defer fake.putRecordsMutex.Unlock()
	fake.PutRecordsStub = nil
	if fake.putRecordsReturnsOnCall == nil {
		fake.putRecordsReturnsOnCall = make(map[int]struct {
			result1 *kinesis.PutRecordsOutput
			result2 error
		})
	}
	fake.putRecordsReturnsOnCall[i] = struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordsRequest(arg1 *kinesis.PutRecordsInput) (*request.Request, *kinesis.PutRecordsOutput) {
	fake.putRecordsRequestMutex.Lock()
	ret, specificReturn := fake.putRecordsRequestReturnsOnCall[len(fake.putRecordsRequestArgsForCall)]
	fake.putRecordsRequestArgsForCall = append(fake.putRecordsRequestArgsForCall, struct {
		arg1 *kinesis.PutRecordsInput
	}{arg1})
	stub := fake.PutRecordsRequestStub
	fakeReturns := fake.putRecordsRequestReturns
	fake.recordInvocation("PutRecordsRequest", []interface{}{arg1})
	fake.putRecordsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) PutRecordsRequestCallCount() int {
	fake.putRecordsRequestMutex.RLock()
	defer fake.putRecordsRequestMutex.RUnlock()
	return len(fake.putRecordsRequestArgsForCall)
}

func (fake *FakeKinesisAPI) PutRecordsRequestCalls(stub func(*kinesis.PutRecordsInput) (*request.Request, *kinesis.PutRecordsOutput)) {
	fake.putRecordsRequestMutex.Lock()
	defer fake.putRecordsRequestMutex.Unlock()
	fake.PutRecordsRequestStub = stub
}

func (fake *FakeKinesisAPI) PutRecordsRequestArgsForCall(i int) *kinesis.PutRecordsInput {
	fake.putRecordsRequestMutex.RLock()
	defer fake.putRecordsRequestMutex.RUnlock()
	argsForCall := fake.putRecordsRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) PutRecordsRequestReturns(result1 *request.Request, result2 *kinesis.PutRecordsOutput) {
	fake.putRecordsRequestMutex.Lock()
	defer fake.putRecordsRequestMutex.Unlock()
	fake.PutRecordsRequestStub = nil
	fake.putRecordsRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.PutRecordsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordsRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.PutRecordsOutput) {
	fake.putRecordsRequestMutex.Lock()
	defer fake.putRecordsRequestMutex.Unlock()
	fake.PutRecordsRequestStub = nil
	if fake.putRecordsRequestReturnsOnCall == nil {
		fake.putRecordsRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.PutRecordsOutput
		})
	}
	fake.putRecordsRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.PutRecordsOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordsWithContext(arg1 context.Context, arg2 *kinesis.PutRecordsInput, arg3 ...request.Option) (*kinesis.PutRecordsOutput, error) {
	fake.putRecordsWithContextMutex.Lock()
	ret, specificReturn := fake.putRecordsWithContextReturnsOnCall[len(fake.putRecordsWithContextArgsForCall)]
	fake.putRecordsWithContextArgsForCall = append(fake.putRecordsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.PutRecordsInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.PutRecordsWithContextStub
	fakeReturns := fake.putRecordsWithContextReturns
	fake.recordInvocation("PutRecordsWithContext", []interface{}{arg1, arg2, arg3})
	fake.putRecordsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) PutRecordsWithContextCallCount() int {
	fake.putRecordsWithContextMutex.RLock()
	defer fake.putRecordsWithContextMutex.RUnlock()
	return len(fake.putRecordsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) PutRecordsWithContextCalls(stub func(context.Context, *kinesis.PutRecordsInput, ...request.Option) (*kinesis.PutRecordsOutput, error)) {
	fake.putRecordsWithContextMutex.Lock()
	defer fake.putRecordsWithContextMutex.Unlock()
	fake.PutRecordsWithContextStub = stub
}

func (fake *FakeKinesisAPI) PutRecordsWithContextArgsForCall(i int) (context.Context, *kinesis.PutRecordsInput, []request.Option) {
	fake.putRecordsWithContextMutex.RLock()
	defer fake.putRecordsWithContextMutex.RUnlock()
	argsForCall := fake.putRecordsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) PutRecordsWithContextReturns(result1 *kinesis.PutRecordsOutput, result2 error) {
	fake.putRecordsWithContextMutex.Lock()
	defer fake.putRecordsWithContextMutex.Unlock()
	fake.PutRecordsWithContextStub = nil
	fake.putRecordsWithContextReturns = struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) PutRecordsWithContextReturnsOnCall(i int, result1 *kinesis.PutRecordsOutput, result2 error) {
	fake.putRecordsWithContextMutex.Lock()
	defer fake.putRecordsWithContextMutex.Unlock()
	fake.PutRecordsWithContextStub = nil
	if fake.putRecordsWithContextReturnsOnCall == nil {
		fake.putRecordsWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.PutRecordsOutput
			result2 error
		})
	}
	fake.putRecordsWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.PutRecordsOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RegisterStreamConsumer(arg1 *kinesis.RegisterStreamConsumerInput) (*kinesis.RegisterStreamConsumerOutput, error) {
	fake.registerStreamConsumerMutex.Lock()
	ret, specificReturn := fake.registerStreamConsumerReturnsOnCall[len(fake.registerStreamConsumerArgsForCall)]
	fake.registerStreamConsumerArgsForCall = append(fake.registerStreamConsumerArgsForCall, struct {
		arg1 *kinesis.RegisterStreamConsumerInput
	}{arg1})
	stub := fake.RegisterStreamConsumerStub
	fakeReturns := fake.registerStreamConsumerReturns
	fake.recordInvocation("RegisterStreamConsumer", []interface{}{arg1})
	fake.registerStreamConsumerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerCallCount() int {
	fake.registerStreamConsumerMutex.RLock()
	defer fake.registerStreamConsumerMutex.RUnlock()
	return len(fake.registerStreamConsumerArgsForCall)
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerCalls(stub func(*kinesis.RegisterStreamConsumerInput) (*kinesis.RegisterStreamConsumerOutput, error)) {
	fake.registerStreamConsumerMutex.Lock()
	defer fake.registerStreamConsumerMutex.Unlock()
	fake.RegisterStreamConsumerStub = stub
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerArgsForCall(i int) *kinesis.RegisterStreamConsumerInput {
	fake.registerStreamConsumerMutex.RLock()
	defer fake.registerStreamConsumerMutex.RUnlock()
	argsForCall := fake.registerStreamConsumerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerReturns(result1 *kinesis.RegisterStreamConsumerOutput, result2 error) {
	fake.registerStreamConsumerMutex.Lock()
	defer fake.registerStreamConsumerMutex.Unlock()
	fake.RegisterStreamConsumerStub = nil
	fake.registerStreamConsumerReturns = struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerReturnsOnCall(i int, result1 *kinesis.RegisterStreamConsumerOutput, result2 error) {
	fake.registerStreamConsumerMutex.Lock()
	defer fake.registerStreamConsumerMutex.Unlock()
	fake.RegisterStreamConsumerStub = nil
	if fake.registerStreamConsumerReturnsOnCall == nil {
		fake.registerStreamConsumerReturnsOnCall = make(map[int]struct {
			result1 *kinesis.RegisterStreamConsumerOutput
			result2 error
		})
	}
	fake.registerStreamConsumerReturnsOnCall[i] = struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerRequest(arg1 *kinesis.RegisterStreamConsumerInput) (*request.Request, *kinesis.RegisterStreamConsumerOutput) {
	fake.registerStreamConsumerRequestMutex.Lock()
	ret, specificReturn := fake.registerStreamConsumerRequestReturnsOnCall[len(fake.registerStreamConsumerRequestArgsForCall)]
	fake.registerStreamConsumerRequestArgsForCall = append(fake.registerStreamConsumerRequestArgsForCall, struct {
		arg1 *kinesis.RegisterStreamConsumerInput
	}{arg1})
	stub := fake.RegisterStreamConsumerRequestStub
	fakeReturns := fake.registerStreamConsumerRequestReturns
	fake.recordInvocation("RegisterStreamConsumerRequest", []interface{}{arg1})
	fake.registerStreamConsumerRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerRequestCallCount() int {
	fake.registerStreamConsumerRequestMutex.RLock()
	defer fake.registerStreamConsumerRequestMutex.RUnlock()
	return len(fake.registerStreamConsumerRequestArgsForCall)
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerRequestCalls(stub func(*kinesis.RegisterStreamConsumerInput) (*request.Request, *kinesis.RegisterStreamConsumerOutput)) {
	fake.registerStreamConsumerRequestMutex.Lock()
	defer fake.registerStreamConsumerRequestMutex.Unlock()
	fake.RegisterStreamConsumerRequestStub = stub
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerRequestArgsForCall(i int) *kinesis.RegisterStreamConsumerInput {
	fake.registerStreamConsumerRequestMutex.RLock()
	defer fake.registerStreamConsumerRequestMutex.RUnlock()
	argsForCall := fake.registerStreamConsumerRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerRequestReturns(result1 *request.Request, result2 *kinesis.RegisterStreamConsumerOutput) {
	fake.registerStreamConsumerRequestMutex.Lock()
	defer fake.registerStreamConsumerRequestMutex.Unlock()
	fake.RegisterStreamConsumerRequestStub = nil
	fake.registerStreamConsumerRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.RegisterStreamConsumerOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.RegisterStreamConsumerOutput) {
	fake.registerStreamConsumerRequestMutex.Lock()
	defer fake.registerStreamConsumerRequestMutex.Unlock()
	fake.RegisterStreamConsumerRequestStub = nil
	if fake.registerStreamConsumerRequestReturnsOnCall == nil {
		fake.registerStreamConsumerRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.RegisterStreamConsumerOutput
		})
	}
	fake.registerStreamConsumerRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.RegisterStreamConsumerOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerWithContext(arg1 context.Context, arg2 *kinesis.RegisterStreamConsumerInput, arg3 ...request.Option) (*kinesis.RegisterStreamConsumerOutput, error) {
	fake.registerStreamConsumerWithContextMutex.Lock()
	ret, specificReturn := fake.registerStreamConsumerWithContextReturnsOnCall[len(fake.registerStreamConsumerWithContextArgsForCall)]
	fake.registerStreamConsumerWithContextArgsForCall = append(fake.registerStreamConsumerWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.RegisterStreamConsumerInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.RegisterStreamConsumerWithContextStub
	fakeReturns := fake.registerStreamConsumerWithContextReturns
	fake.recordInvocation("RegisterStreamConsumerWithContext", []interface{}{arg1, arg2, arg3})
	fake.registerStreamConsumerWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerWithContextCallCount() int {
	fake.registerStreamConsumerWithContextMutex.RLock()
	defer fake.registerStreamConsumerWithContextMutex.RUnlock()
	return len(fake.registerStreamConsumerWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerWithContextCalls(stub func(context.Context, *kinesis.RegisterStreamConsumerInput, ...request.Option) (*kinesis.RegisterStreamConsumerOutput, error)) {
	fake.registerStreamConsumerWithContextMutex.Lock()
	defer fake.registerStreamConsumerWithContextMutex.Unlock()
	fake.RegisterStreamConsumerWithContextStub = stub
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerWithContextArgsForCall(i int) (context.Context, *kinesis.RegisterStreamConsumerInput, []request.Option) {
	fake.registerStreamConsumerWithContextMutex.RLock()
	defer fake.registerStreamConsumerWithContextMutex.RUnlock()
	argsForCall := fake.registerStreamConsumerWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerWithContextReturns(result1 *kinesis.RegisterStreamConsumerOutput, result2 error) {
	fake.registerStreamConsumerWithContextMutex.Lock()
	defer fake.registerStreamConsumerWithContextMutex.Unlock()
	fake.RegisterStreamConsumerWithContextStub = nil
	fake.registerStreamConsumerWithContextReturns = struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RegisterStreamConsumerWithContextReturnsOnCall(i int, result1 *kinesis.RegisterStreamConsumerOutput, result2 error) {
	fake.registerStreamConsumerWithContextMutex.Lock()
	defer fake.registerStreamConsumerWithContextMutex.Unlock()
	fake.RegisterStreamConsumerWithContextStub = nil
	if fake.registerStreamConsumerWithContextReturnsOnCall == nil {
		fake.registerStreamConsumerWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.RegisterStreamConsumerOutput
			result2 error
		})
	}
	fake.registerStreamConsumerWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.RegisterStreamConsumerOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RemoveTagsFromStream(arg1 *kinesis.RemoveTagsFromStreamInput) (*kinesis.RemoveTagsFromStreamOutput, error) {
	fake.removeTagsFromStreamMutex.Lock()
	ret, specificReturn := fake.removeTagsFromStreamReturnsOnCall[len(fake.removeTagsFromStreamArgsForCall)]
	fake.removeTagsFromStreamArgsForCall = append(fake.removeTagsFromStreamArgsForCall, struct {
		arg1 *kinesis.RemoveTagsFromStreamInput
	}{arg1})
	stub := fake.RemoveTagsFromStreamStub
	fakeReturns := fake.removeTagsFromStreamReturns
	fake.recordInvocation("RemoveTagsFromStream", []interface{}{arg1})
	fake.removeTagsFromStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamCallCount() int {
	fake.removeTagsFromStreamMutex.RLock()
	defer fake.removeTagsFromStreamMutex.RUnlock()
	return len(fake.removeTagsFromStreamArgsForCall)
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamCalls(stub func(*kinesis.RemoveTagsFromStreamInput) (*kinesis.RemoveTagsFromStreamOutput, error)) {
	fake.removeTagsFromStreamMutex.Lock()
	defer fake.removeTagsFromStreamMutex.Unlock()
	fake.RemoveTagsFromStreamStub = stub
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamArgsForCall(i int) *kinesis.RemoveTagsFromStreamInput {
	fake.removeTagsFromStreamMutex.RLock()
	defer fake.removeTagsFromStreamMutex.RUnlock()
	argsForCall := fake.removeTagsFromStreamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamReturns(result1 *kinesis.RemoveTagsFromStreamOutput, result2 error) {
	fake.removeTagsFromStreamMutex.Lock()
	defer fake.removeTagsFromStreamMutex.Unlock()
	fake.RemoveTagsFromStreamStub = nil
	fake.removeTagsFromStreamReturns = struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamReturnsOnCall(i int, result1 *kinesis.RemoveTagsFromStreamOutput, result2 error) {
	fake.removeTagsFromStreamMutex.Lock()
	defer fake.removeTagsFromStreamMutex.Unlock()
	fake.RemoveTagsFromStreamStub = nil
	if fake.removeTagsFromStreamReturnsOnCall == nil {
		fake.removeTagsFromStreamReturnsOnCall = make(map[int]struct {
			result1 *kinesis.RemoveTagsFromStreamOutput
			result2 error
		})
	}
	fake.removeTagsFromStreamReturnsOnCall[i] = struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamRequest(arg1 *kinesis.RemoveTagsFromStreamInput) (*request.Request, *kinesis.RemoveTagsFromStreamOutput) {
	fake.removeTagsFromStreamRequestMutex.Lock()
	ret, specificReturn := fake.removeTagsFromStreamRequestReturnsOnCall[len(fake.removeTagsFromStreamRequestArgsForCall)]
	fake.removeTagsFromStreamRequestArgsForCall = append(fake.removeTagsFromStreamRequestArgsForCall, struct {
		arg1 *kinesis.RemoveTagsFromStreamInput
	}{arg1})
	stub := fake.RemoveTagsFromStreamRequestStub
	fakeReturns := fake.removeTagsFromStreamRequestReturns
	fake.recordInvocation("RemoveTagsFromStreamRequest", []interface{}{arg1})
	fake.removeTagsFromStreamRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamRequestCallCount() int {
	fake.removeTagsFromStreamRequestMutex.RLock()
	defer fake.removeTagsFromStreamRequestMutex.RUnlock()
	return len(fake.removeTagsFromStreamRequestArgsForCall)
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamRequestCalls(stub func(*kinesis.RemoveTagsFromStreamInput) (*request.Request, *kinesis.RemoveTagsFromStreamOutput)) {
	fake.removeTagsFromStreamRequestMutex.Lock()
	defer fake.removeTagsFromStreamRequestMutex.Unlock()
	fake.RemoveTagsFromStreamRequestStub = stub
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamRequestArgsForCall(i int) *kinesis.RemoveTagsFromStreamInput {
	fake.removeTagsFromStreamRequestMutex.RLock()
	defer fake.removeTagsFromStreamRequestMutex.RUnlock()
	argsForCall := fake.removeTagsFromStreamRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamRequestReturns(result1 *request.Request, result2 *kinesis.RemoveTagsFromStreamOutput) {
	fake.removeTagsFromStreamRequestMutex.Lock()
	defer fake.removeTagsFromStreamRequestMutex.Unlock()
	fake.RemoveTagsFromStreamRequestStub = nil
	fake.removeTagsFromStreamRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.RemoveTagsFromStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.RemoveTagsFromStreamOutput) {
	fake.removeTagsFromStreamRequestMutex.Lock()
	defer fake.removeTagsFromStreamRequestMutex.Unlock()
	fake.RemoveTagsFromStreamRequestStub = nil
	if fake.removeTagsFromStreamRequestReturnsOnCall == nil {
		fake.removeTagsFromStreamRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.RemoveTagsFromStreamOutput
		})
	}
	fake.removeTagsFromStreamRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.RemoveTagsFromStreamOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamWithContext(arg1 context.Context, arg2 *kinesis.RemoveTagsFromStreamInput, arg3 ...request.Option) (*kinesis.RemoveTagsFromStreamOutput, error) {
	fake.removeTagsFromStreamWithContextMutex.Lock()
	ret, specificReturn := fake.removeTagsFromStreamWithContextReturnsOnCall[len(fake.removeTagsFromStreamWithContextArgsForCall)]
	fake.removeTagsFromStreamWithContextArgsForCall = append(fake.removeTagsFromStreamWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.RemoveTagsFromStreamInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.RemoveTagsFromStreamWithContextStub
	fakeReturns := fake.removeTagsFromStreamWithContextReturns
	fake.recordInvocation("RemoveTagsFromStreamWithContext", []interface{}{arg1, arg2, arg3})
	fake.removeTagsFromStreamWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamWithContextCallCount() int {
	fake.removeTagsFromStreamWithContextMutex.RLock()
	defer fake.removeTagsFromStreamWithContextMutex.RUnlock()
	return len(fake.removeTagsFromStreamWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamWithContextCalls(stub func(context.Context, *kinesis.RemoveTagsFromStreamInput, ...request.Option) (*kinesis.RemoveTagsFromStreamOutput, error)) {
	fake.removeTagsFromStreamWithContextMutex.Lock()
	defer fake.removeTagsFromStreamWithContextMutex.Unlock()
	fake.RemoveTagsFromStreamWithContextStub = stub
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamWithContextArgsForCall(i int) (context.Context, *kinesis.RemoveTagsFromStreamInput, []request.Option) {
	fake.removeTagsFromStreamWithContextMutex.RLock()
	defer fake.removeTagsFromStreamWithContextMutex.RUnlock()
	argsForCall := fake.removeTagsFromStreamWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamWithContextReturns(result1 *kinesis.RemoveTagsFromStreamOutput, result2 error) {
	fake.removeTagsFromStreamWithContextMutex.Lock()
	defer fake.removeTagsFromStreamWithContextMutex.Unlock()
	fake.RemoveTagsFromStreamWithContextStub = nil
	fake.removeTagsFromStreamWithContextReturns = struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) RemoveTagsFromStreamWithContextReturnsOnCall(i int, result1 *kinesis.RemoveTagsFromStreamOutput, result2 error) {
	fake.removeTagsFromStreamWithContextMutex.Lock()
	defer fake.removeTagsFromStreamWithContextMutex.Unlock()
	fake.RemoveTagsFromStreamWithContextStub = nil
	if fake.removeTagsFromStreamWithContextReturnsOnCall == nil {
		fake.removeTagsFromStreamWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.RemoveTagsFromStreamOutput
			result2 error
		})
	}
	fake.removeTagsFromStreamWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.RemoveTagsFromStreamOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SplitShard(arg1 *kinesis.SplitShardInput) (*kinesis.SplitShardOutput, error) {
	fake.splitShardMutex.Lock()
	ret, specificReturn := fake.splitShardReturnsOnCall[len(fake.splitShardArgsForCall)]
	fake.splitShardArgsForCall = append(fake.splitShardArgsForCall, struct {
		arg1 *kinesis.SplitShardInput
	}{arg1})
	stub := fake.SplitShardStub
	fakeReturns := fake.splitShardReturns
	fake.recordInvocation("SplitShard", []interface{}{arg1})
	fake.splitShardMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) SplitShardCallCount() int {
	fake.splitShardMutex.RLock()
	defer fake.splitShardMutex.RUnlock()
	return len(fake.splitShardArgsForCall)
}

func (fake *FakeKinesisAPI) SplitShardCalls(stub func(*kinesis.SplitShardInput) (*kinesis.SplitShardOutput, error)) {
	fake.splitShardMutex.Lock()
	defer fake.splitShardMutex.Unlock()
	fake.SplitShardStub = stub
}

func (fake *FakeKinesisAPI) SplitShardArgsForCall(i int) *kinesis.SplitShardInput {
	fake.splitShardMutex.RLock()
	defer fake.splitShardMutex.RUnlock()
	argsForCall := fake.splitShardArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) SplitShardReturns(result1 *kinesis.SplitShardOutput, result2 error) {
	fake.splitShardMutex.Lock()
	defer fake.splitShardMutex.Unlock()
	fake.SplitShardStub = nil
	fake.splitShardReturns = struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SplitShardReturnsOnCall(i int, result1 *kinesis.SplitShardOutput, result2 error) {
	fake.splitShardMutex.Lock()
	defer fake.splitShardMutex.Unlock()
	fake.SplitShardStub = nil
	if fake.splitShardReturnsOnCall == nil {
		fake.splitShardReturnsOnCall = make(map[int]struct {
			result1 *kinesis.SplitShardOutput
			result2 error
		})
	}
	fake.splitShardReturnsOnCall[i] = struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SplitShardRequest(arg1 *kinesis.SplitShardInput) (*request.Request, *kinesis.SplitShardOutput) {
	fake.splitShardRequestMutex.Lock()
	ret, specificReturn := fake.splitShardRequestReturnsOnCall[len(fake.splitShardRequestArgsForCall)]
	fake.splitShardRequestArgsForCall = append(fake.splitShardRequestArgsForCall, struct {
		arg1 *kinesis.SplitShardInput
	}{arg1})
	stub := fake.SplitShardRequestStub
	fakeReturns := fake.splitShardRequestReturns
	fake.recordInvocation("SplitShardRequest", []interface{}{arg1})
	fake.splitShardRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) SplitShardRequestCallCount() int {
	fake.splitShardRequestMutex.RLock()
	defer fake.splitShardRequestMutex.RUnlock()
	return len(fake.splitShardRequestArgsForCall)
}

func (fake *FakeKinesisAPI) SplitShardRequestCalls(stub func(*kinesis.SplitShardInput) (*request.Request, *kinesis.SplitShardOutput)) {
	fake.splitShardRequestMutex.Lock()
	defer fake.splitShardRequestMutex.Unlock()
	fake.SplitShardRequestStub = stub
}

func (fake *FakeKinesisAPI) SplitShardRequestArgsForCall(i int) *kinesis.SplitShardInput {
	fake.splitShardRequestMutex.RLock()
	defer fake.splitShardRequestMutex.RUnlock()
	argsForCall := fake.splitShardRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) SplitShardRequestReturns(result1 *request.Request, result2 *kinesis.SplitShardOutput) {
	fake.splitShardRequestMutex.Lock()
	defer fake.splitShardRequestMutex.Unlock()
	fake.SplitShardRequestStub = nil
	fake.splitShardRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.SplitShardOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SplitShardRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.SplitShardOutput) {
	fake.splitShardRequestMutex.Lock()
	defer fake.splitShardRequestMutex.Unlock()
	fake.SplitShardRequestStub = nil
	if fake.splitShardRequestReturnsOnCall == nil {
		fake.splitShardRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.SplitShardOutput
		})
	}
	fake.splitShardRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.SplitShardOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SplitShardWithContext(arg1 context.Context, arg2 *kinesis.SplitShardInput, arg3 ...request.Option) (*kinesis.SplitShardOutput, error) {
	fake.splitShardWithContextMutex.Lock()
	ret, specificReturn := fake.splitShardWithContextReturnsOnCall[len(fake.splitShardWithContextArgsForCall)]
	fake.splitShardWithContextArgsForCall = append(fake.splitShardWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.SplitShardInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.SplitShardWithContextStub
	fakeReturns := fake.splitShardWithContextReturns
	fake.recordInvocation("SplitShardWithContext", []interface{}{arg1, arg2, arg3})
	fake.splitShardWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) SplitShardWithContextCallCount() int {
	fake.splitShardWithContextMutex.RLock()
	defer fake.splitShardWithContextMutex.RUnlock()
	return len(fake.splitShardWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) SplitShardWithContextCalls(stub func(context.Context, *kinesis.SplitShardInput, ...request.Option) (*kinesis.SplitShardOutput, error)) {
	fake.splitShardWithContextMutex.Lock()
	defer fake.splitShardWithContextMutex.Unlock()
	fake.SplitShardWithContextStub = stub
}

func (fake *FakeKinesisAPI) SplitShardWithContextArgsForCall(i int) (context.Context, *kinesis.SplitShardInput, []request.Option) {
	fake.splitShardWithContextMutex.RLock()
	defer fake.splitShardWithContextMutex.RUnlock()
	argsForCall := fake.splitShardWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) SplitShardWithContextReturns(result1 *kinesis.SplitShardOutput, result2 error) {
	fake.splitShardWithContextMutex.Lock()
	defer fake.splitShardWithContextMutex.Unlock()
	fake.SplitShardWithContextStub = nil
	fake.splitShardWithContextReturns = struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SplitShardWithContextReturnsOnCall(i int, result1 *kinesis.SplitShardOutput, result2 error) {
	fake.splitShardWithContextMutex.Lock()
	defer fake.splitShardWithContextMutex.Unlock()
	fake.SplitShardWithContextStub = nil
	if fake.splitShardWithContextReturnsOnCall == nil {
		fake.splitShardWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.SplitShardOutput
			result2 error
		})
	}
	fake.splitShardWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.SplitShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StartStreamEncryption(arg1 *kinesis.StartStreamEncryptionInput) (*kinesis.StartStreamEncryptionOutput, error) {
	fake.startStreamEncryptionMutex.Lock()
	ret, specificReturn := fake.startStreamEncryptionReturnsOnCall[len(fake.startStreamEncryptionArgsForCall)]
	fake.startStreamEncryptionArgsForCall = append(fake.startStreamEncryptionArgsForCall, struct {
		arg1 *kinesis.StartStreamEncryptionInput
	}{arg1})
	stub := fake.StartStreamEncryptionStub
	fakeReturns := fake.startStreamEncryptionReturns
	fake.recordInvocation("StartStreamEncryption", []interface{}{arg1})
	fake.startStreamEncryptionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) StartStreamEncryptionCallCount() int {
	fake.startStreamEncryptionMutex.RLock()
	defer fake.startStreamEncryptionMutex.RUnlock()
	return len(fake.startStreamEncryptionArgsForCall)
}

func (fake *FakeKinesisAPI) StartStreamEncryptionCalls(stub func(*kinesis.StartStreamEncryptionInput) (*kinesis.StartStreamEncryptionOutput, error)) {
	fake.startStreamEncryptionMutex.Lock()
	defer fake.startStreamEncryptionMutex.Unlock()
	fake.StartStreamEncryptionStub = stub
}

func (fake *FakeKinesisAPI) StartStreamEncryptionArgsForCall(i int) *kinesis.StartStreamEncryptionInput {
	fake.startStreamEncryptionMutex.RLock()
	defer fake.startStreamEncryptionMutex.RUnlock()
	argsForCall := fake.startStreamEncryptionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) StartStreamEncryptionReturns(result1 *kinesis.StartStreamEncryptionOutput, result2 error) {
	fake.startStreamEncryptionMutex.Lock()
	defer fake.startStreamEncryptionMutex.Unlock()
	fake.StartStreamEncryptionStub = nil
	fake.startStreamEncryptionReturns = struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StartStreamEncryptionReturnsOnCall(i int, result1 *kinesis.StartStreamEncryptionOutput, result2 error) {
	fake.startStreamEncryptionMutex.Lock()
	defer fake.startStreamEncryptionMutex.Unlock()
	fake.StartStreamEncryptionStub = nil
	if fake.startStreamEncryptionReturnsOnCall == nil {
		fake.startStreamEncryptionReturnsOnCall = make(map[int]struct {
			result1 *kinesis.StartStreamEncryptionOutput
			result2 error
		})
	}
	fake.startStreamEncryptionReturnsOnCall[i] = struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StartStreamEncryptionRequest(arg1 *kinesis.StartStreamEncryptionInput) (*request.Request, *kinesis.StartStreamEncryptionOutput) {
	fake.startStreamEncryptionRequestMutex.Lock()
	ret, specificReturn := fake.startStreamEncryptionRequestReturnsOnCall[len(fake.startStreamEncryptionRequestArgsForCall)]
	fake.startStreamEncryptionRequestArgsForCall = append(fake.startStreamEncryptionRequestArgsForCall, struct {
		arg1 *kinesis.StartStreamEncryptionInput
	}{arg1})
	stub := fake.StartStreamEncryptionRequestStub
	fakeReturns := fake.startStreamEncryptionRequestReturns
	fake.recordInvocation("StartStreamEncryptionRequest", []interface{}{arg1})
	fake.startStreamEncryptionRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) StartStreamEncryptionRequestCallCount() int {
	fake.startStreamEncryptionRequestMutex.RLock()
	defer fake.startStreamEncryptionRequestMutex.RUnlock()
	return len(fake.startStreamEncryptionRequestArgsForCall)
}

func (fake *FakeKinesisAPI) StartStreamEncryptionRequestCalls(stub func(*kinesis.StartStreamEncryptionInput) (*request.Request, *kinesis.StartStreamEncryptionOutput)) {
	fake.startStreamEncryptionRequestMutex.Lock()
	defer fake.startStreamEncryptionRequestMutex.Unlock()
	fake.StartStreamEncryptionRequestStub = stub
}

func (fake *FakeKinesisAPI) StartStreamEncryptionRequestArgsForCall(i int) *kinesis.StartStreamEncryptionInput {
	fake.startStreamEncryptionRequestMutex.RLock()
	defer fake.startStreamEncryptionRequestMutex.RUnlock()
	argsForCall := fake.startStreamEncryptionRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) StartStreamEncryptionRequestReturns(result1 *request.Request, result2 *kinesis.StartStreamEncryptionOutput) {
	fake.startStreamEncryptionRequestMutex.Lock()
	defer fake.startStreamEncryptionRequestMutex.Unlock()
	fake.StartStreamEncryptionRequestStub = nil
	fake.startStreamEncryptionRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.StartStreamEncryptionOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StartStreamEncryptionRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.StartStreamEncryptionOutput) {
	fake.startStreamEncryptionRequestMutex.Lock()
	defer fake.startStreamEncryptionRequestMutex.Unlock()
	fake.StartStreamEncryptionRequestStub = nil
	if fake.startStreamEncryptionRequestReturnsOnCall == nil {
		fake.startStreamEncryptionRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.StartStreamEncryptionOutput
		})
	}
	fake.startStreamEncryptionRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.StartStreamEncryptionOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StartStreamEncryptionWithContext(arg1 context.Context, arg2 *kinesis.StartStreamEncryptionInput, arg3 ...request.Option) (*kinesis.StartStreamEncryptionOutput, error) {
	fake.startStreamEncryptionWithContextMutex.Lock()
	ret, specificReturn := fake.startStreamEncryptionWithContextReturnsOnCall[len(fake.startStreamEncryptionWithContextArgsForCall)]
	fake.startStreamEncryptionWithContextArgsForCall = append(fake.startStreamEncryptionWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.StartStreamEncryptionInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.StartStreamEncryptionWithContextStub
	fakeReturns := fake.startStreamEncryptionWithContextReturns
	fake.recordInvocation("StartStreamEncryptionWithContext", []interface{}{arg1, arg2, arg3})
	fake.startStreamEncryptionWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) StartStreamEncryptionWithContextCallCount() int {
	fake.startStreamEncryptionWithContextMutex.RLock()
	defer fake.startStreamEncryptionWithContextMutex.RUnlock()
	return len(fake.startStreamEncryptionWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) StartStreamEncryptionWithContextCalls(stub func(context.Context, *kinesis.StartStreamEncryptionInput, ...request.Option) (*kinesis.StartStreamEncryptionOutput, error)) {
	fake.startStreamEncryptionWithContextMutex.Lock()
	defer fake.startStreamEncryptionWithContextMutex.Unlock()
	fake.StartStreamEncryptionWithContextStub = stub
}

func (fake *FakeKinesisAPI) StartStreamEncryptionWithContextArgsForCall(i int) (context.Context, *kinesis.StartStreamEncryptionInput, []request.Option) {
	fake.startStreamEncryptionWithContextMutex.RLock()
	defer fake.startStreamEncryptionWithContextMutex.RUnlock()
	argsForCall := fake.startStreamEncryptionWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) StartStreamEncryptionWithContextReturns(result1 *kinesis.StartStreamEncryptionOutput, result2 error) {
	fake.startStreamEncryptionWithContextMutex.Lock()
	defer fake.startStreamEncryptionWithContextMutex.Unlock()
	fake.StartStreamEncryptionWithContextStub = nil
	fake.startStreamEncryptionWithContextReturns = struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StartStreamEncryptionWithContextReturnsOnCall(i int, result1 *kinesis.StartStreamEncryptionOutput, result2 error) {
	fake.startStreamEncryptionWithContextMutex.Lock()
	defer fake.startStreamEncryptionWithContextMutex.Unlock()
	fake.StartStreamEncryptionWithContextStub = nil
	if fake.startStreamEncryptionWithContextReturnsOnCall == nil {
		fake.startStreamEncryptionWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.StartStreamEncryptionOutput
			result2 error
		})
	}
	fake.startStreamEncryptionWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.StartStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StopStreamEncryption(arg1 *kinesis.StopStreamEncryptionInput) (*kinesis.StopStreamEncryptionOutput, error) {
	fake.stopStreamEncryptionMutex.Lock()
	ret, specificReturn := fake.stopStreamEncryptionReturnsOnCall[len(fake.stopStreamEncryptionArgsForCall)]
	fake.stopStreamEncryptionArgsForCall = append(fake.stopStreamEncryptionArgsForCall, struct {
		arg1 *kinesis.StopStreamEncryptionInput
	}{arg1})
	stub := fake.StopStreamEncryptionStub
	fakeReturns := fake.stopStreamEncryptionReturns
	fake.recordInvocation("StopStreamEncryption", []interface{}{arg1})
	fake.stopStreamEncryptionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) StopStreamEncryptionCallCount() int {
	fake.stopStreamEncryptionMutex.RLock()
	defer fake.stopStreamEncryptionMutex.RUnlock()
	return len(fake.stopStreamEncryptionArgsForCall)
}

func (fake *FakeKinesisAPI) StopStreamEncryptionCalls(stub func(*kinesis.StopStreamEncryptionInput) (*kinesis.StopStreamEncryptionOutput, error)) {
	fake.stopStreamEncryptionMutex.Lock()
	defer fake.stopStreamEncryptionMutex.Unlock()
	fake.StopStreamEncryptionStub = stub
}

func (fake *FakeKinesisAPI) StopStreamEncryptionArgsForCall(i int) *kinesis.StopStreamEncryptionInput {
	fake.stopStreamEncryptionMutex.RLock()
	defer fake.stopStreamEncryptionMutex.RUnlock()
	argsForCall := fake.stopStreamEncryptionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) StopStreamEncryptionReturns(result1 *kinesis.StopStreamEncryptionOutput, result2 error) {
	fake.stopStreamEncryptionMutex.Lock()
	defer fake.stopStreamEncryptionMutex.Unlock()
	fake.StopStreamEncryptionStub = nil
	fake.stopStreamEncryptionReturns = struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StopStreamEncryptionReturnsOnCall(i int, result1 *kinesis.StopStreamEncryptionOutput, result2 error) {
	fake.stopStreamEncryptionMutex.Lock()
	defer fake.stopStreamEncryptionMutex.Unlock()
	fake.StopStreamEncryptionStub = nil
	if fake.stopStreamEncryptionReturnsOnCall == nil {
		fake.stopStreamEncryptionReturnsOnCall = make(map[int]struct {
			result1 *kinesis.StopStreamEncryptionOutput
			result2 error
		})
	}
	fake.stopStreamEncryptionReturnsOnCall[i] = struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StopStreamEncryptionRequest(arg1 *kinesis.StopStreamEncryptionInput) (*request.Request, *kinesis.StopStreamEncryptionOutput) {
	fake.stopStreamEncryptionRequestMutex.Lock()
	ret, specificReturn := fake.stopStreamEncryptionRequestReturnsOnCall[len(fake.stopStreamEncryptionRequestArgsForCall)]
	fake.stopStreamEncryptionRequestArgsForCall = append(fake.stopStreamEncryptionRequestArgsForCall, struct {
		arg1 *kinesis.StopStreamEncryptionInput
	}{arg1})
	stub := fake.StopStreamEncryptionRequestStub
	fakeReturns := fake.stopStreamEncryptionRequestReturns
	fake.recordInvocation("StopStreamEncryptionRequest", []interface{}{arg1})
	fake.stopStreamEncryptionRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) StopStreamEncryptionRequestCallCount() int {
	fake.stopStreamEncryptionRequestMutex.RLock()
	defer fake.stopStreamEncryptionRequestMutex.RUnlock()
	return len(fake.stopStreamEncryptionRequestArgsForCall)
}

func (fake *FakeKinesisAPI) StopStreamEncryptionRequestCalls(stub func(*kinesis.StopStreamEncryptionInput) (*request.Request, *kinesis.StopStreamEncryptionOutput)) {
	fake.stopStreamEncryptionRequestMutex.Lock()
	defer fake.stopStreamEncryptionRequestMutex.Unlock()
	fake.StopStreamEncryptionRequestStub = stub
}

func (fake *FakeKinesisAPI) StopStreamEncryptionRequestArgsForCall(i int) *kinesis.StopStreamEncryptionInput {
	fake.stopStreamEncryptionRequestMutex.RLock()
	defer fake.stopStreamEncryptionRequestMutex.RUnlock()
	argsForCall := fake.stopStreamEncryptionRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) StopStreamEncryptionRequestReturns(result1 *request.Request, result2 *kinesis.StopStreamEncryptionOutput) {
	fake.stopStreamEncryptionRequestMutex.Lock()
	defer fake.stopStreamEncryptionRequestMutex.Unlock()
	fake.StopStreamEncryptionRequestStub = nil
	fake.stopStreamEncryptionRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.StopStreamEncryptionOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StopStreamEncryptionRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.StopStreamEncryptionOutput) {
	fake.stopStreamEncryptionRequestMutex.Lock()
	defer fake.stopStreamEncryptionRequestMutex.Unlock()
	fake.StopStreamEncryptionRequestStub = nil
	if fake.stopStreamEncryptionRequestReturnsOnCall == nil {
		fake.stopStreamEncryptionRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.StopStreamEncryptionOutput
		})
	}
	fake.stopStreamEncryptionRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.StopStreamEncryptionOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StopStreamEncryptionWithContext(arg1 context.Context, arg2 *kinesis.StopStreamEncryptionInput, arg3 ...request.Option) (*kinesis.StopStreamEncryptionOutput, error) {
	fake.stopStreamEncryptionWithContextMutex.Lock()
	ret, specificReturn := fake.stopStreamEncryptionWithContextReturnsOnCall[len(fake.stopStreamEncryptionWithContextArgsForCall)]
	fake.stopStreamEncryptionWithContextArgsForCall = append(fake.stopStreamEncryptionWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.StopStreamEncryptionInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.StopStreamEncryptionWithContextStub
	fakeReturns := fake.stopStreamEncryptionWithContextReturns
	fake.recordInvocation("StopStreamEncryptionWithContext", []interface{}{arg1, arg2, arg3})
	fake.stopStreamEncryptionWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) StopStreamEncryptionWithContextCallCount() int {
	fake.stopStreamEncryptionWithContextMutex.RLock()
	defer fake.stopStreamEncryptionWithContextMutex.RUnlock()
	return len(fake.stopStreamEncryptionWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) StopStreamEncryptionWithContextCalls(stub func(context.Context, *kinesis.StopStreamEncryptionInput, ...request.Option) (*kinesis.StopStreamEncryptionOutput, error)) {
	fake.stopStreamEncryptionWithContextMutex.Lock()
	defer fake.stopStreamEncryptionWithContextMutex.Unlock()
	fake.StopStreamEncryptionWithContextStub = stub
}

func (fake *FakeKinesisAPI) StopStreamEncryptionWithContextArgsForCall(i int) (context.Context, *kinesis.StopStreamEncryptionInput, []request.Option) {
	fake.stopStreamEncryptionWithContextMutex.RLock()
	defer fake.stopStreamEncryptionWithContextMutex.RUnlock()
	argsForCall := fake.stopStreamEncryptionWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) StopStreamEncryptionWithContextReturns(result1 *kinesis.StopStreamEncryptionOutput, result2 error) {
	fake.stopStreamEncryptionWithContextMutex.Lock()
	defer fake.stopStreamEncryptionWithContextMutex.Unlock()
	fake.StopStreamEncryptionWithContextStub = nil
	fake.stopStreamEncryptionWithContextReturns = struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) StopStreamEncryptionWithContextReturnsOnCall(i int, result1 *kinesis.StopStreamEncryptionOutput, result2 error) {
	fake.stopStreamEncryptionWithContextMutex.Lock()
	defer fake.stopStreamEncryptionWithContextMutex.Unlock()
	fake.StopStreamEncryptionWithContextStub = nil
	if fake.stopStreamEncryptionWithContextReturnsOnCall == nil {
		fake.stopStreamEncryptionWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.StopStreamEncryptionOutput
			result2 error
		})
	}
	fake.stopStreamEncryptionWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.StopStreamEncryptionOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SubscribeToShard(arg1 *kinesis.SubscribeToShardInput) (*kinesis.SubscribeToShardOutput, error) {
	fake.subscribeToShardMutex.Lock()
	ret, specificReturn := fake.subscribeToShardReturnsOnCall[len(fake.subscribeToShardArgsForCall)]
	fake.subscribeToShardArgsForCall = append(fake.subscribeToShardArgsForCall, struct {
		arg1 *kinesis.SubscribeToShardInput
	}{arg1})
	stub := fake.SubscribeToShardStub
	fakeReturns := fake.subscribeToShardReturns
	fake.recordInvocation("SubscribeToShard", []interface{}{arg1})
	fake.subscribeToShardMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) SubscribeToShardCallCount() int {
	fake.subscribeToShardMutex.RLock()
	defer fake.subscribeToShardMutex.RUnlock()
	return len(fake.subscribeToShardArgsForCall)
}

func (fake *FakeKinesisAPI) SubscribeToShardCalls(stub func(*kinesis.SubscribeToShardInput) (*kinesis.SubscribeToShardOutput, error)) {
	fake.subscribeToShardMutex.Lock()
	defer fake.subscribeToShardMutex.Unlock()
	fake.SubscribeToShardStub = stub
}

func (fake *FakeKinesisAPI) SubscribeToShardArgsForCall(i int) *kinesis.SubscribeToShardInput {
	fake.subscribeToShardMutex.RLock()
	defer fake.subscribeToShardMutex.RUnlock()
	argsForCall := fake.subscribeToShardArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) SubscribeToShardReturns(result1 *kinesis.SubscribeToShardOutput, result2 error) {
	fake.subscribeToShardMutex.Lock()
	defer fake.subscribeToShardMutex.Unlock()
	fake.SubscribeToShardStub = nil
	fake.subscribeToShardReturns = struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SubscribeToShardReturnsOnCall(i int, result1 *kinesis.SubscribeToShardOutput, result2 error) {
	fake.subscribeToShardMutex.Lock()
	defer fake.subscribeToShardMutex.Unlock()
	fake.SubscribeToShardStub = nil
	if fake.subscribeToShardReturnsOnCall == nil {
		fake.subscribeToShardReturnsOnCall = make(map[int]struct {
			result1 *kinesis.SubscribeToShardOutput
			result2 error
		})
	}
	fake.subscribeToShardReturnsOnCall[i] = struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SubscribeToShardRequest(arg1 *kinesis.SubscribeToShardInput) (*request.Request, *kinesis.SubscribeToShardOutput) {
	fake.subscribeToShardRequestMutex.Lock()
	ret, specificReturn := fake.subscribeToShardRequestReturnsOnCall[len(fake.subscribeToShardRequestArgsForCall)]
	fake.subscribeToShardRequestArgsForCall = append(fake.subscribeToShardRequestArgsForCall, struct {
		arg1 *kinesis.SubscribeToShardInput
	}{arg1})
	stub := fake.SubscribeToShardRequestStub
	fakeReturns := fake.subscribeToShardRequestReturns
	fake.recordInvocation("SubscribeToShardRequest", []interface{}{arg1})
	fake.subscribeToShardRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) SubscribeToShardRequestCallCount() int {
	fake.subscribeToShardRequestMutex.RLock()
	defer fake.subscribeToShardRequestMutex.RUnlock()
	return len(fake.subscribeToShardRequestArgsForCall)
}

func (fake *FakeKinesisAPI) SubscribeToShardRequestCalls(stub func(*kinesis.SubscribeToShardInput) (*request.Request, *kinesis.SubscribeToShardOutput)) {
	fake.subscribeToShardRequestMutex.Lock()
	defer fake.subscribeToShardRequestMutex.Unlock()
	fake.SubscribeToShardRequestStub = stub
}

func (fake *FakeKinesisAPI) SubscribeToShardRequestArgsForCall(i int) *kinesis.SubscribeToShardInput {
	fake.subscribeToShardRequestMutex.RLock()
	defer fake.subscribeToShardRequestMutex.RUnlock()
	argsForCall := fake.subscribeToShardRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) SubscribeToShardRequestReturns(result1 *request.Request, result2 *kinesis.SubscribeToShardOutput) {
	fake.subscribeToShardRequestMutex.Lock()
	defer fake.subscribeToShardRequestMutex.Unlock()
	fake.SubscribeToShardRequestStub = nil
	fake.subscribeToShardRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.SubscribeToShardOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SubscribeToShardRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.SubscribeToShardOutput) {
	fake.subscribeToShardRequestMutex.Lock()
	defer fake.subscribeToShardRequestMutex.Unlock()
	fake.SubscribeToShardRequestStub = nil
	if fake.subscribeToShardRequestReturnsOnCall == nil {
		fake.subscribeToShardRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.SubscribeToShardOutput
		})
	}
	fake.subscribeToShardRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.SubscribeToShardOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SubscribeToShardWithContext(arg1 context.Context, arg2 *kinesis.SubscribeToShardInput, arg3 ...request.Option) (*kinesis.SubscribeToShardOutput, error) {
	fake.subscribeToShardWithContextMutex.Lock()
	ret, specificReturn := fake.subscribeToShardWithContextReturnsOnCall[len(fake.subscribeToShardWithContextArgsForCall)]
	fake.subscribeToShardWithContextArgsForCall = append(fake.subscribeToShardWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.SubscribeToShardInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.SubscribeToShardWithContextStub
	fakeReturns := fake.subscribeToShardWithContextReturns
	fake.recordInvocation("SubscribeToShardWithContext", []interface{}{arg1, arg2, arg3})
	fake.subscribeToShardWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) SubscribeToShardWithContextCallCount() int {
	fake.subscribeToShardWithContextMutex.RLock()
	defer fake.subscribeToShardWithContextMutex.RUnlock()
	return len(fake.subscribeToShardWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) SubscribeToShardWithContextCalls(stub func(context.Context, *kinesis.SubscribeToShardInput, ...request.Option) (*kinesis.SubscribeToShardOutput, error)) {
	fake.subscribeToShardWithContextMutex.Lock()
	defer fake.subscribeToShardWithContextMutex.Unlock()
	fake.SubscribeToShardWithContextStub = stub
}

func (fake *FakeKinesisAPI) SubscribeToShardWithContextArgsForCall(i int) (context.Context, *kinesis.SubscribeToShardInput, []request.Option) {
	fake.subscribeToShardWithContextMutex.RLock()
	defer fake.subscribeToShardWithContextMutex.RUnlock()
	argsForCall := fake.subscribeToShardWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) SubscribeToShardWithContextReturns(result1 *kinesis.SubscribeToShardOutput, result2 error) {
	fake.subscribeToShardWithContextMutex.Lock()
	defer fake.subscribeToShardWithContextMutex.Unlock()
	fake.SubscribeToShardWithContextStub = nil
	fake.subscribeToShardWithContextReturns = struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) SubscribeToShardWithContextReturnsOnCall(i int, result1 *kinesis.SubscribeToShardOutput, result2 error) {
	fake.subscribeToShardWithContextMutex.Lock()
	defer fake.subscribeToShardWithContextMutex.Unlock()
	fake.SubscribeToShardWithContextStub = nil
	if fake.subscribeToShardWithContextReturnsOnCall == nil {
		fake.subscribeToShardWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.SubscribeToShardOutput
			result2 error
		})
	}
	fake.subscribeToShardWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.SubscribeToShardOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) UpdateShardCount(arg1 *kinesis.UpdateShardCountInput) (*kinesis.UpdateShardCountOutput, error) {
	fake.updateShardCountMutex.Lock()
	ret, specificReturn := fake.updateShardCountReturnsOnCall[len(fake.updateShardCountArgsForCall)]
	fake.updateShardCountArgsForCall = append(fake.updateShardCountArgsForCall, struct {
		arg1 *kinesis.UpdateShardCountInput
	}{arg1})
	stub := fake.UpdateShardCountStub
	fakeReturns := fake.updateShardCountReturns
	fake.recordInvocation("UpdateShardCount", []interface{}{arg1})
	fake.updateShardCountMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) UpdateShardCountCallCount() int {
	fake.updateShardCountMutex.RLock()
	defer fake.updateShardCountMutex.RUnlock()
	return len(fake.updateShardCountArgsForCall)
}

func (fake *FakeKinesisAPI) UpdateShardCountCalls(stub func(*kinesis.UpdateShardCountInput) (*kinesis.UpdateShardCountOutput, error)) {
	fake.updateShardCountMutex.Lock()
	defer fake.updateShardCountMutex.Unlock()
	fake.UpdateShardCountStub = stub
}

func (fake *FakeKinesisAPI) UpdateShardCountArgsForCall(i int) *kinesis.UpdateShardCountInput {
	fake.updateShardCountMutex.RLock()
	defer fake.updateShardCountMutex.RUnlock()
	argsForCall := fake.updateShardCountArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) UpdateShardCountReturns(result1 *kinesis.UpdateShardCountOutput, result2 error) {
	fake.updateShardCountMutex.Lock()
	defer fake.updateShardCountMutex.Unlock()
	fake.UpdateShardCountStub = nil
	fake.updateShardCountReturns = struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) UpdateShardCountReturnsOnCall(i int, result1 *kinesis.UpdateShardCountOutput, result2 error) {
	fake.updateShardCountMutex.Lock()
	defer fake.updateShardCountMutex.Unlock()
	fake.UpdateShardCountStub = nil
	if fake.updateShardCountReturnsOnCall == nil {
		fake.updateShardCountReturnsOnCall = make(map[int]struct {
			result1 *kinesis.UpdateShardCountOutput
			result2 error
		})
	}
	fake.updateShardCountReturnsOnCall[i] = struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) UpdateShardCountRequest(arg1 *kinesis.UpdateShardCountInput) (*request.Request, *kinesis.UpdateShardCountOutput) {
	fake.updateShardCountRequestMutex.Lock()
	ret, specificReturn := fake.updateShardCountRequestReturnsOnCall[len(fake.updateShardCountRequestArgsForCall)]
	fake.updateShardCountRequestArgsForCall = append(fake.updateShardCountRequestArgsForCall, struct {
		arg1 *kinesis.UpdateShardCountInput
	}{arg1})
	stub := fake.UpdateShardCountRequestStub
	fakeReturns := fake.updateShardCountRequestReturns
	fake.recordInvocation("UpdateShardCountRequest", []interface{}{arg1})
	fake.updateShardCountRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) UpdateShardCountRequestCallCount() int {
	fake.updateShardCountRequestMutex.RLock()
	defer fake.updateShardCountRequestMutex.RUnlock()
	return len(fake.updateShardCountRequestArgsForCall)
}

func (fake *FakeKinesisAPI) UpdateShardCountRequestCalls(stub func(*kinesis.UpdateShardCountInput) (*request.Request, *kinesis.UpdateShardCountOutput)) {
	fake.updateShardCountRequestMutex.Lock()
	defer fake.updateShardCountRequestMutex.Unlock()
	fake.UpdateShardCountRequestStub = stub
}

func (fake *FakeKinesisAPI) UpdateShardCountRequestArgsForCall(i int) *kinesis.UpdateShardCountInput {
	fake.updateShardCountRequestMutex.RLock()
	defer fake.updateShardCountRequestMutex.RUnlock()
	argsForCall := fake.updateShardCountRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) UpdateShardCountRequestReturns(result1 *request.Request, result2 *kinesis.UpdateShardCountOutput) {
	fake.updateShardCountRequestMutex.Lock()
	defer fake.updateShardCountRequestMutex.Unlock()
	fake.UpdateShardCountRequestStub = nil
	fake.updateShardCountRequestReturns = struct {
		result1 *request.Request
		result2 *kinesis.UpdateShardCountOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) UpdateShardCountRequestReturnsOnCall(i int, result1 *request.Request, result2 *kinesis.UpdateShardCountOutput) {
	fake.updateShardCountRequestMutex.Lock()
	defer fake.updateShardCountRequestMutex.Unlock()
	fake.UpdateShardCountRequestStub = nil
	if fake.updateShardCountRequestReturnsOnCall == nil {
		fake.updateShardCountRequestReturnsOnCall = make(map[int]struct {
			result1 *request.Request
			result2 *kinesis.UpdateShardCountOutput
		})
	}
	fake.updateShardCountRequestReturnsOnCall[i] = struct {
		result1 *request.Request
		result2 *kinesis.UpdateShardCountOutput
	}{result1, result2}
}

func (fake *FakeKinesisAPI) UpdateShardCountWithContext(arg1 context.Context, arg2 *kinesis.UpdateShardCountInput, arg3 ...request.Option) (*kinesis.UpdateShardCountOutput, error) {
	fake.updateShardCountWithContextMutex.Lock()
	ret, specificReturn := fake.updateShardCountWithContextReturnsOnCall[len(fake.updateShardCountWithContextArgsForCall)]
	fake.updateShardCountWithContextArgsForCall = append(fake.updateShardCountWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.UpdateShardCountInput
		arg3 []request.Option
	}{arg1, arg2, arg3})
	stub := fake.UpdateShardCountWithContextStub
	fakeReturns := fake.updateShardCountWithContextReturns
	fake.recordInvocation("UpdateShardCountWithContext", []interface{}{arg1, arg2, arg3})
	fake.updateShardCountWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKinesisAPI) UpdateShardCountWithContextCallCount() int {
	fake.updateShardCountWithContextMutex.RLock()
	defer fake.updateShardCountWithContextMutex.RUnlock()
	return len(fake.updateShardCountWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) UpdateShardCountWithContextCalls(stub func(context.Context, *kinesis.UpdateShardCountInput, ...request.Option) (*kinesis.UpdateShardCountOutput, error)) {
	fake.updateShardCountWithContextMutex.Lock()
	defer fake.updateShardCountWithContextMutex.Unlock()
	fake.UpdateShardCountWithContextStub = stub
}

func (fake *FakeKinesisAPI) UpdateShardCountWithContextArgsForCall(i int) (context.Context, *kinesis.UpdateShardCountInput, []request.Option) {
	fake.updateShardCountWithContextMutex.RLock()
	defer fake.updateShardCountWithContextMutex.RUnlock()
	argsForCall := fake.updateShardCountWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) UpdateShardCountWithContextReturns(result1 *kinesis.UpdateShardCountOutput, result2 error) {
	fake.updateShardCountWithContextMutex.Lock()
	defer fake.updateShardCountWithContextMutex.Unlock()
	fake.UpdateShardCountWithContextStub = nil
	fake.updateShardCountWithContextReturns = struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) UpdateShardCountWithContextReturnsOnCall(i int, result1 *kinesis.UpdateShardCountOutput, result2 error) {
	fake.updateShardCountWithContextMutex.Lock()
	defer fake.updateShardCountWithContextMutex.Unlock()
	fake.UpdateShardCountWithContextStub = nil
	if fake.updateShardCountWithContextReturnsOnCall == nil {
		fake.updateShardCountWithContextReturnsOnCall = make(map[int]struct {
			result1 *kinesis.UpdateShardCountOutput
			result2 error
		})
	}
	fake.updateShardCountWithContextReturnsOnCall[i] = struct {
		result1 *kinesis.UpdateShardCountOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeKinesisAPI) WaitUntilStreamExists(arg1 *kinesis.DescribeStreamInput) error {
	fake.waitUntilStreamExistsMutex.Lock()
	ret, specificReturn := fake.waitUntilStreamExistsReturnsOnCall[len(fake.waitUntilStreamExistsArgsForCall)]
	fake.waitUntilStreamExistsArgsForCall = append(fake.waitUntilStreamExistsArgsForCall, struct {
		arg1 *kinesis.DescribeStreamInput
	}{arg1})
	stub := fake.WaitUntilStreamExistsStub
	fakeReturns := fake.waitUntilStreamExistsReturns
	fake.recordInvocation("WaitUntilStreamExists", []interface{}{arg1})
	fake.waitUntilStreamExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsCallCount() int {
	fake.waitUntilStreamExistsMutex.RLock()
	defer fake.waitUntilStreamExistsMutex.RUnlock()
	return len(fake.waitUntilStreamExistsArgsForCall)
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsCalls(stub func(*kinesis.DescribeStreamInput) error) {
	fake.waitUntilStreamExistsMutex.Lock()
	defer fake.waitUntilStreamExistsMutex.Unlock()
	fake.WaitUntilStreamExistsStub = stub
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsArgsForCall(i int) *kinesis.DescribeStreamInput {
	fake.waitUntilStreamExistsMutex.RLock()
	defer fake.waitUntilStreamExistsMutex.RUnlock()
	argsForCall := fake.waitUntilStreamExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsReturns(result1 error) {
	fake.waitUntilStreamExistsMutex.Lock()
	defer fake.waitUntilStreamExistsMutex.Unlock()
	fake.WaitUntilStreamExistsStub = nil
	fake.waitUntilStreamExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsReturnsOnCall(i int, result1 error) {
	fake.waitUntilStreamExistsMutex.Lock()
	defer fake.waitUntilStreamExistsMutex.Unlock()
	fake.WaitUntilStreamExistsStub = nil
	if fake.waitUntilStreamExistsReturnsOnCall == nil {
		fake.waitUntilStreamExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilStreamExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsWithContext(arg1 context.Context, arg2 *kinesis.DescribeStreamInput, arg3 ...request.WaiterOption) error {
	fake.waitUntilStreamExistsWithContextMutex.Lock()
	ret, specificReturn := fake.waitUntilStreamExistsWithContextReturnsOnCall[len(fake.waitUntilStreamExistsWithContextArgsForCall)]
	fake.waitUntilStreamExistsWithContextArgsForCall = append(fake.waitUntilStreamExistsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 []request.WaiterOption
	}{arg1, arg2, arg3})
	stub := fake.WaitUntilStreamExistsWithContextStub
	fakeReturns := fake.waitUntilStreamExistsWithContextReturns
	fake.recordInvocation("WaitUntilStreamExistsWithContext", []interface{}{arg1, arg2, arg3})
	fake.waitUntilStreamExistsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsWithContextCallCount() int {
	fake.waitUntilStreamExistsWithContextMutex.RLock()
	defer fake.waitUntilStreamExistsWithContextMutex.RUnlock()
	return len(fake.waitUntilStreamExistsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsWithContextCalls(stub func(context.Context, *kinesis.DescribeStreamInput, ...request.WaiterOption) error) {
	fake.waitUntilStreamExistsWithContextMutex.Lock()
	defer fake.waitUntilStreamExistsWithContextMutex.Unlock()
	fake.WaitUntilStreamExistsWithContextStub = stub
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsWithContextArgsForCall(i int) (context.Context, *kinesis.DescribeStreamInput, []request.WaiterOption) {
	fake.waitUntilStreamExistsWithContextMutex.RLock()
	defer fake.waitUntilStreamExistsWithContextMutex.RUnlock()
	argsForCall := fake.waitUntilStreamExistsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsWithContextReturns(result1 error) {
	fake.waitUntilStreamExistsWithContextMutex.Lock()
	defer fake.waitUntilStreamExistsWithContextMutex.Unlock()
	fake.WaitUntilStreamExistsWithContextStub = nil
	fake.waitUntilStreamExistsWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) WaitUntilStreamExistsWithContextReturnsOnCall(i int, result1 error) {
	fake.waitUntilStreamExistsWithContextMutex.Lock()
	defer fake.waitUntilStreamExistsWithContextMutex.Unlock()
	fake.WaitUntilStreamExistsWithContextStub = nil
	if fake.waitUntilStreamExistsWithContextReturnsOnCall == nil {
		fake.waitUntilStreamExistsWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilStreamExistsWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExists(arg1 *kinesis.DescribeStreamInput) error {
	fake.waitUntilStreamNotExistsMutex.Lock()
	ret, specificReturn := fake.waitUntilStreamNotExistsReturnsOnCall[len(fake.waitUntilStreamNotExistsArgsForCall)]
	fake.waitUntilStreamNotExistsArgsForCall = append(fake.waitUntilStreamNotExistsArgsForCall, struct {
		arg1 *kinesis.DescribeStreamInput
	}{arg1})
	stub := fake.WaitUntilStreamNotExistsStub
	fakeReturns := fake.waitUntilStreamNotExistsReturns
	fake.recordInvocation("WaitUntilStreamNotExists", []interface{}{arg1})
	fake.waitUntilStreamNotExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsCallCount() int {
	fake.waitUntilStreamNotExistsMutex.RLock()
	defer fake.waitUntilStreamNotExistsMutex.RUnlock()
	return len(fake.waitUntilStreamNotExistsArgsForCall)
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsCalls(stub func(*kinesis.DescribeStreamInput) error) {
	fake.waitUntilStreamNotExistsMutex.Lock()
	defer fake.waitUntilStreamNotExistsMutex.Unlock()
	fake.WaitUntilStreamNotExistsStub = stub
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsArgsForCall(i int) *kinesis.DescribeStreamInput {
	fake.waitUntilStreamNotExistsMutex.RLock()
	defer fake.waitUntilStreamNotExistsMutex.RUnlock()
	argsForCall := fake.waitUntilStreamNotExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsReturns(result1 error) {
	fake.waitUntilStreamNotExistsMutex.Lock()
	defer fake.waitUntilStreamNotExistsMutex.Unlock()
	fake.WaitUntilStreamNotExistsStub = nil
	fake.waitUntilStreamNotExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsReturnsOnCall(i int, result1 error) {
	fake.waitUntilStreamNotExistsMutex.Lock()
	defer fake.waitUntilStreamNotExistsMutex.Unlock()
	fake.WaitUntilStreamNotExistsStub = nil
	if fake.waitUntilStreamNotExistsReturnsOnCall == nil {
		fake.waitUntilStreamNotExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilStreamNotExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsWithContext(arg1 context.Context, arg2 *kinesis.DescribeStreamInput, arg3 ...request.WaiterOption) error {
	fake.waitUntilStreamNotExistsWithContextMutex.Lock()
	ret, specificReturn := fake.waitUntilStreamNotExistsWithContextReturnsOnCall[len(fake.waitUntilStreamNotExistsWithContextArgsForCall)]
	fake.waitUntilStreamNotExistsWithContextArgsForCall = append(fake.waitUntilStreamNotExistsWithContextArgsForCall, struct {
		arg1 context.Context
		arg2 *kinesis.DescribeStreamInput
		arg3 []request.WaiterOption
	}{arg1, arg2, arg3})
	stub := fake.WaitUntilStreamNotExistsWithContextStub
	fakeReturns := fake.waitUntilStreamNotExistsWithContextReturns
	fake.recordInvocation("WaitUntilStreamNotExistsWithContext", []interface{}{arg1, arg2, arg3})
	fake.waitUntilStreamNotExistsWithContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsWithContextCallCount() int {
	fake.waitUntilStreamNotExistsWithContextMutex.RLock()
	defer fake.waitUntilStreamNotExistsWithContextMutex.RUnlock()
	return len(fake.waitUntilStreamNotExistsWithContextArgsForCall)
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsWithContextCalls(stub func(context.Context, *kinesis.DescribeStreamInput, ...request.WaiterOption) error) {
	fake.waitUntilStreamNotExistsWithContextMutex.Lock()
	defer fake.waitUntilStreamNotExistsWithContextMutex.Unlock()
	fake.WaitUntilStreamNotExistsWithContextStub = stub
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsWithContextArgsForCall(i int) (context.Context, *kinesis.DescribeStreamInput, []request.WaiterOption) {
	fake.waitUntilStreamNotExistsWithContextMutex.RLock()
	defer fake.waitUntilStreamNotExistsWithContextMutex.RUnlock()
	argsForCall := fake.waitUntilStreamNotExistsWithContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsWithContextReturns(result1 error) {
	fake.waitUntilStreamNotExistsWithContextMutex.Lock()
	defer fake.waitUntilStreamNotExistsWithContextMutex.Unlock()
	fake.WaitUntilStreamNotExistsWithContextStub = nil
	fake.waitUntilStreamNotExistsWithContextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) WaitUntilStreamNotExistsWithContextReturnsOnCall(i int, result1 error) {
	fake.waitUntilStreamNotExistsWithContextMutex.Lock()
	defer fake.waitUntilStreamNotExistsWithContextMutex.Unlock()
	fake.WaitUntilStreamNotExistsWithContextStub = nil
	if fake.waitUntilStreamNotExistsWithContextReturnsOnCall == nil {
		fake.waitUntilStreamNotExistsWithContextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitUntilStreamNotExistsWithContextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKinesisAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addTagsToStreamMutex.RLock()
	defer fake.addTagsToStreamMutex.RUnlock()
	fake.addTagsToStreamRequestMutex.RLock()
	defer fake.addTagsToStreamRequestMutex.RUnlock()
	fake.addTagsToStreamWithContextMutex.RLock()
	defer fake.addTagsToStreamWithContextMutex.RUnlock()
	fake.createStreamMutex.RLock()
	defer fake.createStreamMutex.RUnlock()
	fake.createStreamRequestMutex.RLock()
	defer fake.createStreamRequestMutex.RUnlock()
	fake.createStreamWithContextMutex.RLock()
	defer fake.createStreamWithContextMutex.RUnlock()
	fake.decreaseStreamRetentionPeriodMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodMutex.RUnlock()
	fake.decreaseStreamRetentionPeriodRequestMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodRequestMutex.RUnlock()
	fake.decreaseStreamRetentionPeriodWithContextMutex.RLock()
	defer fake.decreaseStreamRetentionPeriodWithContextMutex.RUnlock()
	fake.deleteStreamMutex.RLock()
	defer fake.deleteStreamMutex.RUnlock()
	fake.deleteStreamRequestMutex.RLock()
	defer fake.deleteStreamRequestMutex.RUnlock()
	fake.deleteStreamWithContextMutex.RLock()
	defer fake.deleteStreamWithContextMutex.RUnlock()
	fake.deregisterStreamConsumerMutex.RLock()
	defer fake.deregisterStreamConsumerMutex.RUnlock()
	fake.deregisterStreamConsumerRequestMutex.RLock()
	defer fake.deregisterStreamConsumerRequestMutex.RUnlock()
	fake.deregisterStreamConsumerWithContextMutex.RLock()
	defer fake.deregisterStreamConsumerWithContextMutex.RUnlock()
	fake.describeLimitsMutex.RLock()
	defer fake.describeLimitsMutex.RUnlock()
	fake.describeLimitsRequestMutex.RLock()
	defer fake.describeLimitsRequestMutex.RUnlock()
	fake.describeLimitsWithContextMutex.RLock()
	defer fake.describeLimitsWithContextMutex.RUnlock()
	fake.describeStreamMutex.RLock()
	defer fake.describeStreamMutex.RUnlock()
	fake.describeStreamConsumerMutex.RLock()
	defer fake.describeStreamConsumerMutex.RUnlock()
	fake.describeStreamConsumerRequestMutex.RLock()
	defer fake.describeStreamConsumerRequestMutex.RUnlock()
	fake.describeStreamConsumerWithContextMutex.RLock()
	defer fake.describeStreamConsumerWithContextMutex.RUnlock()
	fake.describeStreamPagesMutex.RLock()
	defer fake.describeStreamPagesMutex.RUnlock()
	fake.describeStreamPagesWithContextMutex.RLock()
	defer fake.describeStreamPagesWithContextMutex.RUnlock()
	fake.describeStreamRequestMutex.RLock()
	defer fake.describeStreamRequestMutex.RUnlock()
	fake.describeStreamSummaryMutex.RLock()
	defer fake.describeStreamSummaryMutex.RUnlock()
	fake.describeStreamSummaryRequestMutex.RLock()
	defer fake.describeStreamSummaryRequestMutex.RUnlock()
	fake.describeStreamSummaryWithContextMutex.RLock()
	defer fake.describeStreamSummaryWithContextMutex.RUnlock()
	fake.describeStreamWithContextMutex.RLock()
	defer fake.describeStreamWithContextMutex.RUnlock()
	fake.disableEnhancedMonitoringMutex.RLock()
	defer fake.disableEnhancedMonitoringMutex.RUnlock()
	fake.disableEnhancedMonitoringRequestMutex.RLock()
	defer fake.disableEnhancedMonitoringRequestMutex.RUnlock()
	fake.disableEnhancedMonitoringWithContextMutex.RLock()
	defer fake.disableEnhancedMonitoringWithContextMutex.RUnlock()
	fake.enableEnhancedMonitoringMutex.RLock()
	defer fake.enableEnhancedMonitoringMutex.RUnlock()
	fake.enableEnhancedMonitoringRequestMutex.RLock()
	defer fake.enableEnhancedMonitoringRequestMutex.RUnlock()
	fake.enableEnhancedMonitoringWithContextMutex.RLock()
	defer fake.enableEnhancedMonitoringWithContextMutex.RUnlock()
	fake.getRecordsMutex.RLock()
	defer fake.getRecordsMutex.RUnlock()
	fake.getRecordsRequestMutex.RLock()
	defer fake.getRecordsRequestMutex.RUnlock()
	fake.getRecordsWithContextMutex.RLock()
	defer fake.getRecordsWithContextMutex.RUnlock()
	fake.getShardIteratorMutex.RLock()
	defer fake.getShardIteratorMutex.RUnlock()
	fake.getShardIteratorRequestMutex.RLock()
	defer fake.getShardIteratorRequestMutex.RUnlock()
	fake.getShardIteratorWithContextMutex.RLock()
	defer fake.getShardIteratorWithContextMutex.RUnlock()
	fake.increaseStreamRetentionPeriodMutex.RLock()
	defer fake.increaseStreamRetentionPeriodMutex.RUnlock()
	fake.increaseStreamRetentionPeriodRequestMutex.RLock()
	defer fake.increaseStreamRetentionPeriodRequestMutex.RUnlock()
	fake.increaseStreamRetentionPeriodWithContextMutex.RLock()
	defer fake.increaseStreamRetentionPeriodWithContextMutex.RUnlock()
	fake.listShardsMutex.RLock()
	defer fake.listShardsMutex.RUnlock()
	fake.listShardsRequestMutex.RLock()
	defer fake.listShardsRequestMutex.RUnlock()
	fake.listShardsWithContextMutex.RLock()
	defer fake.listShardsWithContextMutex.RUnlock()
	fake.listStreamConsumersMutex.RLock()
	defer fake.listStreamConsumersMutex.RUnlock()
	fake.listStreamConsumersPagesMutex.RLock()
	defer fake.listStreamConsumersPagesMutex.RUnlock()
	fake.listStreamConsumersPagesWithContextMutex.RLock()
	defer fake.listStreamConsumersPagesWithContextMutex.RUnlock()
	fake.listStreamConsumersRequestMutex.RLock()
	defer fake.listStreamConsumersRequestMutex.RUnlock()
	fake.listStreamConsumersWithContextMutex.RLock()
	defer fake.listStreamConsumersWithContextMutex.RUnlock()
	fake.listStreamsMutex.RLock()
	defer fake.listStreamsMutex.RUnlock()
	fake.listStreamsPagesMutex.RLock()
	defer fake.listStreamsPagesMutex.RUnlock()
	fake.listStreamsPagesWithContextMutex.RLock()
	defer fake.listStreamsPagesWithContextMutex.RUnlock()
	fake.listStreamsRequestMutex.RLock()
	defer fake.listStreamsRequestMutex.RUnlock()
	fake.listStreamsWithContextMutex.RLock()
	defer fake.listStreamsWithContextMutex.RUnlock()
	fake.listTagsForStreamMutex.RLock()
	defer fake.listTagsForStreamMutex.RUnlock()
	fake.listTagsForStreamRequestMutex.RLock()
	defer fake.listTagsForStreamRequestMutex.RUnlock()
	fake.listTagsForStreamWithContextMutex.RLock()
	defer fake.listTagsForStreamWithContextMutex.RUnlock()
	fake.mergeShardsMutex.RLock()
	defer fake.mergeShardsMutex.RUnlock()
	fake.mergeShardsRequestMutex.RLock()
	defer fake.mergeShardsRequestMutex.RUnlock()
	fake.mergeShardsWithContextMutex.RLock()
	defer fake.mergeShardsWithContextMutex.RUnlock()
	fake.putRecordMutex.RLock()
	defer fake.putRecordMutex.RUnlock()
	fake.putRecordRequestMutex.RLock()
	defer fake.putRecordRequestMutex.RUnlock()
	fake.putRecordWithContextMutex.RLock()
	defer fake.putRecordWithContextMutex.RUnlock()
	fake.putRecordsMutex.RLock()
	defer fake.putRecordsMutex.RUnlock()
	fake.putRecordsRequestMutex.RLock()
	defer fake.putRecordsRequestMutex.RUnlock()
	fake.putRecordsWithContextMutex.RLock()
	defer fake.putRecordsWithContextMutex.RUnlock()
	fake.registerStreamConsumerMutex.RLock()
	defer fake.registerStreamConsumerMutex.RUnlock()
	fake.registerStreamConsumerRequestMutex.RLock()
	defer fake.registerStreamConsumerRequestMutex.RUnlock()
	fake.registerStreamConsumerWithContextMutex.RLock()
	defer fake.registerStreamConsumerWithContextMutex.RUnlock()
	fake.removeTagsFromStreamMutex.RLock()
	defer fake.removeTagsFromStreamMutex.RUnlock()
	fake.removeTagsFromStreamRequestMutex.RLock()
	defer fake.removeTagsFromStreamRequestMutex.RUnlock()
	fake.removeTagsFromStreamWithContextMutex.RLock()
	defer fake.removeTagsFromStreamWithContextMutex.RUnlock()
	fake.splitShardMutex.RLock()
	defer fake.splitShardMutex.RUnlock()
	fake.splitShardRequestMutex.RLock()
	defer fake.splitShardRequestMutex.RUnlock()
	fake.splitShardWithContextMutex.RLock()
	defer fake.splitShardWithContextMutex.RUnlock()
	fake.startStreamEncryptionMutex.RLock()
	defer fake.startStreamEncryptionMutex.RUnlock()
	fake.startStreamEncryptionRequestMutex.RLock()
	defer fake.startStreamEncryptionRequestMutex.RUnlock()
	fake.startStreamEncryptionWithContextMutex.RLock()
	defer fake.startStreamEncryptionWithContextMutex.RUnlock()
	fake.stopStreamEncryptionMutex.RLock()
	defer fake.stopStreamEncryptionMutex.RUnlock()
	fake.stopStreamEncryptionRequestMutex.RLock()
	defer fake.stopStreamEncryptionRequestMutex.RUnlock()
	fake.stopStreamEncryptionWithContextMutex.RLock()
	defer fake.stopStreamEncryptionWithContextMutex.RUnlock()
	fake.subscribeToShardMutex.RLock()
	defer fake.subscribeToShardMutex.RUnlock()
	fake.subscribeToShardRequestMutex.RLock()
	defer fake.subscribeToShardRequestMutex.RUnlock()
	fake.subscribeToShardWithContextMutex.RLock()
	defer fake.subscribeToShardWithContextMutex.RUnlock()
	fake.updateShardCountMutex.RLock()
	defer fake.updateShardCountMutex.RUnlock()
	fake.updateShardCountRequestMutex.RLock()
	defer fake.updateShardCountRequestMutex.RUnlock()
	fake.updateShardCountWithContextMutex.RLock()
	defer fake.updateShardCountWithContextMutex.RUnlock()
	fake.waitUntilStreamExistsMutex.RLock()
	defer fake.waitUntilStreamExistsMutex.RUnlock()
	fake.waitUntilStreamExistsWithContextMutex.RLock()
	defer fake.waitUntilStreamExistsWithContextMutex.RUnlock()
	fake.waitUntilStreamNotExistsMutex.RLock()
	defer fake.waitUntilStreamNotExistsMutex.RUnlock()
	fake.waitUntilStreamNotExistsWithContextMutex.RLock()
	defer fake.waitUntilStreamNotExistsWithContextMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKinesisAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kinesisiface.KinesisAPI = new(FakeKinesisAPI)
